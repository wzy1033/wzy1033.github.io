<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>22暑期ACM集训周记02 | Serein</title><meta name="keywords" content="算法周记"><meta name="author" content="吴振扬"><meta name="copyright" content="吴振扬"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="函数&#x2F;递归&#x2F;STL">
<meta property="og:type" content="article">
<meta property="og:title" content="22暑期ACM集训周记02">
<meta property="og:url" content="http://example.com/2022/07/24/ACM%E5%91%A8%E8%AE%B0/%E6%9A%91%E6%9C%9FACM%E5%91%A8%E8%AE%B02/index.html">
<meta property="og:site_name" content="Serein">
<meta property="og:description" content="函数&#x2F;递归&#x2F;STL">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/noritake/12.jpg">
<meta property="article:published_time" content="2022-07-24T15:00:00.000Z">
<meta property="article:modified_time" content="2022-09-11T14:27:00.135Z">
<meta property="article:author" content="吴振扬">
<meta property="article:tag" content="算法周记">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/noritake/12.jpg"><link rel="shortcut icon" href="/img/noritake/da1.jpg"><link rel="canonical" href="http://example.com/2022/07/24/ACM%E5%91%A8%E8%AE%B0/%E6%9A%91%E6%9C%9FACM%E5%91%A8%E8%AE%B02/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?a448fa19cb6abe47b4e5f89922820c23";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><link rel="stylesheet" href="/" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":100,"languages":{"author":"作者: 吴振扬","link":"链接: ","source":"来源: Serein","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '22暑期ACM集训周记02',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-09-11 22:27:00'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/zhheo/JS-Heo@main/mainColor/heoMainColor.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/zhheo/JS-Heo@main/404/404.css"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="Serein" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">10</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">3</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-book-open"></i><span> 文档</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/random/"><i class="fa-fw fas fa-random"></i><span> 随便看看</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fas fa-compass"></i><span> 关于</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/%E5%85%B3%E4%BA%8E%E6%88%91/"><i class="fa-fw fas fa-address-card"></i><span> 本站</span></a></li><li><a class="site-page child" href="/%E5%9B%BE%E5%BA%93/%E6%91%84%E5%BD%B1/"><i class="fa-fw fas fa-images"></i><span> 影集</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Serein</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-book-open"></i><span> 文档</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/random/"><i class="fa-fw fas fa-random"></i><span> 随便看看</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fas fa-compass"></i><span> 关于</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/%E5%85%B3%E4%BA%8E%E6%88%91/"><i class="fa-fw fas fa-address-card"></i><span> 本站</span></a></li><li><a class="site-page child" href="/%E5%9B%BE%E5%BA%93/%E6%91%84%E5%BD%B1/"><i class="fa-fw fas fa-images"></i><span> 影集</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">22暑期ACM集训周记02</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-07-24T15:00:00.000Z" title="发表于 2022-07-24 23:00:00">2022-07-24</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-09-11T14:27:00.135Z" title="更新于 2022-09-11 22:27:00">2022-09-11</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%AD%A6%E4%B9%A0/">学习</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">8.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>33分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="22暑期ACM集训周记02"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="post-content" id="article-container"><h1 id="一、第二周学习总结表"><a href="#一、第二周学习总结表" class="headerlink" title="一、第二周学习总结表"></a>一、第二周学习总结表</h1><ul>
<li><h4 id="本周学习完成情况"><a href="#本周学习完成情况" class="headerlink" title="本周学习完成情况"></a>本周学习完成情况</h4><table border="1">
<tr>
<th>Contest</th>
<th>完成情况</th>
</tr>
<tr>
<td>PTA函数与递归练习</td>
<td>12/13</td>
</tr>
<tr>
<td>函数与递归练习 </td>
<td>6/10</td>
</tr>
<tr>
<td>STL(vector,stack,queue)练习</td>
<td>6/6 </td>
</tr>
<tr>
<td>STL经典练习</td>
<td>12/12</td>
</tr>
<tr>
  <td>回溯应用练习赛</td>
  <td>5/5</td>
</tr>
<tr>
  <td>其他练习</td>
  <td>5/5</td>
</tr>
<tr>
  <td>比赛补题</td>
  <td>2/2</td>
</tr>
</table>
</li>
<li><h4 id="个人感悟"><a href="#个人感悟" class="headerlink" title="个人感悟"></a>个人感悟</h4></li>
</ul>
<p>​        本周为ACM集训的第二周，回顾了函数递归，学习了新的回溯算法。这一周里，几场练习赛下来，深刻感受到了学习新算法和数据结构的重要性。比如牛客的大部分题目，题面看起来并不算难，但是数据范围总是会让传统的办法无效，这时候新的算法和数据结构的重要性就体现的很重要。比如前一天的Atcoder，前三十分钟我便写完了前三题，而后一个小时因为知识点的受限，虽然后面的题能看出来大概方向但是依旧写不出实际的代码。比如D题能直接看出来是动态规划，但是没有系统的学习和大量的练习我最终也没有推出最优子结构。再比如C题，熟悉了map以后，我仅仅花了五分多钟就写了出来。如果没有接触到STL容器，可能要做很久。再比如周日的河南大学萌新赛的J题，自学了同余定理之后，我一下就有了思路，虽然最后没有优化好还是有部分超时，没有完整的把题目通过，但是对知识点有了深刻的理解，对解题思路有了更新的感悟。</p>
<p>​        所以接下来一周，我对自己的计划是完成日常练习题的基础上，学习更多新的知识点，和做题的技巧。不但要刷日常的练习还要刷不同平台的题目，感受出题的不同方向和考察知识点的角度。</p>
<h1 id="二、本周学习新内容"><a href="#二、本周学习新内容" class="headerlink" title="二、本周学习新内容"></a>二、本周学习新内容</h1><h3 id="1-四舍五入简便写法"><a href="#1-四舍五入简便写法" class="headerlink" title="1.四舍五入简便写法"></a>1.四舍五入简便写法</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">floor</span>(x+<span class="number">0.5</span>)</span><br></pre></td></tr></table></figure>
<h3 id="2-使用assert来调试程序"><a href="#2-使用assert来调试程序" class="headerlink" title="2.使用assert来调试程序"></a>2.使用assert来调试程序</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x=<span class="number">2</span>;</span><br><span class="line"><span class="built_in">assert</span>(x&gt;=<span class="number">3</span>);</span><br><span class="line">cout&lt;&lt;x&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*报错</span></span><br><span class="line"><span class="comment">Assertion failed!</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Program: E:\Code\VSCode\Test.exe</span></span><br><span class="line"><span class="comment">File: Test.cpp, Line 15\``</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Expression: x&gt;=3</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h3 id="3-auto-register"><a href="#3-auto-register" class="headerlink" title="3.auto register"></a>3.auto register</h3><p><code>auto</code>可以自动根据后面的表达式，来给变量赋予类型。</p>
<p><code>register</code>可以将常用的变量放到寄存器中，提高运行的效率。</p>
<h3 id="4-gcd"><a href="#4-gcd" class="headerlink" title="4._gcd"></a>4._gcd</h3><p>c++<algorithm\>自带的求最大公约数的函数，底层原理是欧几里得算法。</p>
<h3 id="5-深度优先搜索-DFS"><a href="#5-深度优先搜索-DFS" class="headerlink" title="5.深度优先搜索(DFS)"></a>5.深度优先搜索(DFS)</h3><ol>
<li><h4 id="核心"><a href="#核心" class="headerlink" title="核心"></a><strong>核心</strong></h4></li>
</ol>
<p>​        沿着树的深度<code>遍历解答树的结点</code>，尽可能的深的搜索。前进中遭遇失败，则<code>回溯到前进前的结点</code>，另寻别的同路继续搜索，<code>直到满足条件</code></p>
<ol>
<li><h4 id="思想"><a href="#思想" class="headerlink" title="思想"></a><strong>思想</strong></h4></li>
</ol>
<p>​        在寻找终点的过程中将<code>当前状态</code>压入栈，若遇到死路则栈顶出栈，直到某个状态可以继续发散</p>
<ol>
<li><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4></li>
</ol>
<p>​        注意时间复杂度满不满足使用DFS，容易爆栈</p>
<ol>
<li><h4 id="核心思想代码："><a href="#核心思想代码：" class="headerlink" title="核心思想代码："></a>核心思想代码：</h4></li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(当前状态)</span></span>&#123;</span><br><span class="line">	如果到终点就返回;</span><br><span class="line">  标记当前状态已经访问过;</span><br><span class="line">  <span class="keyword">for</span> (当前状态能走的所有步)&#123;</span><br><span class="line">    新状态=当前状态转移之后的状态;</span><br><span class="line">    <span class="keyword">if</span>(新状态不符合要求)&#123;</span><br><span class="line">      <span class="keyword">continue</span>;<span class="comment">//直接跳过，寻找当前状态的下一种新状态</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(新状态没有访问过 &amp;&amp; 符合要求)&#123;</span><br><span class="line">      <span class="built_in">dfs</span>(新状态);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-998244353"><a href="#6-998244353" class="headerlink" title="6.998244353"></a>6.998244353</h3><p>一个神奇的数，常用被取模。</p>
<h3 id="7-同余定理"><a href="#7-同余定理" class="headerlink" title="7.同余定理"></a>7.同余定理</h3><ol>
<li><h4 id="同余定理即"><a href="#同余定理即" class="headerlink" title="同余定理即"></a>同余定理即</h4></li>
</ol>
<script type="math/tex; mode=display">
若(a-b)\bmod m = 0 ，则a\bmod m = b\bmod m</script><ul>
<li>证明：</li>
</ul>
<script type="math/tex; mode=display">
假设a\bmod m= b \bmod m\\
可设a=m*k+d\\
可设b=m*t+d\\
则(a-b)\bmod m= (m*(k+t)+d-d)\bmod m=0</script><p>​        其实就是余数在相减的过程中被减去了</p>
<ol>
<li><h4 id="其他性质"><a href="#其他性质" class="headerlink" title="其他性质"></a>其他性质</h4><script type="math/tex; mode=display">
(a+b) \bmod m=((a \bmod m)+(b \bmod m))\bmod m\\
(a*b) \bmod m=((a \bmod m)*(b \bmod m))\bmod m</script><p>可以在题目中对大数取余的时候可以用到</p>
</li>
</ol>
<script type="math/tex; mode=display">
a\bmod m =b \bmod m\\
则a^n \bmod m= b^n \bmod m\\
则a+c \bmod m= b+c \bmod m\\
则a*c \bmod m= b*c \bmod m</script><p>​        两个数同余，那么他们的平方也同余，他们加上同样的数也同余</p>
<script type="math/tex; mode=display">
a\mod b=0\\
c\mod d=0\\
a*b \bmod b*d =0</script><h2 id=""><a href="#" class="headerlink" title=" "></a> </h2><h3 id="8-容器的一些不熟悉的使用方法"><a href="#8-容器的一些不熟悉的使用方法" class="headerlink" title="8.容器的一些不熟悉的使用方法"></a>8.容器的一些不熟悉的使用方法</h3><ol>
<li><h4 id="priority-queue"><a href="#priority-queue" class="headerlink" title="priority_queue"></a><strong>priority_queue</strong></h4></li>
</ol>
<ul>
<li>每次push和pop都会动态调整容器内的序列</li>
<li><p>其实就是一个堆，默认为最大堆，从小到大排，所以<code>q.top()</code>为最大值,<code>q.pop()</code>就是把最大值移除</p>
</li>
<li><p>erase的返回值为删除元素后的迭代器下一个，所以删除完了有时候需要iter—</p>
</li>
<li><p>定义应该这样<code>priority_queue&lt;Type, [Container],Funtional&gt;</code></p>
<p>而如果使用了第三个参数，第二个参数也必须加上</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">priority_queue&lt;<span class="type">int</span>, greater&lt;&gt;&gt; pq;<span class="comment">//这是错误的</span></span><br><span class="line">priority_queue&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt; , greater&lt;&gt;&gt; pq;<span class="comment">//这是对的</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<ol>
<li><h4 id="set"><a href="#set" class="headerlink" title="set"></a>set</h4></li>
</ol>
<ul>
<li>访问速度是O(log~n~)</li>
<li>底层是二叉搜索树</li>
<li><code>erase(item)</code>把item元素删除</li>
<li><code>lower_bound(item)</code>：返回大于等于目标item的第一个值</li>
<li><code>lower_bound(item)</code>：返回大于目标item的第一个值</li>
</ul>
<ol>
<li><h4 id="transform"><a href="#transform" class="headerlink" title="transform"></a>transform</h4></li>
</ol>
<ul>
<li><p>transform(s.begin(),s.end(),s.begin(),::tolower);</p>
</li>
<li><p>字符串全部转换大小写</p>
</li>
</ul>
<ol>
<li><h4 id="pair"><a href="#pair" class="headerlink" title="pair"></a>pair</h4></li>
</ol>
<ul>
<li>一个二元组</li>
<li>用法<code>pair&lt;string,int&gt; p</code></li>
<li><code>p.first()</code>表示第一个元素，<code>p.second()</code>表示第二个元素</li>
</ul>
<h1 id="三、题解一览"><a href="#三、题解一览" class="headerlink" title="三、题解一览"></a>三、题解一览</h1><h2 id="1-河南理工大学萌新赛-B-宝石"><a href="#1-河南理工大学萌新赛-B-宝石" class="headerlink" title="1.河南理工大学萌新赛 - B - 宝石"></a>1.河南理工大学萌新赛 - B - 宝石</h2><p><a target="_blank" rel="noopener" href="https://ac.nowcoder.com/acm/contest/37344/B">题目链接</a></p>
<h3 id="题目标签"><a href="#题目标签" class="headerlink" title="题目标签"></a>题目标签</h3><p>打表；哈希</p>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>小Y得到了一堆宝石，但是其中有一些宝石是假的没有价值，显然小Y并不想要这些假的宝石，小Y被告诉了一个鉴别真假宝石的方法。将这些宝石排成一行，按照从 1∼n标上标号并得出其真实度，<strong>如果第 i 个宝石的真实度等于标号大于 i 的三个宝石的真实度乘积(可以使用标号相同的三个宝石)</strong>，这个宝石被认为是真的，你能帮小Y找出所有真的宝石的数量吗。</p>
<p>第一行一个整数 n (4≤n≤1500)，表示所有宝石数量。</p>
<p>第二行 n个整数 ai(−10^6^≤ai≤10^6^)，表示每个宝石的真实度。</p>
<h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><p>直接暴力毫无疑问，数据量过大会TLE。</p>
<p>那么我就想到了打表，将两个宝石的乘积乘起来，再用map存起来。遍历宝石，如果除的通，且在map里面，即宝石为真的，ans++。</p>
<p>但是新的问题又出现了：如果直接每个宝石都正序打表，从头开始数据量过大。如果储存起来，可以采用记忆化思想减少重复运算，但又不能在针对某个宝石进行遍历时，知道表中的数据是不是宝石后面的乘积。</p>
<p>由此可以尝试一下倒序打表，这样打表的好处在于倒序打表，针对每一个新遍历的宝石i，进行打表。这样一来不会重复打表，可以保证表中的数据一定时某个宝石i后面的数据的乘积</p>
<p>带着这种思想便可以大致写出程序的大概了，但是仍需注意一些问题：</p>
<ol>
<li><strong>下标问题</strong>：针对第i个宝石判断真假时，对下标为<strong>n-1</strong>的宝石到<strong>i+1</strong>的宝石进行求积，并存入map中，再用宝石i ÷ [n-1,i+1]的宝石求商，如果商被标记过，ans++</li>
<li><strong>求商</strong>：必须判断num[i]!=0，不然会报错</li>
<li><strong>特判</strong>：对a[i] == 0 &amp;&amp; a[j] == 0 的情况需要特判</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxnum 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 1000000007</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="type">int</span> num[n + <span class="number">100</span>];</span><br><span class="line">    <span class="built_in">memset</span>(num, <span class="number">0</span>, <span class="built_in">sizeof</span>(num));</span><br><span class="line">    unordered_map&lt;ll, <span class="type">bool</span>&gt; mp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; num[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//需要倒序，并且一边打表一边判断</span></span><br><span class="line">    <span class="comment">//正序打表，储存下来不能判断是不是该宝石后的，所以必须倒序</span></span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) <span class="comment">//倒序，i作为判断的宝石</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = n - <span class="number">1</span>; j &gt; i; j--) <span class="comment">//倒序更新，并且随着i的不断减小，只更新没有出现过的乘积</span></span><br><span class="line">        &#123;</span><br><span class="line">            mp[num[i + <span class="number">1</span>] * num[j]] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = n - <span class="number">1</span>; j &gt; i; j--) <span class="comment">//关于第i个宝石，针对其后面的所有宝石，进行试除，如果可除通，并且被标记过，说明成功的</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (num[i] == <span class="number">0</span> &amp;&amp; mp[<span class="number">0</span>] == <span class="number">1</span>)<span class="comment">//对于1 1 0 0 这种情况，需要特判，因为除数和被除数都为0</span></span><br><span class="line">            &#123;</span><br><span class="line">                ans++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (num[j] != <span class="number">0</span> &amp;&amp; num[i] % num[j] == <span class="number">0</span> &amp;&amp; mp[num[i] / num[j]] == <span class="number">1</span>)<span class="comment">//常规判断</span></span><br><span class="line">            &#123;</span><br><span class="line">                ans++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-计算24点，并输出"><a href="#2-计算24点，并输出" class="headerlink" title="2.计算24点，并输出"></a>2.计算24点，并输出</h2><h3 id="题目标签-1"><a href="#题目标签-1" class="headerlink" title="题目标签"></a>题目标签</h3><p>递归；搜索</p>
<h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>给出4个数，计算能否组成24点。</p>
<p>计算为+ - × ÷</p>
<p>可以加小括号</p>
<h3 id="题目解析-1"><a href="#题目解析-1" class="headerlink" title="题目解析"></a>题目解析</h3><p>递归函数的参数为</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dfs</span>(num,len,str);</span><br><span class="line"><span class="comment">//num为数组</span></span><br><span class="line"><span class="comment">//len为</span></span><br><span class="line"><span class="comment">//str为保存的输出字符串的数组</span></span><br></pre></td></tr></table></figure>
<p>对于数组num，每次任取两个不一样的数，相互操作，分别dfs</p>
<p>len为数组中的数的个数。如果len为1，说明已经完成全部操作</p>
<p>str以字符串的形式记录了对应操作的字符串</p>
<p>不过每次dfs时，需要新开一个数组</p>
<p>先记录不被选中的两个数，再把新合并的数存入数组中，再进行下一步操作</p>
<p>如果用原数组，或者全局变量，数据会被记录，不同的操作还需要回溯，不方便dfs</p>
<h3 id="通过代码"><a href="#通过代码" class="headerlink" title="通过代码"></a>通过代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> true 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> false 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> eps 1e-6</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> bool int</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> vis[<span class="number">4</span>];</span><br><span class="line"><span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line"><span class="type">bool</span> flag=<span class="literal">false</span>;</span><br><span class="line"><span class="type">bool</span> fflag;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">double</span> a[],<span class="type">int</span> len,string aa[<span class="number">4</span>])</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (len==<span class="number">1</span>)<span class="comment">//剩下一个数，说明操作完了</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">fabs</span>(<span class="number">24</span>-a[<span class="number">0</span>])&lt;eps)<span class="comment">//因为有小数，存在误差</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// printf(&quot;Yes&quot;);//不能直接输出，因为有多种情况，就会输出多次</span></span><br><span class="line">            flag=<span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (flag==<span class="literal">true</span>)<span class="comment">//如果已经找到了，就不再进行下面的计算了</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (fflag==<span class="literal">false</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;aa[<span class="number">0</span>]&lt;&lt;endl;</span><br><span class="line">            fflag=<span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len ; i++)<span class="comment">//挑选两个数操作</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; len ; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i==j)<span class="comment">//不能选相同的</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">double</span> t[<span class="number">4</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">            string tt[<span class="number">4</span>];</span><br><span class="line">            <span class="built_in">memset</span>(tt,<span class="number">0</span>,<span class="built_in">sizeof</span>(tt));</span><br><span class="line">            <span class="type">int</span> l=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; len; k++)<span class="comment">//先把除了选中的数以外的数存入新数组，不然等会不同的操作每次都要存，重复操作</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (k!=i &amp;&amp; k!=j)</span><br><span class="line">                &#123;</span><br><span class="line">                    t[l]=a[k];<span class="comment">//除了选中的数以外的数存入新数组</span></span><br><span class="line">                    tt[l]=aa[k];<span class="comment">//除了选中以外的数</span></span><br><span class="line">                    l++;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//控制括号的输出</span></span><br><span class="line">            string ykh=<span class="string">&quot;)&quot;</span>;</span><br><span class="line">            string zkh=<span class="string">&quot;(&quot;</span>;</span><br><span class="line">            <span class="comment">//如果最后一步不用加括号</span></span><br><span class="line">            <span class="keyword">if</span> (len==<span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ykh=<span class="string">&quot;&quot;</span>;</span><br><span class="line">                zkh=<span class="string">&quot;&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            t[l]=a[i]+a[j];<span class="comment">//把合并的两个数存入新数组</span></span><br><span class="line">            tt[l]=zkh+aa[i]+<span class="string">&quot;+&quot;</span>+aa[j]+ykh;<span class="comment">//表达式存入新数组</span></span><br><span class="line">            <span class="built_in">dfs</span>(t,len<span class="number">-1</span>,tt);<span class="comment">//下一步搜索</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            t[l]=a[i]-a[j];<span class="comment">//把合并的两个数存入新数组</span></span><br><span class="line">            tt[l]=zkh+aa[i]+<span class="string">&quot;-&quot;</span>+aa[j]+ykh;<span class="comment">//表达式存入新数组</span></span><br><span class="line">            <span class="built_in">dfs</span>(t,len<span class="number">-1</span>,tt);<span class="comment">//下一步搜索</span></span><br><span class="line"></span><br><span class="line">            t[l]=a[j]-a[i];<span class="comment">//把合并的两个数存入新数组</span></span><br><span class="line">            tt[l]=zkh+aa[j]+<span class="string">&quot;-&quot;</span>+aa[i]+ykh;<span class="comment">//表达式存入新数组</span></span><br><span class="line">            <span class="built_in">dfs</span>(t,len<span class="number">-1</span>,tt);<span class="comment">//下一步搜索</span></span><br><span class="line"></span><br><span class="line">            t[l]=a[i]*a[j];<span class="comment">//把合并的两个数存入新数组</span></span><br><span class="line">            tt[l]=aa[i]+<span class="string">&quot;*&quot;</span>+aa[j];<span class="comment">//表达式存入新数组</span></span><br><span class="line">            <span class="built_in">dfs</span>(t,len<span class="number">-1</span>,tt);<span class="comment">//下一步搜索</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//对除法进行搜索</span></span><br><span class="line">            <span class="keyword">if</span> (a[i]!=<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                t[l]=a[j]/a[i];</span><br><span class="line">                tt[l]=<span class="string">&quot;(&quot;</span>+aa[j]+<span class="string">&quot;/&quot;</span>+aa[i]+<span class="string">&quot;)&quot;</span>;</span><br><span class="line">                <span class="built_in">dfs</span>(t,len<span class="number">-1</span>,tt);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (a[j]!=<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                t[l]=a[i]/a[j];</span><br><span class="line">                tt[l]=<span class="string">&quot;(&quot;</span>+aa[i]+<span class="string">&quot;/&quot;</span>+aa[j]+<span class="string">&quot;)&quot;</span>;</span><br><span class="line">                <span class="built_in">dfs</span>(t,len<span class="number">-1</span>,tt);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">double</span> num[<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%lf %lf %lf %lf&quot;</span>,&amp;num[<span class="number">0</span>],&amp;num[<span class="number">1</span>],&amp;num[<span class="number">2</span>],&amp;num[<span class="number">3</span>]) &amp;&amp; num[<span class="number">0</span>]+num[<span class="number">1</span>]+num[<span class="number">2</span>]+num[<span class="number">3</span>]!=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        flag=<span class="literal">false</span>;</span><br><span class="line">        fflag=<span class="literal">false</span>;</span><br><span class="line">        string str[<span class="number">4</span>]=&#123;<span class="built_in">to_string</span>(<span class="built_in">int</span>(num[<span class="number">0</span>])),<span class="built_in">to_string</span>(<span class="built_in">int</span>(num[<span class="number">1</span>])),<span class="built_in">to_string</span>(<span class="built_in">int</span>(num[<span class="number">2</span>])),<span class="built_in">to_string</span>(<span class="built_in">int</span>(num[<span class="number">3</span>]))&#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">dfs</span>(num,<span class="number">4</span>,str);</span><br><span class="line">        <span class="keyword">if</span> (flag==<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;-1\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-PTA-汉诺塔问题"><a href="#3-PTA-汉诺塔问题" class="headerlink" title="3.PTA - 汉诺塔问题"></a>3.PTA - 汉诺塔问题</h2><h3 id="题目标签-2"><a href="#题目标签-2" class="headerlink" title="题目标签"></a>题目标签</h3><p>递归</p>
<h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>将n个盘子从<code>原始柱子a</code>借助<code>过渡柱b</code>移动到<code>目标柱c</code></p>
<h3 id="题目解析-2"><a href="#题目解析-2" class="headerlink" title="题目解析"></a>题目解析</h3><p>将n个盘子从a借助b移动到c需经过以下三步操作</p>
<ol>
<li>将n-1个盘子从a借助c移动到b</li>
<li>将第n个盘子从a移动到c</li>
<li>将n-1个盘子从b借助a移动到c</li>
</ol>
<p>而每一步操作又可以递归一次</p>
<p>递归的出口就在于</p>
<p>当只有一个盘子时可以直接将a移动到c</p>
<h3 id="通过代码-1"><a href="#通过代码-1" class="headerlink" title="通过代码"></a>通过代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MoveTower</span><span class="params">(<span class="type">int</span> num, <span class="type">char</span> src, <span class="type">char</span> dst, <span class="type">char</span> trs)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1</span> == num)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;%d: %c -&gt; %c\n&quot;</span>,num, src, dst);;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="built_in">MoveTower</span>(num - <span class="number">1</span>, src, trs, dst);</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;%d: %c -&gt; %c\n&quot;</span>,num, src, dst);</span><br><span class="line">          <span class="built_in">MoveTower</span>(num - <span class="number">1</span>, trs, dst, src);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">char</span> s, d, t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %c %c %c&quot;</span>, &amp;n, &amp;s, &amp;d, &amp;t);</span><br><span class="line">    <span class="built_in">MoveTower</span>(n, s, d, t);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-函数递归-E-正方形"><a href="#4-函数递归-E-正方形" class="headerlink" title="4.函数递归 - E - 正方形"></a>4.函数递归 - E - 正方形</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://vjudge.net/problem/UVA-201">题目链接</a></p>
</blockquote>
<h3 id="题目标签-3"><a href="#题目标签-3" class="headerlink" title="题目标签"></a>题目标签</h3><p>模拟;矩阵</p>
<h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><p>设有一个n×n的矩阵,给出点与点之间连接的关系,求出一共有多少个正方形</p>
<h3 id="题目解析-3"><a href="#题目解析-3" class="headerlink" title="题目解析"></a>题目解析</h3><p>由于数据量少,采用纯暴力法;</p>
<p>遍历每一个点,对该点遍历每一个正方形的边长,判断是否有连线,有的话则cnt[边长]++</p>
<p>那么对于每一个边长的正方形,该如何去遍历,判断有无连线呢</p>
<p>因为连线是离散的,还没有学图论还不知道怎么优化,去松弛点与点的关系</p>
<p>这里直接先用一个四维数组num[i~1~][j~1~][i~2~][j~2~]表示i~1~j~1~到i~2~j~2~之间有连线</p>
<p>那么如何判断边长为2及以上的点有连线呢</p>
<p>这里直接用一个循环判断</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">边长为k时</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> l;l&lt;=k;l++)&#123;</span><br><span class="line"></span><br><span class="line">	对点之间的判断加上一个l,表示当前从原始的点出发了几步,来判断当前点到目标点之间的点之间有没有连线</span><br><span class="line">	num[i][j+l][i][j+l+<span class="number">1</span>]==<span class="number">1</span>;</span><br><span class="line">    num[i+k][j+l][i+k][j+l+<span class="number">1</span>]==<span class="number">1</span>;</span><br><span class="line">    num[i+l][j][i+l+<span class="number">1</span>][j]==<span class="number">1</span>;</span><br><span class="line">    num[i+l][j+k][i+l+<span class="number">1</span>][j+k]==<span class="number">1</span></span><br><span class="line">    上述四个关系式来表示边长为l的长方形走步长为k时是否点与点之间连着线</span><br><span class="line">&#125;</span><br><span class="line">如下图黑线表示l的长度</span><br></pre></td></tr></table></figure>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/wzy2002/pic-bed/raw/master/img/image-20220719205736448.png" alt="image-20220719205736448"  /></p>
<p><strong>几个细节要注意:</strong></p>
<ol>
<li>k的步长部分要循环到<code>k&lt;=min(n-i,n-j)</code>这样可以减少无用的循环</li>
<li>输入部分要注意,Vertical的输入是先输入列再输入行</li>
<li>uva的输入输出很严格,换行要多注意细节,与标准输出进行对比</li>
</ol>
<h3 id="通过代码-2"><a href="#通过代码-2" class="headerlink" title="通过代码"></a>通过代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxnum 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 1000000007</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;n&gt;&gt;m)&#123;</span><br><span class="line">        <span class="keyword">if</span> (t!=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;\n**********************************\n&quot;</span>&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">        ++t;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> num[<span class="number">11</span>][<span class="number">11</span>][<span class="number">11</span>][<span class="number">11</span>];<span class="comment">//四维数组，存储</span></span><br><span class="line">        <span class="built_in">memset</span>(num,<span class="number">0</span>,<span class="built_in">sizeof</span>(num));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; m; k++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">char</span> opt;</span><br><span class="line">            <span class="type">int</span> i,j;</span><br><span class="line">            cin&gt;&gt;opt&gt;&gt;i&gt;&gt;j;</span><br><span class="line">            <span class="keyword">if</span> (opt==<span class="string">&#x27;H&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                num[i][j][i][j+<span class="number">1</span>]=<span class="number">1</span>;<span class="comment">//两双向链接</span></span><br><span class="line">                num[i][j+<span class="number">1</span>][i][j]=<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                num[j][i][j+<span class="number">1</span>][i]=<span class="number">1</span>;</span><br><span class="line">                num[j+<span class="number">1</span>][i][j][i]=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//枚举i j</span></span><br><span class="line">        <span class="type">int</span> cnt[<span class="number">10</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j&lt;= n;j++)&#123;</span><br><span class="line">                <span class="comment">//对于点i，j根据步长k枚举</span></span><br><span class="line"></span><br><span class="line">                </span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=<span class="built_in">min</span>(n-i,n-j);k++)&#123;<span class="comment">//k为步长</span></span><br><span class="line">                    <span class="type">bool</span> flag=<span class="literal">true</span>;</span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">0</span>; l &lt; k; l++)<span class="comment">//l为到i，j+k之间的点,一步一步判断</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">if</span>( num[i][j+l][i][j+l+<span class="number">1</span>]==<span class="number">1</span> &amp;&amp; </span><br><span class="line">                            num[i+k][j+l][i+k][j+l+<span class="number">1</span>]==<span class="number">1</span> &amp;&amp; </span><br><span class="line">                            num[i+l][j][i+l+<span class="number">1</span>][j]==<span class="number">1</span> &amp;&amp; </span><br><span class="line">                            num[i+l][j+k][i+l+<span class="number">1</span>][j+k]==<span class="number">1</span>)</span><br><span class="line">                        &#123;<span class="comment">//判断四个点的步长</span></span><br><span class="line">							<span class="keyword">continue</span>;<span class="comment">//步长内再走一步</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">//走完k步以后判断走不走得通</span></span><br><span class="line">                    <span class="keyword">if</span> (flag==<span class="literal">false</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;<span class="comment">//走不通,下一个步长</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (flag==<span class="literal">true</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        cnt[k]++;<span class="comment">//走的通,正方形大小为k的++</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                &#125; </span><br><span class="line">                </span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Problem #&quot;</span>&lt;&lt;t&lt;&lt;endl&lt;&lt;endl;</span><br><span class="line">        <span class="type">bool</span> f=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span> ; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(cnt[i]!=<span class="number">0</span>)&#123;</span><br><span class="line">                cout&lt;&lt;cnt[i]&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;<span class="string">&quot;square (s) of size &quot;</span>&lt;&lt;i&lt;&lt;endl;</span><br><span class="line">                f=<span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(f==<span class="literal">false</span>)&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;No completed squares can be found.&quot;</span>&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// printf(&quot;Time used = %.2lf\n&quot;, (double)clock() / CLOCKS_PER_SEC);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-火车站出栈合法性问题"><a href="#5-火车站出栈合法性问题" class="headerlink" title="5.火车站出栈合法性问题"></a>5.火车站出栈合法性问题</h2><blockquote>
<h3 id="两种方法"><a href="#两种方法" class="headerlink" title="两种方法"></a>两种方法</h3><p>1.枚举每一种出栈顺序。用dfs做</p>
<p>2.模拟出栈</p>
</blockquote>
<h2 id="6-The-Blocks-Problem"><a href="#6-The-Blocks-Problem" class="headerlink" title="6.The Blocks Problem"></a>6.The Blocks Problem</h2><h3 id="题目标签-4"><a href="#题目标签-4" class="headerlink" title="题目标签"></a>题目标签</h3><p>vector</p>
<h3 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h3><p>有n个小方块，编号从0-n-1</p>
<p>给出一序列指令操作</p>
<p>求出最终小方块的摆放方式</p>
<p>move a onto b</p>
<ul>
<li>a和b都是方块的编号，先将a和b上面所有的方块都放回原处，再将a放在b上。</li>
</ul>
<p>move a over b</p>
<ul>
<li>a和b都是方块的编号，先将a上面所有的方块放回原处，再将a放在b上。（b上原有方块不动）</li>
</ul>
<p>pile a onto b</p>
<ul>
<li>a和b都是方块的编号，将a和其上面所有的积极组成的一摞整体移动到b上。在移动前要先将b上面所有的积极都放回原处。移动的一摞方块要保持原来的顺序不变。</li>
</ul>
<p>pile a over b</p>
<ul>
<li>a和b都是方块的编号，将a和其上面所有的方块组成的一摞整体移动到b所在一摞方块的最上面一个方块上。移动的一摞方块要保持原来的顺序不变。</li>
</ul>
<p><em>quit</em></p>
<ul>
<li>结束方块的操纵。</li>
</ul>
<h3 id="题目解析-4"><a href="#题目解析-4" class="headerlink" title="题目解析"></a>题目解析</h3><p><strong>一开始的想法：</strong></p>
<p>搞十个栈，然后存入一个结构体，结构体记录了当前结点存在的栈的位置</p>
<p>一番尝试后发现过于复杂</p>
<p>容易把自己绕晕，而且push进栈里的结构体，也只能push值进去，而不是原来的，所以不能直接从读入的a，b进行查找，反而不如遍历查找来的效率高</p>
<p><strong>正确解法：</strong></p>
<p>使用一个vector数组；</p>
<p>使用resizie操作可以轻松的把上面不需要的元素清楚。比栈方便很多</p>
<p>而读入进来的结点在哪个位置只需要手写一个find函数，参数是调用了传入形参的引用，这样就可以在外部函数里操作。也不用把查找完的值放回主函数内。</p>
<p><strong>关于指令操作：</strong></p>
<p>其实只需要2种指令；一种清理上方元素归为，一种为把所有元素全部放进去</p>
<p>因为一个元素的时候，某一元素上面的所有元素就是他自己，所以不用做单独的放一个元素的操作</p>
<h3 id="通过代码-3"><a href="#通过代码-3" class="headerlink" title="通过代码"></a>通过代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxnum 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 1000000007</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">25</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v[N];</span><br><span class="line"><span class="comment">//用vector来模拟</span></span><br><span class="line"><span class="comment">//每次要先找到</span></span><br><span class="line"><span class="comment">//定理：</span></span><br><span class="line"><span class="comment">//      onto清空b上的</span></span><br><span class="line"><span class="comment">//      move清空a上的</span></span><br><span class="line"><span class="comment">//      两种情况都需要把x上的放到y上</span></span><br><span class="line"><span class="comment">//注意：</span></span><br><span class="line"><span class="comment">//      都设置为全局变量，方便操作</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; i &lt;&lt; <span class="string">&quot;:&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; v[i].<span class="built_in">size</span>(); j++)</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; v[i][j];</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">find</span><span class="params">(<span class="type">int</span> key,<span class="type">int</span> &amp;x,<span class="type">int</span> &amp;y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; v[i].<span class="built_in">size</span>(); j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(v[i][j]==key)&#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//clear：把v[ax][ay]-v[ax][max]的清空，归位</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">(<span class="type">int</span> ax,<span class="type">int</span> ay)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = ay+<span class="number">1</span>; j &lt; v[ax].<span class="built_in">size</span>(); j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> b = v[ax][j];</span><br><span class="line">        v[b].<span class="built_in">push_back</span>(b);</span><br><span class="line">    &#125;</span><br><span class="line">    v[ax].<span class="built_in">resize</span>(ay + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//把v[ax]上从ay到最大元素全部搬到v[bx]上，然后再重新resize v[ax]的大小，不需要做过多的删除操作</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">renew</span><span class="params">(<span class="type">int</span> ax,<span class="type">int</span> ay,<span class="type">int</span> bx)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = ay; i &lt; v[ax].<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        v[bx].<span class="built_in">push_back</span>(v[ax][i]);</span><br><span class="line">    &#125;</span><br><span class="line">    v[ax].<span class="built_in">resize</span>(ay);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        v[i].<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    string op;</span><br><span class="line">    <span class="keyword">while</span> (cin&gt;&gt;op &amp;&amp; op!=<span class="string">&quot;quit&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        string way;</span><br><span class="line">        <span class="type">int</span> a,b;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;way&gt;&gt;b;</span><br><span class="line">        <span class="comment">//先找到点的位置，再进行下一步操作</span></span><br><span class="line">        <span class="comment">//定义两个坐标来储存变量，让外部函数调用他们的引用</span></span><br><span class="line">        <span class="type">int</span> ax,bx,ay,by;</span><br><span class="line">        <span class="built_in">find</span>(a,ax,ay);<span class="comment">//操作，让ax，ay变成a所在的位置</span></span><br><span class="line">        <span class="built_in">find</span>(b,bx,by);<span class="comment">//操作，让bx，by变成b所在的位置</span></span><br><span class="line">        <span class="keyword">if</span> (ax==bx)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (op==<span class="string">&quot;move&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">clear</span>(ax,ay);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (way==<span class="string">&quot;onto&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">clear</span>(bx,by);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">renew</span>(ax,ay,bx);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">print</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="7-组合数问题"><a href="#7-组合数问题" class="headerlink" title="7.组合数问题"></a>7.组合数问题</h2><h3 id="题目标签-5"><a href="#题目标签-5" class="headerlink" title="题目标签"></a>题目标签</h3><p>搜索</p>
<h3 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定n个数，从中取r个数进行组合，求解法和个数</p>
<h3 id="题目解析-5"><a href="#题目解析-5" class="headerlink" title="题目解析"></a>题目解析</h3><p>n个数，取r个进行组合。也就是dfs r层，每层都要取数，数的范围是前一层取的数+1 ~ n。</p>
<p>为了保证组合没有重复的，所以每层取得数都是前一层数的+1.同时还能保证是按照升序进行输出。</p>
<h3 id="通过代码-4"><a href="#通过代码-4" class="headerlink" title="通过代码"></a>通过代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxnum 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 1000000007</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="type">int</span> n;<span class="type">int</span> r; </span><br><span class="line"><span class="type">int</span> all;</span><br><span class="line"><span class="type">int</span> a[<span class="number">22</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> begin)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (begin==r+<span class="number">1</span>)<span class="comment">//终点</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= r; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%3d&quot;</span>,a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = a[begin<span class="number">-1</span>]+<span class="number">1</span>; i &lt;= n; i++)<span class="comment">//i是必须是递增的</span></span><br><span class="line">    &#123;</span><br><span class="line">        a[begin]=i;</span><br><span class="line">        <span class="built_in">dfs</span>(begin+<span class="number">1</span>);<span class="comment">//递增后的下一步搜索</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;r;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="8-数的全排列"><a href="#8-数的全排列" class="headerlink" title="8.数的全排列"></a>8.数的全排列</h2><h3 id="题目标签-6"><a href="#题目标签-6" class="headerlink" title="题目标签"></a>题目标签</h3><p>搜索</p>
<h3 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定n个数1-n，求全排列</p>
<h3 id="题目解析-6"><a href="#题目解析-6" class="headerlink" title="题目解析"></a>题目解析</h3><p>除了next_permutation以外，还有几种使用深度优先搜素的算法来进行求解</p>
<p>首先将1-n全部存入数组，存进去之后，用dfs来进行数的交换，交换的顺序是从最后交换到第一个。</p>
<h3 id="通过代码-5"><a href="#通过代码-5" class="headerlink" title="通过代码"></a>通过代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxnum 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 1000000007</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="type">int</span> a[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> num=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//定义一个数组，让搜索时可以访问到那些元素</span></span><br><span class="line"><span class="comment">//每次让他们交换一个位置，然后该交换位置之后的继续向下搜索交换位置的</span></span><br><span class="line"><span class="comment">//每次交换位置的是begin和i交换，i++，也就是从begin开始，到begin以后的要进行交换</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Perm</span><span class="params">(<span class="type">int</span> begin, <span class="type">int</span> end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//先写出出口</span></span><br><span class="line">    <span class="keyword">if</span> (begin == end)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; end; i++)<span class="comment">//必须是&lt;=end</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%5d&quot;</span>, a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        num++;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = begin; i &lt; end; i++)<span class="comment">//必须是&lt;=end</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">swap</span>(a[i], a[begin]);</span><br><span class="line">        <span class="built_in">Perm</span>(begin + <span class="number">1</span>, end);</span><br><span class="line">        <span class="built_in">swap</span>(a[i], a[begin]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        a[i] = i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//初始化完成</span></span><br><span class="line">    <span class="built_in">Perm</span>(<span class="number">0</span>, n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="9-N皇后问题"><a href="#9-N皇后问题" class="headerlink" title="9.N皇后问题"></a>9.N皇后问题</h2><h3 id="题目标签-7"><a href="#题目标签-7" class="headerlink" title="题目标签"></a>题目标签</h3><p>深度优先搜索</p>
<h3 id="题目描述-7"><a href="#题目描述-7" class="headerlink" title="题目描述"></a>题目描述</h3><p>一个N*N的棋盘上有N个棋子，棋子的攻击范围是同一行，同一列，同一对角线（正副两个对角线），要求求出一种摆放的顺序，使得摆放八个棋子不会相互攻击到。</p>
<h3 id="题目解析-7"><a href="#题目解析-7" class="headerlink" title="题目解析"></a>题目解析</h3><p>采用dfs的方式求解。</p>
<p>因为棋子不可能会被放在同一行，所以从上往下的行数进行dfs，注意每次放置一个棋子，都需要为他的攻击范围进行标记，即该点不能被放置新的棋子。</p>
<p>即一行一行的往下搜索，每一层的搜索，都将选择1-n的位置判断是否能摆放，能摆放则进行摆放，每种摆放位置都进入棋盘的下一行进行下一步dfs搜索。</p>
<ul>
<li><h4 id="需要注意的点："><a href="#需要注意的点：" class="headerlink" title="需要注意的点："></a><strong>需要注意的点：</strong></h4></li>
</ul>
<p><strong>1. 如果采用二维数组进行标记：</strong></p>
<p>那么需要在走不通的路之后进行回溯时，需要对标记过的进行撤销。而标记和撤销标记的关键步骤在于，不要使用a[i][j]=1 或这a[i][j]=0的方式进行标记撤销，而要使用a[i][j]=++或这a[i][j]—的方式。原因在于，如果一个点被他上面的棋子标记了，同时也被另一个棋子标记了，如果另一个棋子走不通，撤销标记时，直接把该点置为0的话，那么第一个棋子标记他的效果则会被另一个棋子的撤销而失效。所以采用++ — 的方式，即一个棋子不再是被标记而是被标记x次。这样撤销的时候不会直接撤销全部效果。而是—，如果&gt;0，说明还有标记他的。只有当他变为0，也就是所有标记他的棋子都回溯了以后，才能说明这一点被真正的重新可以使用</p>
<p><strong>2. 优化后的简便方法：</strong></p>
<p>只需要用ans数组记录摆放的列即可，因为ans[i]=x.就已经说明了是i行x列的被放上了棋子。</p>
<p>由于采用二维数组做的复杂性，和回溯撤销非常麻烦。这里引入一个刘汝佳《算法竞赛入门经典》中的一个快速判断是否能放置棋子的办法。</p>
<p>同一列其实非常好判断，只需在下一个棋子的时候，枚举之前全部下过的棋子的列数(用ans数组保存的哪个)，当前列和之前下过的列是否相等，如果相等说明在同一列。</p>
<p>而同一对角线则需要一些数学性质：</p>
<ol>
<li>同一主对角线上的点，y-x的值都是相等的。如(1,1) (2,2) (3,3)都处于同一对角线上，而他们的y-x值都相等。再如(1,2) (2,3) (3,4) 也是存在于同一主对角线上。y-x的值也相等。</li>
<li>副对角线上的点则是x+y的值都相等，详见下图</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/wzy2002/pic-bed/raw/master/img/image-20220723120939376.png" alt="image-20220723120939376"></p>
<h3 id="通过代码-6"><a href="#通过代码-6" class="headerlink" title="通过代码"></a>通过代码</h3><ul>
<li><h4 id="二维数组标记版本"><a href="#二维数组标记版本" class="headerlink" title="二维数组标记版本"></a>二维数组标记版本</h4></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxnum 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 1000000007</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> tree = <span class="number">0</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[<span class="number">13</span>][<span class="number">13</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> ans[<span class="number">13</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (k == n) <span class="comment">//终点</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (num &lt; <span class="number">3</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d%s&quot;</span>, ans[i], i == n - <span class="number">1</span> ? <span class="string">&quot;\n&quot;</span> : <span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        num++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//每个深度(行)，枚举列放棋子，i为列，k为行</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[k][i] &lt; <span class="number">1</span>) <span class="comment">//没被标记可以放</span></span><br><span class="line">        &#123;</span><br><span class="line">            tree++;</span><br><span class="line">            ans[k] = i + <span class="number">1</span>;</span><br><span class="line">            a[k][i]++;</span><br><span class="line">            <span class="comment">//标记不能放置的棋子,同行同列，斜边</span></span><br><span class="line">            <span class="comment">//同行可以其实不标记，因为是一行一行下去的</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = k; j &lt; n; j++) <span class="comment">//同一列</span></span><br><span class="line">            &#123;</span><br><span class="line">                a[j][i]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = k + <span class="number">1</span>, xie = <span class="number">1</span>; j &lt; n; j++) <span class="comment">//向下的斜边</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (i + xie &lt; n)</span><br><span class="line">                    a[j][i + xie]++;</span><br><span class="line">                <span class="keyword">if</span> (i - xie &gt;= <span class="number">0</span>)</span><br><span class="line">                    a[j][i - xie]++;</span><br><span class="line">                xie++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">dfs</span>(k + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果用新数组递归下去，回溯不用删除</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = k; j &lt; n; j++) <span class="comment">//同一列</span></span><br><span class="line">            &#123;</span><br><span class="line">                a[j][i]--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = k + <span class="number">1</span>, xie = <span class="number">1</span>; j &lt; n; j++) <span class="comment">//向下的斜边</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (i + xie &lt; n)</span><br><span class="line">                    a[j][i + xie]--;</span><br><span class="line">                <span class="keyword">if</span> (i - xie &gt;= <span class="number">0</span>)</span><br><span class="line">                    a[j][i - xie]--;</span><br><span class="line">                xie++;</span><br><span class="line">            &#125;</span><br><span class="line">            a[k][i]--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line">    cout &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><h4 id="一维数组优化版本"><a href="#一维数组优化版本" class="headerlink" title="一维数组优化版本"></a>一维数组优化版本</h4></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxnum 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 1000000007</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> tree = <span class="number">0</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[<span class="number">13</span>][<span class="number">13</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> ans[<span class="number">13</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//优化方法：</span></span><br><span class="line"><span class="comment">//主要是对判断是否被标记做优化</span></span><br><span class="line"><span class="comment">//引理：处于同一主对角线上的，纵坐标值-横坐标值相等。处于同一副对角线上的，纵坐标值+横坐标值值相等。</span></span><br><span class="line"><span class="comment">//我们也不需要使用二维数组来储存，因为a[i]的i就是行号，a[i]的值就是列号。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (k == n) <span class="comment">//终点</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (num &lt; <span class="number">3</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d%s&quot;</span>, ans[i], i == n - <span class="number">1</span> ? <span class="string">&quot;\n&quot;</span> : <span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        num++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)<span class="comment">//针对每一行有n种不同的列可以摆放棋子</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">bool</span> ok = <span class="literal">true</span>;</span><br><span class="line">        ans[k] = i + <span class="number">1</span>;<span class="comment">//下标从0开始，但输出的是从1开始，i+1。不会影响引理的判断，因为所有的列号都被+1了</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; k; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (ans[k] == ans[j] || k - ans[k] == j - ans[j] || k + ans[k] == j + ans[j]) <span class="comment">//引理</span></span><br><span class="line">            &#123;</span><br><span class="line">                ok = <span class="literal">false</span>;<span class="comment">//如果位于同一列/斜边---不能进行下一步dfs</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ok == <span class="literal">true</span>)</span><br><span class="line">            <span class="built_in">dfs</span>(k + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line">    cout &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="10-信息编码"><a href="#10-信息编码" class="headerlink" title="10.信息编码"></a>10.信息编码</h2><h3 id="题目标签-8"><a href="#题目标签-8" class="headerlink" title="题目标签"></a>题目标签</h3><p>哈希</p>
<h3 id="题目描述-8"><a href="#题目描述-8" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一串字符串，为解码的信息。</p>
<p>每个字符分别对应着 0 01 10 000 001 010 011 100 101 110 0000 0001 ······。没有全部为1的解码串</p>
<p>当读取到这样的字符是，可以解码。</p>
<p>给出一串01组成的密钥，前三个代表着字符的长度，后面相应的字符串代表着字符的解码串，读到全1时表面当前长度的解码串结束，读到000时表示当前case结束</p>
<h3 id="题目解析-8"><a href="#题目解析-8" class="headerlink" title="题目解析"></a>题目解析</h3><p>用一个二维数组来表示解码的信息。code[len][value],前一个代表长度，后一个储存信息。</p>
<p>value将2进制信息转换成10进制来储存</p>
<p>注意结尾要把换行符读取掉</p>
<h3 id="通过代码-7"><a href="#通过代码-7" class="headerlink" title="通过代码"></a>通过代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxnum 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 1000000007</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">change</span><span class="params">(string s)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">length</span>();i++)&#123;</span><br><span class="line">        sum=sum*<span class="number">2</span>+(s[i]-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// code[len][value];len为长度;value为值；value有2^len - 1个</span></span><br><span class="line">    <span class="type">char</span> code[<span class="number">100</span>][<span class="number">1000</span>] = &#123;<span class="string">&quot;&quot;</span>&#125;;</span><br><span class="line">    string head;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">getline</span>(cin, head))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//编码</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; t &lt; head.<span class="built_in">length</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> len = <span class="built_in">pow</span>(<span class="number">2</span>, i) - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; len; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                code[i][j] = head[t];</span><br><span class="line">                t++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)<span class="comment">//解码</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//读取长度</span></span><br><span class="line">            string slen = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="type">char</span> c;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">               </span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>, &amp;c);</span><br><span class="line">                <span class="keyword">if</span>(c==<span class="string">&#x27;\n&#x27;</span>)&#123;</span><br><span class="line">                    <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;c);</span><br><span class="line">                &#125;</span><br><span class="line">                slen += c;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> l = <span class="built_in">change</span>(slen);</span><br><span class="line">            <span class="keyword">if</span>(l==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//读取对应码值</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                string s;</span><br><span class="line">                <span class="type">char</span> cc;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; l; i++) <span class="comment">//读取l个字符</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>, &amp;cc);</span><br><span class="line">                    <span class="keyword">if</span>(cc==<span class="string">&#x27;\n&#x27;</span>)&#123;</span><br><span class="line">                        <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;cc);</span><br><span class="line">                    &#125;</span><br><span class="line">                    s += cc;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">int</span> num = <span class="built_in">change</span>(s);</span><br><span class="line">                <span class="keyword">if</span> (num == <span class="built_in">pow</span>(<span class="number">2</span>, l) - <span class="number">1</span>)</span><br><span class="line">                &#123; <span class="comment">// 111跳出当前循环</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                cout &lt;&lt; code[l][num];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="11-产生冠军"><a href="#11-产生冠军" class="headerlink" title="11.产生冠军"></a>11.产生冠军</h2><h3 id="题目标签-9"><a href="#题目标签-9" class="headerlink" title="题目标签"></a>题目标签</h3><p>拓扑排序/Set</p>
<h3 id="题目描述-9"><a href="#题目描述-9" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一组数据，代表xx输给了xx。</p>
<p>请求判定这局有没有冠军</p>
<h3 id="题目解析-9"><a href="#题目解析-9" class="headerlink" title="题目解析"></a>题目解析</h3><p><strong>解法一：</strong></p>
<p>仅当有人一人没输过时才能产生冠军，所以只需用两个set，分别记录所有人和输的人，比较他们的size的差是否为1即可。</p>
<p><strong>解法二：</strong></p>
<p>拓扑排序解法，给所有人记录入度和出度，仅当有一人的入度为0时，即可产生冠军</p>
<h3 id="通过代码-8"><a href="#通过代码-8" class="headerlink" title="通过代码"></a>通过代码</h3><p><strong>解法二：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; n &amp;&amp; n != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        map&lt;string, <span class="type">int</span>&gt; mp;　　<span class="comment">// 分别为名字，入度</span></span><br><span class="line">        string a, b;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">            mp[b] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(mp[a] != <span class="number">1</span>)</span><br><span class="line">                mp[a] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;    <span class="comment">// 入度为0的节点个数</span></span><br><span class="line">        <span class="keyword">for</span>(map&lt;string, <span class="type">int</span>&gt;::iterator it = mp.<span class="built_in">begin</span>(); it != mp.<span class="built_in">end</span>(); ++it)</span><br><span class="line">            <span class="keyword">if</span>(it-&gt;second == <span class="number">0</span>)</span><br><span class="line">                cnt++;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(cnt == <span class="number">1</span>)</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%AE%97%E6%B3%95%E5%91%A8%E8%AE%B0/">算法周记</a></div><div class="post_share"><div class="social-share" data-image="/img/noritake/12.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/07/17/ACM%E5%91%A8%E8%AE%B0/%E6%9A%91%E6%9C%9FACM%E5%91%A8%E8%AE%B01/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/noritake/12.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">22暑期ACM集训周记01</div></div></a></div><div class="next-post pull-right"><a href="/2022/07/31/ACM%E5%91%A8%E8%AE%B0/%E6%9A%91%E6%9C%9FACM%E5%91%A8%E8%AE%B03/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/noritake/12.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">22暑期ACM集训周记03</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/07/17/ACM%E5%91%A8%E8%AE%B0/%E6%9A%91%E6%9C%9FACM%E5%91%A8%E8%AE%B01/" title="22暑期ACM集训周记01"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/noritake/12.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-07-17</div><div class="title">22暑期ACM集训周记01</div></div></a></div><div><a href="/2022/07/31/ACM%E5%91%A8%E8%AE%B0/%E6%9A%91%E6%9C%9FACM%E5%91%A8%E8%AE%B03/" title="22暑期ACM集训周记03"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/noritake/12.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-07-31</div><div class="title">22暑期ACM集训周记03</div></div></a></div><div><a href="/2022/08/07/ACM%E5%91%A8%E8%AE%B0/%E6%9A%91%E6%9C%9FACM%E5%91%A8%E8%AE%B04/" title="22暑期ACM集训周记04"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/noritake/12.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-08-07</div><div class="title">22暑期ACM集训周记04</div></div></a></div><div><a href="/2022/08/15/ACM%E5%91%A8%E8%AE%B0/%E6%9A%91%E6%9C%9FACM%E5%91%A8%E8%AE%B05/" title="22暑期ACM集训周记05"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/noritake/12.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-08-15</div><div class="title">22暑期ACM集训周记05</div></div></a></div><div><a href="/2022/08/21/ACM%E5%91%A8%E8%AE%B0/%E6%9A%91%E6%9C%9FACM%E5%91%A8%E8%AE%B06/" title="22暑期ACM集训周记06"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/noritake/12.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-08-21</div><div class="title">22暑期ACM集训周记06</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="lv-container" data-id="city" data-uid="MTAyMC81NDE4Mi8zMDY1NA=="></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">吴振扬</div><div class="author-info__description">知命不惧，日日自新</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">10</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">3</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://wzy2002.vercel.app/关于我/"><i class="fas fa-address-card"></i><span>关于本站</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/wzy1033" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:1033090568@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="https://space.bilibili.com/23248208?from=search&amp;seid=17564098687180453698&amp;spm_id_from=333.337.0.0" target="_blank" title="bilibili"><i class="fas fa-tv"></i></a><a class="social-icon" href="https://www.zhihu.com/people/wu-zhen-yang-64" target="_blank" title="Zhihu"><i class="fab fa-zhihu"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E7%AC%AC%E4%BA%8C%E5%91%A8%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E8%A1%A8"><span class="toc-text">一、第二周学习总结表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%AC%E5%91%A8%E5%AD%A6%E4%B9%A0%E5%AE%8C%E6%88%90%E6%83%85%E5%86%B5"><span class="toc-text">本周学习完成情况</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AA%E4%BA%BA%E6%84%9F%E6%82%9F"><span class="toc-text">个人感悟</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E6%9C%AC%E5%91%A8%E5%AD%A6%E4%B9%A0%E6%96%B0%E5%86%85%E5%AE%B9"><span class="toc-text">二、本周学习新内容</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%9B%9B%E8%88%8D%E4%BA%94%E5%85%A5%E7%AE%80%E4%BE%BF%E5%86%99%E6%B3%95"><span class="toc-text">1.四舍五入简便写法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%BD%BF%E7%94%A8assert%E6%9D%A5%E8%B0%83%E8%AF%95%E7%A8%8B%E5%BA%8F"><span class="toc-text">2.使用assert来调试程序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-auto-register"><span class="toc-text">3.auto register</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-gcd"><span class="toc-text">4._gcd</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2-DFS"><span class="toc-text">5.深度优先搜索(DFS)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83"><span class="toc-text">核心</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E6%83%B3"><span class="toc-text">思想</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F"><span class="toc-text">注意</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3%E4%BB%A3%E7%A0%81%EF%BC%9A"><span class="toc-text">核心思想代码：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-998244353"><span class="toc-text">6.998244353</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E5%90%8C%E4%BD%99%E5%AE%9A%E7%90%86"><span class="toc-text">7.同余定理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8C%E4%BD%99%E5%AE%9A%E7%90%86%E5%8D%B3"><span class="toc-text">同余定理即</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E6%80%A7%E8%B4%A8"><span class="toc-text">其他性质</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-text"> </span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E5%AE%B9%E5%99%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E4%B8%8D%E7%86%9F%E6%82%89%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">8.容器的一些不熟悉的使用方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#priority-queue"><span class="toc-text">priority_queue</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#set"><span class="toc-text">set</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#transform"><span class="toc-text">transform</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pair"><span class="toc-text">pair</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E9%A2%98%E8%A7%A3%E4%B8%80%E8%A7%88"><span class="toc-text">三、题解一览</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%B2%B3%E5%8D%97%E7%90%86%E5%B7%A5%E5%A4%A7%E5%AD%A6%E8%90%8C%E6%96%B0%E8%B5%9B-B-%E5%AE%9D%E7%9F%B3"><span class="toc-text">1.河南理工大学萌新赛 - B - 宝石</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%A0%87%E7%AD%BE"><span class="toc-text">题目标签</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90"><span class="toc-text">题目解析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E8%AE%A1%E7%AE%9724%E7%82%B9%EF%BC%8C%E5%B9%B6%E8%BE%93%E5%87%BA"><span class="toc-text">2.计算24点，并输出</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%A0%87%E7%AD%BE-1"><span class="toc-text">题目标签</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-1"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90-1"><span class="toc-text">题目解析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E4%BB%A3%E7%A0%81"><span class="toc-text">通过代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-PTA-%E6%B1%89%E8%AF%BA%E5%A1%94%E9%97%AE%E9%A2%98"><span class="toc-text">3.PTA - 汉诺塔问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%A0%87%E7%AD%BE-2"><span class="toc-text">题目标签</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-2"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90-2"><span class="toc-text">题目解析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E4%BB%A3%E7%A0%81-1"><span class="toc-text">通过代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%87%BD%E6%95%B0%E9%80%92%E5%BD%92-E-%E6%AD%A3%E6%96%B9%E5%BD%A2"><span class="toc-text">4.函数递归 - E - 正方形</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%A0%87%E7%AD%BE-3"><span class="toc-text">题目标签</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-3"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90-3"><span class="toc-text">题目解析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E4%BB%A3%E7%A0%81-2"><span class="toc-text">通过代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E7%81%AB%E8%BD%A6%E7%AB%99%E5%87%BA%E6%A0%88%E5%90%88%E6%B3%95%E6%80%A7%E9%97%AE%E9%A2%98"><span class="toc-text">5.火车站出栈合法性问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95"><span class="toc-text">两种方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-The-Blocks-Problem"><span class="toc-text">6.The Blocks Problem</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%A0%87%E7%AD%BE-4"><span class="toc-text">题目标签</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-4"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90-4"><span class="toc-text">题目解析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E4%BB%A3%E7%A0%81-3"><span class="toc-text">通过代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E7%BB%84%E5%90%88%E6%95%B0%E9%97%AE%E9%A2%98"><span class="toc-text">7.组合数问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%A0%87%E7%AD%BE-5"><span class="toc-text">题目标签</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-5"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90-5"><span class="toc-text">题目解析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E4%BB%A3%E7%A0%81-4"><span class="toc-text">通过代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E6%95%B0%E7%9A%84%E5%85%A8%E6%8E%92%E5%88%97"><span class="toc-text">8.数的全排列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%A0%87%E7%AD%BE-6"><span class="toc-text">题目标签</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-6"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90-6"><span class="toc-text">题目解析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E4%BB%A3%E7%A0%81-5"><span class="toc-text">通过代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-N%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98"><span class="toc-text">9.N皇后问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%A0%87%E7%AD%BE-7"><span class="toc-text">题目标签</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-7"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90-7"><span class="toc-text">题目解析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E7%82%B9%EF%BC%9A"><span class="toc-text">需要注意的点：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E4%BB%A3%E7%A0%81-6"><span class="toc-text">通过代码</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E6%A0%87%E8%AE%B0%E7%89%88%E6%9C%AC"><span class="toc-text">二维数组标记版本</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E4%BC%98%E5%8C%96%E7%89%88%E6%9C%AC"><span class="toc-text">一维数组优化版本</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-%E4%BF%A1%E6%81%AF%E7%BC%96%E7%A0%81"><span class="toc-text">10.信息编码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%A0%87%E7%AD%BE-8"><span class="toc-text">题目标签</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-8"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90-8"><span class="toc-text">题目解析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E4%BB%A3%E7%A0%81-7"><span class="toc-text">通过代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-%E4%BA%A7%E7%94%9F%E5%86%A0%E5%86%9B"><span class="toc-text">11.产生冠军</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%A0%87%E7%AD%BE-9"><span class="toc-text">题目标签</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-9"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90-9"><span class="toc-text">题目解析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E4%BB%A3%E7%A0%81-8"><span class="toc-text">通过代码</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/08/21/ACM%E5%91%A8%E8%AE%B0/%E6%9A%91%E6%9C%9FACM%E5%91%A8%E8%AE%B06/" title="22暑期ACM集训周记06"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/noritake/12.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="22暑期ACM集训周记06"/></a><div class="content"><a class="title" href="/2022/08/21/ACM%E5%91%A8%E8%AE%B0/%E6%9A%91%E6%9C%9FACM%E5%91%A8%E8%AE%B06/" title="22暑期ACM集训周记06">22暑期ACM集训周记06</a><time datetime="2022-08-21T15:00:00.000Z" title="发表于 2022-08-21 23:00:00">2022-08-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/08/15/ACM%E5%91%A8%E8%AE%B0/%E6%9A%91%E6%9C%9FACM%E5%91%A8%E8%AE%B05/" title="22暑期ACM集训周记05"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/noritake/12.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="22暑期ACM集训周记05"/></a><div class="content"><a class="title" href="/2022/08/15/ACM%E5%91%A8%E8%AE%B0/%E6%9A%91%E6%9C%9FACM%E5%91%A8%E8%AE%B05/" title="22暑期ACM集训周记05">22暑期ACM集训周记05</a><time datetime="2022-08-15T15:00:00.000Z" title="发表于 2022-08-15 23:00:00">2022-08-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/08/07/ACM%E5%91%A8%E8%AE%B0/%E6%9A%91%E6%9C%9FACM%E5%91%A8%E8%AE%B04/" title="22暑期ACM集训周记04"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/noritake/12.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="22暑期ACM集训周记04"/></a><div class="content"><a class="title" href="/2022/08/07/ACM%E5%91%A8%E8%AE%B0/%E6%9A%91%E6%9C%9FACM%E5%91%A8%E8%AE%B04/" title="22暑期ACM集训周记04">22暑期ACM集训周记04</a><time datetime="2022-08-07T15:00:00.000Z" title="发表于 2022-08-07 23:00:00">2022-08-07</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2022 By 吴振扬</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hi, welcome to my <a target="_blank" rel="noopener" href="https://wzy1033.github.io/">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.2
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container:not\([display]\)').forEach(node => {
            const target = node.parentNode
            if (target.nodeName.toLowerCase() === 'li') {
              target.parentNode.classList.add('has-jax')
            } else {
              target.classList.add('has-jax')
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script><script>function loadLivere () {
  if (typeof LivereTower === 'object') {
    window.LivereTower.init()
  }
  else {
    (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
    })(document, 'script');
  }
}

if ('Livere' === 'Livere' || !false) {
  if (false) btf.loadComment(document.getElementById('lv-container'), loadLivere)
  else loadLivere()
}
else {
  function loadOtherComment () {
    loadLivere()
  }
}</script></div><script async src="//at.alicdn.com/t/font_2804883_dzrzjhfbfv.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="true" data-click="false"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["meta[property=\"og:image\"]","meta[property=\"og:title\"]","meta[property=\"og:url\"]","head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  typeof preloader === 'object' && preloader.initLoading()
  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --><script async src="//at.alicdn.com/t/font_2032782_8d5kxvn09md.js"></script><!-- hexo injector body_end end --></body></html>