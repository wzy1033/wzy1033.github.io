<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>22暑期ACM集训周记06</title>
      <link href="/2022/08/21/ACM%E5%91%A8%E8%AE%B0/%E6%9A%91%E6%9C%9FACM%E5%91%A8%E8%AE%B06/"/>
      <url>/2022/08/21/ACM%E5%91%A8%E8%AE%B0/%E6%9A%91%E6%9C%9FACM%E5%91%A8%E8%AE%B06/</url>
      
        <content type="html"><![CDATA[<h1 id="一、第六周学习总结表"><a href="#一、第六周学习总结表" class="headerlink" title="一、第六周学习总结表"></a>一、第六周学习总结表</h1><ul><li><h3 id="本周学习完成情况"><a href="#本周学习完成情况" class="headerlink" title="本周学习完成情况"></a>本周学习完成情况</h3><table border="1"><tr><th>Contest</th><th>完成情况</th></tr><tr><td>博弈论入门练习</td><td>8/12</td></tr><tr><td>并查集练习</td><td>11/19</td></tr><tr><td>字符串</td><td>10/11</td></tr><tr><td>线段树1</td><td>7/15</td></tr><tr>  <td>图论(拓扑排序)</td>  <td>11/18</td></tr><tr>  <td>Atcoder比赛+补题</td>  <td>4/8</td></tr><tr>  <td>郑州大学比赛+补题</td>  <td>6/12</td></tr><tr>  <td>小白月赛比赛+补题</td>  <td>4/6</td></tr><tr>  <td>ccpc华为</td>  <td>2/12</td></tr><tr>  <td><b>总计</b></td>  <td><b>50/90</b></td></td></tr></table></li><li><h3 id="个人感悟"><a href="#个人感悟" class="headerlink" title="个人感悟"></a>个人感悟</h3><p>​        本周是最后一周，经过了40天的历练，感觉自己对算法有了一个全新的认识。对算法和数据结构整体的认知更加的清晰了。未来学习路线也逐渐有了方向。最直观的感受就是解题能力的提升，虽然像atcoder和codeforces上的思维题做题情况和暑假前也差不多，但是做题速度和读题速度有了非常大的进步。而新学习的知识也慢慢的能在各种比赛中用到了，比如上周日的牛客中的博弈论数论题的基础题都解了出来，非常有成就感。<br>​<br>暑期结束到开学的日子里，我将对整个暑假学习的进行一些巩固，把所有刷过的题目看一遍，没有做出的题目再尝试一遍。随后把图论的没有来的及讲完的东西自学完成。把刘汝佳白书所学过的东西都看一遍，以及算法进阶上的题目能做的对照题单尽量全部完成</p></li></ul><h1 id="二、本周学习新内容"><a href="#二、本周学习新内容" class="headerlink" title="二、本周学习新内容"></a>二、本周学习新内容</h1><h3 id="1-LONG-LONG-MAX"><a href="#1-LONG-LONG-MAX" class="headerlink" title="1.LONG_LONG_MAX"></a>1.LONG_LONG_MAX</h3><p><limits.h>中包含的，即long long 的最大值</p><p>9223372036854775807</p><h3 id="2-字符串哈希"><a href="#2-字符串哈希" class="headerlink" title="2.字符串哈希"></a>2.字符串哈希</h3><p>$f(s)=\Sigma_{i=1}^l s[i]\times p^{l-i} (\bmod M )$</p><p>原理：将字符串类比成一个p进制的数</p><ul><li><p>且p通常取<code>131</code> or <code>1331</code>，在$2^{64}$范围内映射</p></li><li><p>为了防止指数爆炸的情况，定义成<code>unsigned long long</code>的形式，超出会自动取模</p></li></ul><p>计算字符串的哈希值，即计算前缀和复杂度为$O(n)$</p><p>计算字符串后再次获取子串的哈希值，即计算区间和复杂度为$O(1)$</p><p>$ f[L, R]=(f[R]−f[L−1]×P ^{R−L+1} )$</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> P=<span class="number">131</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1001</span>;</span><br><span class="line">ull h[N], p[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">gethash</span><span class="params">(string s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= s.<span class="built_in">length</span>(); i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        h[i] = h[i - <span class="number">1</span>] * P + s[i];</span><br><span class="line">        p[i] = p[i - <span class="number">1</span>] * P;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ull <span class="title">get</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> h[r] - h[l - <span class="number">1</span>] * p[r - l + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    p[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-线段树"><a href="#3-线段树" class="headerlink" title="3.线段树"></a>3.线段树</h3><p>$O(log_n)$修改区间值，查询区间值</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Luogu P3372 【模板】线段树 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lc p &lt;&lt; 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rc p &lt;&lt; 1 | 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 100005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mid(x, y) x + y &gt;&gt; 1</span></span><br><span class="line">ll n;</span><br><span class="line">ll num[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    ll l, r, sum, add;</span><br><span class="line">&#125; tr[N * <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//向上更新结点维护的值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(ll p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[p].sum = tr[lc].sum + tr[rc].sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(ll p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> &amp;pp = tr[p], &amp;pl = tr[lc], &amp;pr = tr[rc];</span><br><span class="line">    <span class="keyword">if</span> (pp.add)</span><br><span class="line">    &#123; <span class="comment">//懒惰标记</span></span><br><span class="line">        pl.sum += pp.add * (pl.r - pl.l + <span class="number">1</span>);</span><br><span class="line">        pr.sum += pp.add * (pr.r - pr.l + <span class="number">1</span>);</span><br><span class="line">        pl.add += pp.add; <span class="comment">//+=因为可能有多个懒惰值</span></span><br><span class="line">        pr.add += pp.add;</span><br><span class="line">        pp.add = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//建树,l,r代表的是线段的开始和结束</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(ll p, ll l, ll r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[p] = &#123;l, r, num[l], <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span> (l == r)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    ll m = <span class="built_in">mid</span>(l, r);</span><br><span class="line">    <span class="built_in">build</span>(lc, l, m);</span><br><span class="line">    <span class="built_in">build</span>(rc, m + <span class="number">1</span>, r);</span><br><span class="line">    <span class="built_in">pushup</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//区间修改</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(ll p, ll x, ll y, ll k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= tr[p].l &amp;&amp; tr[p].r &lt;= y)</span><br><span class="line">    &#123;</span><br><span class="line">        tr[p].sum += (tr[p].r - tr[p].l + <span class="number">1</span>) * k;</span><br><span class="line">        tr[p].add += k;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ll m = <span class="built_in">mid</span>(tr[p].l, tr[p].r); <span class="comment">//寻找改向哪个方向递归查询目标点</span></span><br><span class="line">    <span class="built_in">pushdown</span>(p);</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= m)</span><br><span class="line">        <span class="built_in">update</span>(lc, x, y, k);</span><br><span class="line">    <span class="keyword">if</span> (y &gt; m)</span><br><span class="line">        <span class="built_in">update</span>(rc, x, y, k);</span><br><span class="line">    <span class="built_in">pushup</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//区间查询(x=y就是单点查询)</span></span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(ll p, ll x, ll y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= tr[p].l &amp;&amp; tr[p].r &lt;= y)</span><br><span class="line">        <span class="keyword">return</span> tr[p].sum;</span><br><span class="line">    ll m = <span class="built_in">mid</span>(tr[p].l, tr[p].r);</span><br><span class="line">    <span class="built_in">pushdown</span>(p);</span><br><span class="line">    ll sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= m)</span><br><span class="line">        sum += <span class="built_in">query</span>(lc, x, y);</span><br><span class="line">    <span class="keyword">if</span> (y &gt; m)</span><br><span class="line">        sum += <span class="built_in">query</span>(rc, x, y);</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n, m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;num[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-博弈论"><a href="#4-博弈论" class="headerlink" title="4.博弈论"></a>4.博弈论</h3><h4 id="01Bash博弈"><a href="#01Bash博弈" class="headerlink" title="01Bash博弈"></a>01Bash博弈</h4><p><a href="https://blog.csdn.net/hesorchen/article/details/104131660">(91条消息) HDU-2147 kiki‘s game 巴什博弈_hesorchen的博客-CSDN博客</a></p><blockquote><p>只有一堆n个物品，两个人轮流从这堆物品中取物，规定每次至少取1个，最多取m个，最后取光者得胜</p></blockquote><ul><li><strong>分析：</strong></li></ul><p>​        首先可以最简单的分析：</p><p>​            如果只有$m+1$个物品，那么先手最多取走m个物品，无论怎么取，后手都能取完。</p><p>​        那么推广到多个物品，只要 $n = (m+1)*k + p$，即 $n\bmod (m+1) != 0$</p><p>​            只要我们先手，取出p个物品，让剩下的物品数量变成$(m+1)$的倍数</p><p>​            那么只要对手任意取x个物品，先手只要再取$(m+1)-x$个物品，保证每次留给对手的局面都是$(m+1)$的倍数，那么我们就必赢</p><ul><li><p><strong>结论：</strong></p><p>当$n\bmod(m+1)==0$时先手必败</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">if</span>(n%(m+<span class="number">1</span>)==<span class="number">0</span>)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;second&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;first&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="02Wythoff博弈"><a href="#02Wythoff博弈" class="headerlink" title="02Wythoff博弈"></a>02Wythoff博弈</h4><blockquote><p>有两堆各若干物品，两个人轮流从任意一堆中至少取出一个或者从两堆中取出同样多的物品，规定每次至少取一个，至多不限，最后取光者胜。</p></blockquote><p>这里的必输局势：（0，0）、（1，2）、（3，5）、（4，7）、（6，10）、（8，13）、（9，15）、（11，18）、（12，20）。从这些必输局势可以发现，每组的第一个是前面没有出现的最小正整数，ak=[k∗(1+5–√)/2], bk=ak+k, k=0,1,2,3…。</p><p>所以，先求出差值，差值*黄金分割比 == 最小值的话后手赢，否者先手赢。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> r = (<span class="built_in">sqrt</span>(<span class="number">5</span>) + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> d = <span class="built_in">abs</span>(a - b) * r;</span><br><span class="line"><span class="keyword">if</span> (d != <span class="built_in">min</span>(a, b))  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span>  <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><p>注：如果a,b的值非常大的话，需要高精度来计算这个double类型的r</p><h4 id="03Nim博弈"><a href="#03Nim博弈" class="headerlink" title="03Nim博弈"></a>03Nim博弈</h4><ul><li>[ ] 异或的原理?</li></ul><p><a href="https://blog.csdn.net/A_Comme_Amour/article/details/79347291">(91条消息) [学习笔记] （博弈论）Nim游戏和SG函数_A_Comme_Amour的博客-CSDN博客_nim博弈</a></p><blockquote><p>Nim博弈：</p><p>即n堆个物品，每次可以里面取任意个,取到最后一个物品的人取胜。</p></blockquote><p><strong>Nim博弈必胜局势的证明</strong></p><ul><li><strong>条件：</strong>有$n$堆牌$x_i$，每次任意堆取牌任意数量。即</li></ul><p>$x_1\ x_2\  x_3 \ x_4 ···x_n $</p><ul><li><strong>已知：</strong></li></ul><p>$若当前x_1 \wedge x_2 \wedge  x_3 \wedge x_4 \wedge ···x_n =0，则先手者操作必输，即为必败局势$</p><ul><li><strong>要证明：</strong></li></ul><p>$x_1 \wedge x_2 \wedge  x_3 \wedge x_4 \wedge ···x_n\  !=0时，必能进行某种操作，使得对手成为必败局势$</p><ul><li><strong>即:</strong></li></ul><script type="math/tex; mode=display">当你有x_1 \wedge x_2 \wedge  x_3 \wedge x_4 \wedge ···x_n\  !=0 \ \ \ \\你必有某种取牌法让你的对手有\\x_1 \wedge x_2 \wedge  x_3 \wedge x_4 \wedge ···x_n =0</script><ul><li><strong>证：</strong></li></ul><p>​        设<code>所有数的异或</code>为$x_0$，若$x_0\ !=0$，则说明其二进制上必有一位为1    </p><p>​        则必然存在$x_i$,使得$x_i \wedge x_0 &lt; x_i$,既然这个数比$x_{i}$小</p><p>​            那么就存在$x_i - x_i \wedge x_0&lt;x_i$</p><p>​            所$x_i - (x_i - x_i \wedge x_0)=x_i \wedge x_0$</p><p>​            也就是说可以对$x_i$进行一个操作,即对第i堆牌$x_i$拿出$(x_i - x_i \wedge x_0)$张牌，让他$xi$张牌变成$x_i \wedge x_0$张牌</p><p>​            进行这一步操作之后，你的对手拿到的牌一定是</p><p>​                $x_1 \wedge x_2 \wedge  x_3 \wedge x_4 \wedge ···x_n\ \wedge x_0  $</p><p>​            $=x_0 \wedge x_0=0$,</p><p>​                即所有数异或为0，即为<code>必败局势</code></p><p>​        所以必然存在一种操作，使得对手成为<code>必败局势</code></p><ul><li><strong>总结：</strong></li></ul><p>​        也就是说，要让对手成为<code>必败局势</code>,那么对$x_i$，取出$(x_i - x_i \wedge x_0)$，让牌数$x_i$变为$(x_i - x_i \wedge x_0)$即可</p><p>​        而这样的$x_i$的数量取决于$x_i \wedge x_0 &lt; x_i$的数量</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= n; k++)</span><br><span class="line">&#123;</span><br><span class="line">    ans ^= num[k];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="04ICG游戏"><a href="#04ICG游戏" class="headerlink" title="04ICG游戏"></a>04ICG游戏</h4><p>Nim游戏是经典的公平组合游戏(ICG)，对于ICG游戏我们有如下定义：</p><ul><li>两名选手</li><li>两名选手轮流行动，每一次行动可以在有限合法操作集合中选择一个</li><li>游戏的任何一种可能的局面(position)，合法操作集合只取决于这个局面本身，不取决于轮到哪名选手操作、以前的任何操作、骰子的点数或者其它因素；局面的改变称为“移动”(move)</li><li>如果轮到某名选手移动，且这个局面的合法的移动集合为空（也就是说此时无法进行移动），则这名选手负</li></ul><p>将ICG问题进行转化：任何一个ICG都可以通过把每个局面看作一个顶点，对每个局面和它的子局面连一条有向边来抽象这个“有向图游戏”</p><p><img src="https://gitee.com/wzy2002/pic-bed/raw/master/img/image-20220816084901461.png" alt="image-20220816084901461" style="zoom:30%;" /></p><h4 id="05PN分析"><a href="#05PN分析" class="headerlink" title="05PN分析"></a>05PN分析</h4><ul><li><strong>P-position：即必败点</strong></li></ul><ol><li>所有终结位置，不能再走的位置，为必败点(P点)</li><li>某点开始的所有操作，都将进入<code>必胜点(N点)</code>的位置，为必败点</li></ol><ul><li><strong>N-position：即必胜点</strong></li></ul><ol><li>某点开始的所有操作，存在某一步能进入<code>必败点(P点)</code>的位置，为必胜点</li></ol><ul><li>分析步骤</li></ul><ol><li>将所有终结位置标记为必败点(P点);</li><li>将所有一步能进入必败点(P点)的位置标记为必胜点(N点);</li><li>如果从某个点开始的所有一步操作都只能进入必胜点(N点)，则将该位置标记为必败点(P点);</li><li>如果在步骤3中未能找到新的必败点(P点)，算法终止，否则返回步骤2.</li></ol><h4 id="06SG函数"><a href="#06SG函数" class="headerlink" title="06SG函数"></a>06SG函数</h4><ul><li>[ ] SG异或的原理？</li></ul><p><strong>SG函数</strong>为<strong>计算博弈状态</strong>的函数，当SG[X] = 0时，说明先手必败</p><ul><li>mex运算(minimal excludant)</li></ul><p>$mex(S)=min\left\{不在集合中的自然数\right\}$</p><script type="math/tex; mode=display">sg(x)=mex\left\{ 每个sg(y)\ \ |\ \  y是x的后继\right\}</script><ul><li>SG函数的求法：</li></ul><ol><li>找出必败态</li><li>找出当前所有状态的前驱结点</li><li>根据定义计算结点SG值</li><li>重复上述步骤，直到整棵树建立完成</li></ol><ul><li>例题：<a href="https://www.acwing.com/problem/content/895/">集合Nim</a></li></ul><p><a href="https://www.cnblogs.com/tian-zai/p/16543249.html">集合-Nim游戏 - 天仔 - 博客园 (cnblogs.com)</a></p><ul><li>代码模板</li></ul><p>DFS序遍历DAG图</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> sg[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; a[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">// dfs序遍历DAG图求SG函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getSg</span><span class="params">(<span class="type">int</span> cur)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//如果有值，直接返回（记忆化搜索）</span></span><br><span class="line">    <span class="keyword">if</span> (sg[cur] != <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> sg[cur];</span><br><span class="line">    <span class="comment">//如果没有，那就找</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//用于标记</span></span><br><span class="line">    <span class="type">bool</span> vis[N] = &#123;<span class="literal">false</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//遍历当前结点的后继结点，dfs序求出他们的sg函数,并标记</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a[cur].<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> next = a[cur][i];</span><br><span class="line">        <span class="type">int</span> pos = <span class="built_in">getSg</span>(next);</span><br><span class="line">        <span class="comment">//为true的pos就是当前cur结点的后继的sg值</span></span><br><span class="line">        vis[pos] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// mex函数，找出最小的不在集合内的自然数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (vis[i] == <span class="literal">false</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            sg[cur] = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sg[cur];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非DFS,一次性打表</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> f[<span class="number">15</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">13</span>, <span class="number">21</span>, <span class="number">34</span>, <span class="number">55</span>, <span class="number">89</span>, <span class="number">144</span>, <span class="number">233</span>, <span class="number">377</span>, <span class="number">610</span>, <span class="number">987</span>&#125;;</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line"><span class="type">int</span> sg[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getSg</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(sg, <span class="number">0</span>, <span class="built_in">sizeof</span>(sg));</span><br><span class="line">    <span class="comment">// sg[0]=0,所以循环从1开始</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in">sizeof</span>(vis));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= n &amp;&amp; f[j] &lt;= i; j++)</span><br><span class="line">            vis[sg[i - f[j]]] = <span class="literal">true</span>; <span class="comment">//当前节点可以转到的下一状态标记</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= n; j++)</span><br><span class="line">        &#123; <span class="comment">//查询当前后继状态SG值中最小的非零值</span></span><br><span class="line">            <span class="keyword">if</span> (vis[j] == <span class="literal">false</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                sg[i] = j;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="三、题解一览"><a href="#三、题解一览" class="headerlink" title="三、题解一览"></a>三、题解一览</h1><h2 id="1-博弈论练习-H-A-Chess-Game"><a href="#1-博弈论练习-H-A-Chess-Game" class="headerlink" title="1.博弈论练习 - H - A Chess Game"></a>1.博弈论练习 - H - A Chess Game</h2><h3 id="题目标签"><a href="#题目标签" class="headerlink" title="题目标签"></a>题目标签</h3><p>博弈论；SG函数</p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个DAG图，以及一些棋子，判断是否能获胜</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><p>经典的SG函数的应用。</p><p>用dfs序遍历一个DAG图求解SG函数</p><ol><li>先判断值是否存在（记忆化搜索）</li><li>当前结点能走的所有结点并dfs，打上标记</li><li>mex函数找出最小不存在集合内的自然数</li></ol><h3 id="通过代码"><a href="#通过代码" class="headerlink" title="通过代码"></a>通过代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(false), cin.tie(0), cout.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 1100</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> sg[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; a[N];</span><br><span class="line"><span class="comment">// dfs序遍历DAG图求SG函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getSg</span><span class="params">(<span class="type">int</span> cur)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//如果有值，直接返回（记忆化搜索）</span></span><br><span class="line">    <span class="keyword">if</span> (sg[cur] != <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> sg[cur];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果没有，那就找</span></span><br><span class="line">    <span class="comment">//用于标记</span></span><br><span class="line">    <span class="type">bool</span> vis[N] = &#123;<span class="literal">false</span>&#125;;</span><br><span class="line">    <span class="comment">//遍历当前结点的后继结点，dfs序求出他们的sg函数,并标记</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a[cur].<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> next = a[cur][i];</span><br><span class="line">        <span class="type">int</span> pos = <span class="built_in">getSg</span>(next);</span><br><span class="line">        <span class="comment">//为true的pos就是当前cur结点的后继的sg值</span></span><br><span class="line">        vis[pos] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// mex函数，找出最小的不在集合内的自然数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (vis[i] == <span class="literal">false</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            sg[cur] = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sg[cur];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">bool</span> v[N];</span><br><span class="line">        <span class="built_in">memset</span>(sg, <span class="number">-1</span>, <span class="built_in">sizeof</span>(sg));</span><br><span class="line">        <span class="built_in">memset</span>(v, <span class="number">0</span>, <span class="built_in">sizeof</span>(v));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> t;</span><br><span class="line">            cin &gt;&gt; t;</span><br><span class="line">            a[i].<span class="built_in">clear</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; t; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> temp;</span><br><span class="line">                cin &gt;&gt; temp;</span><br><span class="line">                a[i].<span class="built_in">push_back</span>(temp);</span><br><span class="line">                v[i] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> q;</span><br><span class="line">        <span class="keyword">while</span> (cin &gt;&gt; q &amp;&amp; q != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (q--)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> temp;</span><br><span class="line">                cin &gt;&gt; temp;</span><br><span class="line">                ans ^= <span class="built_in">getSg</span>(temp);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ans == <span class="number">0</span>)</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;LOSE&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;WIN&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-POJ2182-Lost-Cows"><a href="#2-POJ2182-Lost-Cows" class="headerlink" title="2.POJ2182 - Lost Cows"></a>2.POJ2182 - Lost Cows</h2><h3 id="题目标签-1"><a href="#题目标签-1" class="headerlink" title="题目标签"></a>题目标签</h3><p>线段树</p><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>一共有n个数为1-n，随机进行排列</p><p>现在你不知道每个数的大小是多少</p><p>你只知道每个数的前面一共有多少个数比他小，给出2到n（第一个数默认为0）</p><p>现在请你还原出这个数的序列</p><p><img src="https://gitee.com/wzy2002/pic-bed/raw/master/img/image-20220818140844150.png" alt="image-20220818140844150" style="zoom:50%;" align="left"/></p><h3 id="题目解析-1"><a href="#题目解析-1" class="headerlink" title="题目解析"></a>题目解析</h3><p>从后往前遍历，num数组</p><p>推导出，$ans[i]=(1-n)中除去ans[i,n]出现过的数后，第num[i]+1大的数$</p><p><img src="https://gitee.com/wzy2002/pic-bed/raw/master/img/image-20220818141952432.png" alt="image-20220818141952432"></p><p>这里的除去，只是用数组模拟时的说法，实际上，每个数前面的数(可以和他比较的数) 就是不包含 已经计算的数(即后面的数)</p><p>而如果用数组来模拟这一过程，会出现TLE的现象</p><p>所以这题可以用线段树来做</p><p>而线段树的做法不再是维护一个数组，有没有被选中过。而是每一个结点都记录当前区间内还剩下多少个数<code>len</code>(可以被比较的数)</p><p>初始化时，将每个区间的len都记录为r-l+1,比如[1,5]就是5</p><p>每次查询的时候，需要动态的去修改区间的长度，与修改sum类似，每个被访问的（区间包含的）都需要进行修改</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(ll cur, ll k)</span><span class="comment">//表示寻找cur区间内第k小的值</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">pushup</span>(cur);</span><br><span class="line">    <span class="keyword">if</span> (tr[cur].l == tr[cur].r)</span><br><span class="line">        <span class="keyword">return</span> tr[cur].r;</span><br><span class="line">    ll sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (k &lt;= tr[lc].len)</span><br><span class="line">        sum += <span class="built_in">query</span>(lc, k);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        sum += <span class="built_in">query</span>(rc, k - tr[lc].len);</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查询时，用k来查询，与左边的len进行比较。</p><p>如果小于len，就继续向左遍历，即找第len小的数</p><p>如果大于len，就向右遍历，并<code>query(rc,k-tr[lc].len)</code>，意味寻找右边区间内第<code>k-tr[lc].len</code>小的数</p><p>比如</p><ul><li>左区间剩下两个数</li><li>右区间剩下三个数<ul><li>此时如果查找第3小的数，就是递归查找右区间第1小的数<ul><li>因为线段是从小到大排的，所以右区间第1小的数就是，1+2（左区间的数）=3小的数</li></ul></li><li>此时如果查找第2小的数，就是递归查找左区间第2小的数</li></ul></li></ul><h3 id="通过代码-1"><a href="#通过代码-1" class="headerlink" title="通过代码"></a>通过代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Luogu P3372 【模板】线段树 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lc cur &lt;&lt; 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rc cur &lt;&lt; 1 | 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 9000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mid(x, y) x + y &gt;&gt; 1</span></span><br><span class="line">ll n;</span><br><span class="line">ll num[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    ll l, r, len;</span><br><span class="line">&#125; tr[N * <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//向上更新结点维护的值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(ll cur)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[cur].len--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//建树,l,r代表的是线段的开始和结束</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(ll cur, ll l, ll r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[cur].l=l;tr[cur].r=r;tr[cur].len=r-l+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (l == r)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    ll m = <span class="built_in">mid</span>(l, r);</span><br><span class="line">    <span class="built_in">build</span>(lc, l, m);</span><br><span class="line">    <span class="built_in">build</span>(rc, m + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(ll cur, ll k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">pushup</span>(cur);</span><br><span class="line">    <span class="keyword">if</span> (tr[cur].l == tr[cur].r)</span><br><span class="line">        <span class="keyword">return</span> tr[cur].r;</span><br><span class="line">    ll sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (k &lt;= tr[lc].len)</span><br><span class="line">        sum += <span class="built_in">query</span>(lc, k);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        sum += <span class="built_in">query</span>(rc, k - tr[lc].len);</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n;</span><br><span class="line">    ll ans[N] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;num[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        ans[i] = <span class="built_in">query</span>(<span class="number">1</span>, num[i] + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-拓扑排序-B-Following-Orders"><a href="#3-拓扑排序-B-Following-Orders" class="headerlink" title="3.拓扑排序 - B - Following Orders"></a>3.拓扑排序 - B - Following Orders</h2><h3 id="题目标签-2"><a href="#题目标签-2" class="headerlink" title="题目标签"></a>题目标签</h3><p>拓扑排序</p><p>DFS</p><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个字母序列</p><p>以及字母之间的关系</p><p>按字典序以及字母之间的关系求出所有的全排列</p><h3 id="题目解析-2"><a href="#题目解析-2" class="headerlink" title="题目解析"></a>题目解析</h3><p>求拓扑全排列</p><p>按照常规全排列的思想用DFS去搜索</p><p>首先按照常规方法读入，这里注意要把字母转换为数字，再进行sort排序，保证最后输出的一定是按字典序来的</p><p>记录答案，记录对应的字母，输出答案再把数字转换为字母即可</p><p>搜索：</p><p>每次dfs，按照排序后的数字进行遍历</p><p>将没有访问过的和入度为0的进行下一次dfs</p><p>dfs前把该数打上标记</p><ul><li>他连接的所有点的入读都减一</li><li>这个点的vis记录为true</li></ul><h3 id="通过代码-2"><a href="#通过代码-2" class="headerlink" title="通过代码"></a>通过代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 1001</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line"><span class="type">int</span> in[N];</span><br><span class="line"><span class="type">int</span> g[N][N];</span><br><span class="line"><span class="type">int</span> num[N];</span><br><span class="line"><span class="type">int</span> ans[N];</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span>BFS怎么做这道题</span></span><br><span class="line"><span class="comment">//转换成数字</span></span><br><span class="line"><span class="comment">//顺序遍历num,遇到的如果入度为0了，那么就添加，并用ans记录。</span></span><br><span class="line"><span class="comment">// vis记录是否访问，以便不重复</span></span><br><span class="line"><span class="comment">// dfs要进行回溯</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">toposort</span><span class="params">(<span class="type">int</span> cur)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cur == n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, +<span class="built_in">char</span>(ans[i] + <span class="string">&#x27;a&#x27;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (vis[num[i]] == <span class="literal">false</span> &amp;&amp; in[num[i]] == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            vis[num[i]] = <span class="literal">true</span>;</span><br><span class="line">            ans[cur] = num[i];</span><br><span class="line">            <span class="comment">//下一个点的访问到的点</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (g[num[i]][num[j]])</span><br><span class="line">                    in[num[j]]--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">toposort</span>(cur + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">//回溯</span></span><br><span class="line">            vis[num[i]] = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (g[num[i]][num[j]])</span><br><span class="line">                    in[num[j]]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string line;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">getline</span>(cin, line))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(vis, <span class="literal">false</span>, <span class="built_in">sizeof</span>(vis));</span><br><span class="line">        <span class="built_in">memset</span>(in, <span class="number">0</span>, <span class="built_in">sizeof</span>(in));</span><br><span class="line">        <span class="built_in">memset</span>(g, <span class="number">0</span>, <span class="built_in">sizeof</span>(g));</span><br><span class="line"></span><br><span class="line">        n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; line.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (line[i] &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; line[i] &lt;= <span class="string">&#x27;z&#x27;</span>)</span><br><span class="line">                num[n++] = line[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(num, num + n);</span><br><span class="line">        <span class="built_in">getline</span>(cin, line);</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>, temp[<span class="number">2</span>]; <span class="comment">//每两个字母读取一次</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; line.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (line[i] != <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">                temp[cnt++] = line[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (cnt == <span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                cnt = <span class="number">0</span>;</span><br><span class="line">                g[temp[<span class="number">0</span>]][temp[<span class="number">1</span>]] = <span class="number">1</span>;</span><br><span class="line">                in[temp[<span class="number">1</span>]]++; <span class="comment">//入度</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">toposort</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-博弈论练习-C-Being-a-Good-Boy-in-Spring-Festival"><a href="#4-博弈论练习-C-Being-a-Good-Boy-in-Spring-Festival" class="headerlink" title="4.博弈论练习 - C - Being a Good Boy in Spring Festival"></a>4.博弈论练习 - C - Being a Good Boy in Spring Festival</h2><h3 id="题目标签-3"><a href="#题目标签-3" class="headerlink" title="题目标签"></a>题目标签</h3><p>博弈论；</p><p>nim博弈；</p><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><p>有m堆牌，可以任意牌堆中取走任意张，全部取光游戏结束，拿走最后一张牌的人获胜</p><p>求先手要获胜，第一步有多少种可能</p><h3 id="题目解析-3"><a href="#题目解析-3" class="headerlink" title="题目解析"></a>题目解析</h3><p>根据nim博弈的结论</p><p>要让对手成为<code>必败局势</code>,那么对$x_i$，取出$(x_i - x_i \wedge x_0)$，让牌数$x_i$变为$(x_i - x_i \wedge x_0)$即可</p><p>而这样的$x_i$的数量取决于$x_i \wedge x_0 &lt; x_i$的数量</p><p>于是先求出所有的数的异或</p><p>再遍历每一个数即可</p><h3 id="通过代码-3"><a href="#通过代码-3" class="headerlink" title="通过代码"></a>通过代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 1001</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 0x3f3f3f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(ll n)</span></span>&#123;</span><br><span class="line">    ll a[<span class="number">101</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    ll sum=<span class="number">0</span>;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">        sum^=a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]&gt;(sum^a[i]))&#123;</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n;</span><br><span class="line">    <span class="keyword">while</span> (cin&gt;&gt;n &amp;&amp; n!=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">solve</span>(n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-博弈论练习-D-Fibonacci-again-and-again"><a href="#5-博弈论练习-D-Fibonacci-again-and-again" class="headerlink" title="5.博弈论练习 - D - Fibonacci again and again"></a>5.博弈论练习 - D - Fibonacci again and again</h2><h3 id="题目标签-4"><a href="#题目标签-4" class="headerlink" title="题目标签"></a>题目标签</h3><p>博弈论;</p><p>nim博弈</p><p>SG函数</p><h3 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h3><p>有n堆牌，每次可以任意堆里取x张牌</p><p>x必须是斐波那契数列中的数</p><h3 id="题目解析-4"><a href="#题目解析-4" class="headerlink" title="题目解析"></a>题目解析</h3><p>首先打斐波那契表</p><p>因为题目数据直到1000，所有直接手写一个就可以</p><p>然后就是打表sg函数</p><h3 id="通过代码-4"><a href="#通过代码-4" class="headerlink" title="通过代码"></a>通过代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10010</span>;</span><br><span class="line"><span class="type">int</span> f[<span class="number">15</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">13</span>, <span class="number">21</span>, <span class="number">34</span>, <span class="number">55</span>, <span class="number">89</span>, <span class="number">144</span>, <span class="number">233</span>, <span class="number">377</span>, <span class="number">610</span>, <span class="number">987</span>&#125;;</span><br><span class="line"><span class="type">int</span> s[N];</span><br><span class="line"><span class="type">int</span> sg[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getSg</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(sg,<span class="number">0</span>,<span class="built_in">sizeof</span>(sg));</span><br><span class="line">    <span class="comment">//sg[0]=0,所以循环从1开始</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(s,<span class="number">0</span>,<span class="built_in">sizeof</span>(s));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=n&amp;&amp;f[j]&lt;=i;j++)</span><br><span class="line">            s[sg[i-f[j]]]=<span class="number">1</span>;<span class="comment">//当前节点可以转到的下一状态标记</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=n;j++)&#123; <span class="comment">//查询当前后继状态SG值中最小的非零值</span></span><br><span class="line">            <span class="keyword">if</span>(!s[j])&#123;</span><br><span class="line">                sg[i]=j;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a, b, c;</span><br><span class="line">    <span class="built_in">getSg</span>(<span class="number">1001</span>);</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &amp;&amp; a != <span class="number">0</span> &amp;&amp; b != <span class="number">0</span> &amp;&amp; c != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(f, <span class="number">-1</span>, <span class="built_in">sizeof</span>(f)); <span class="comment">//初始化f均为-1,方便在sg函数中查看x是否被记录过</span></span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        res ^= sg[a];</span><br><span class="line">        res ^= sg[b];</span><br><span class="line">        res ^= sg[c];</span><br><span class="line">        <span class="comment">//观察异或值的变化,基本原理与Nim游戏相同</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (res != <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Fibo\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Nacci\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="6-并查集练习-C-The-Suspects"><a href="#6-并查集练习-C-The-Suspects" class="headerlink" title="6.并查集练习 - C - The Suspects"></a>6.并查集练习 - C - The Suspects</h2><h3 id="题目标签-5"><a href="#题目标签-5" class="headerlink" title="题目标签"></a>题目标签</h3><p>并查集</p><h3 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h3><p>某地爆发了疫情</p><p>给出一堆序列，表示这些人曾存在同一场所，为密接</p><p>已知0号为携带者，所有和他为密接的人都会被感染</p><p>求最后感染的总人数</p><h3 id="题目解析-5"><a href="#题目解析-5" class="headerlink" title="题目解析"></a>题目解析</h3><p>记录结点数量的并查集，统计0号结点所在位置的并查集的大小即可</p><p>记录结点数量：每个并查集的数量记录在最大祖先结点上，所有人初始化为1</p><p>每次合并时，让合并后的祖先更新size大小</p><p>查询时查询size[find(0)]即可</p><h3 id="通过代码-5"><a href="#通过代码-5" class="headerlink" title="通过代码"></a>通过代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> fa[<span class="number">30005</span>];</span><br><span class="line"><span class="type">int</span> size[<span class="number">30005</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (x != fa[x])</span><br><span class="line">        x = fa[x] = fa[fa[x]];</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="built_in">find</span>(x);</span><br><span class="line">    y=<span class="built_in">find</span>(y);</span><br><span class="line">    <span class="keyword">if</span>(x==y) <span class="keyword">return</span>;</span><br><span class="line">    fa[y] = x;</span><br><span class="line">    size[x]+=size[y];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; n &gt;&gt; m &amp;&amp; n+m!=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(fa,<span class="number">0</span>,<span class="built_in">sizeof</span>(fa));</span><br><span class="line">        <span class="built_in">memset</span>(size,<span class="number">0</span>,<span class="built_in">sizeof</span>(size));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            fa[i] = i;</span><br><span class="line">            size[i]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> num;cin&gt;&gt;num;</span><br><span class="line">            <span class="type">int</span> father;cin&gt;&gt;father;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>;j &lt; num; j++)<span class="comment">//合并所有</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> son;cin&gt;&gt;son;</span><br><span class="line">                <span class="built_in">merge</span>(father,son);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="comment">//</span></span><br><span class="line">        cout&lt;&lt;size[<span class="built_in">find</span>(<span class="number">0</span>)]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="7-并查集练习-D-Find-them-Catch-them"><a href="#7-并查集练习-D-Find-them-Catch-them" class="headerlink" title="7.并查集练习 - D - Find them, Catch them"></a>7.并查集练习 - D - Find them, Catch them</h2><h3 id="题目标签-6"><a href="#题目标签-6" class="headerlink" title="题目标签"></a>题目标签</h3><p>并查集</p><h3 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h3><p>有两个帮派的人分别为龙和虎</p><p>现有n人，编号为1-n，要么隶属于龙，要么隶属于虎</p><p>现在每行给出一个操作符 和 两个数</p><p>D表示两个人不是同一帮派的</p><p>A表示查询这两个人是否为同一帮派的</p><h3 id="题目解析-6"><a href="#题目解析-6" class="headerlink" title="题目解析"></a>题目解析</h3><p>使用到<strong>种类并查集</strong></p><p>普通并查集是以朋友的朋友还是朋友的思路串在一起</p><p>而种类并查集是以<strong>敌人的敌人是朋友</strong>联系在一起</p><p>所以要开两倍数组，以n为分界线</p><p>表示朋友时，那么在分界线内合并</p><p>​    即<code>merge(a,b);merge(a+n,b+n)</code></p><p>表示敌人时，那么跨过分界线合并</p><p>​    即<code>merge(a+n,b);merge(a,b+n)</code></p><p><img src="https://pic4.zhimg.com/v2-d86d178ed411c7c0d98402359efe5360_1440w.jpg?source=172ae18b" alt="算法学习笔记(7)：种类并查集"></p><p>若有三种不同种类，则开三倍数组</p><h3 id="通过代码-6"><a href="#通过代码-6" class="headerlink" title="通过代码"></a>通过代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> fa[<span class="number">200010</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (x != fa[x])</span><br><span class="line">        x = fa[x] = fa[fa[x]];</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fa[<span class="built_in">find</span>(y)] = <span class="built_in">find</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> m, n;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;=<span class="number">2</span>*n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            fa[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">char</span> op[<span class="number">2</span>];</span><br><span class="line">            <span class="type">int</span> b, c;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%s %d %d&quot;</span>,op,&amp;b,&amp;c);</span><br><span class="line">            <span class="keyword">if</span> (op[<span class="number">0</span>] == <span class="string">&#x27;D&#x27;</span>) <span class="comment">//合并不同类</span></span><br><span class="line">            &#123;              <span class="comment">//合并</span></span><br><span class="line">                <span class="built_in">merge</span>(b + n, c);</span><br><span class="line">                <span class="built_in">merge</span>(b, c + n);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">&#x27;A&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">find</span>(b) == <span class="built_in">find</span>(c))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;In the same gang.\n&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">find</span>(b + n) == <span class="built_in">find</span>(c))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;In different gangs.\n&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;Not sure yet.\n&quot;</span>);<span class="comment">//</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法周记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>22暑期ACM集训周记05</title>
      <link href="/2022/08/15/ACM%E5%91%A8%E8%AE%B0/%E6%9A%91%E6%9C%9FACM%E5%91%A8%E8%AE%B05/"/>
      <url>/2022/08/15/ACM%E5%91%A8%E8%AE%B0/%E6%9A%91%E6%9C%9FACM%E5%91%A8%E8%AE%B05/</url>
      
        <content type="html"><![CDATA[<h1 id="一、第五周学习总结表"><a href="#一、第五周学习总结表" class="headerlink" title="一、第五周学习总结表"></a>一、第五周学习总结表</h1><ul><li><h3 id="本周学习完成情况"><a href="#本周学习完成情况" class="headerlink" title="本周学习完成情况"></a>本周学习完成情况</h3></li></ul><table border="1"><tr> <th>Contest</th> <th>完成情况</th></tr><tr>  <td>数论1(快速幂、GCDLCM、扩欧)</td>  <td>6/16</td></tr><tr>  <td>数论2(同余与逆元、素数、抽屉原理) </td>  <td>8/14</td></tr><tr>  <td>组合数学1(杨辉三角、容斥原理、母函数)</td>  <td>5/8 </td></tr><tr>  <td>组合数学2(卡特兰数、stirling数)</td>  <td>6/11</td></tr><tr>    <td>背包问题</td>    <td>11/18</td></tr><tr>    <td>Atcoder比赛+补题</td>    <td>6/10</td></tr><tr>    <td>郑州大学比赛+补题</td>    <td>6/12</td></tr><tr>    <td>小白月赛比赛+补题</td>    <td>3/5</td></tr><tr>    <td><b>总计</b></td>    <td><b>51/64</b></td></td></tr></table><ul><li><h3 id="个人感悟"><a href="#个人感悟" class="headerlink" title="个人感悟"></a>个人感悟</h3><p>​        本周开始感觉有点力不从心，首先是每天的题目越来越多，但是学的也越来越难，主要是对数学知识理解的不够深刻，并且原本数学不怎么好。在学习数论的时候往往要很久才能理解，理解后也不能很快的应用在题目上面。另外每天题目很多，这周没来得及做的题目很多，却也没有什么时间去补题和写题解。有些灵感涌现时没有及时记录在题解内，很可惜。</p><p>​        希望下周可以及时的进行调整和自我反馈，越来越觉得有时候自我反馈和总结比一味的刷题更加重要。另外希望下周最后一周能对暑假所有所学的进行查漏补缺，把该补的题补完，该记录的模板概念都学完，并且做好对未来学习算法的规划。</p></li></ul><p>​        </p><h1 id="二、本周学习新内容"><a href="#二、本周学习新内容" class="headerlink" title="二、本周学习新内容"></a>二、本周学习新内容</h1><h3 id="1-求区间1-n之间与m互质的数的个数、"><a href="#1-求区间1-n之间与m互质的数的个数、" class="headerlink" title="1.求区间1-n之间与m互质的数的个数、"></a>1.求区间1-n之间与m互质的数的个数、</h3><p>求不互质的个数</p><p>$互质=总数-不互质的个数$</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ll <span class="title">primeNum</span><span class="params">(ll p, ll m)</span> </span>&#123;</span><br><span class="line">    v.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">2</span>; i * i &lt;= p; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p % i == <span class="number">0</span>) &#123;</span><br><span class="line">            v.<span class="built_in">push_back</span>(i);</span><br><span class="line">            <span class="keyword">while</span> (p % i == <span class="number">0</span>) p /= i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p &gt; <span class="number">1</span>) v.<span class="built_in">push_back</span>(p); <span class="comment">//求n的素因子</span></span><br><span class="line"></span><br><span class="line">    ll num = v.<span class="built_in">size</span>(); <span class="comment">//素因子的个数</span></span><br><span class="line">    ll sum = <span class="number">0</span>;           <span class="comment">// 1到m中与n不互素的数的个数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//枚举子集，不能有空集，所以从1开始</span></span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt; <span class="number">1</span> &lt;&lt; num; i++) &#123; <span class="comment">//从1枚举到(2^素因子个数)</span></span><br><span class="line">        ll cnt = <span class="number">0</span>;</span><br><span class="line">        ll t = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (ll j = <span class="number">0</span>; j &lt; num; j++) &#123; <span class="comment">//枚举每个素因子</span></span><br><span class="line">            <span class="keyword">if</span> (i &amp; (<span class="number">1</span> &lt;&lt; j)) &#123;        <span class="comment">//有第i个因子</span></span><br><span class="line">                cnt++;                 <span class="comment">//计数</span></span><br><span class="line">                t *= v[j];             <span class="comment">//乘上这个质因子</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//容斥原理</span></span><br><span class="line">        <span class="keyword">if</span> (cnt &amp; <span class="number">1</span>) <span class="comment">//选取个数为奇数，加</span></span><br><span class="line">            sum += m / t;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">//选取个数为偶数，减</span></span><br><span class="line">            sum -= m / t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m - sum; <span class="comment">//返回1-m中与n互素的数的个数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-求1-N含有0的个数"><a href="#2-求1-N含有0的个数" class="headerlink" title="2.求1-N含有0的个数"></a>2.求1-N含有0的个数</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ll <span class="title">getCount0</span><span class="params">(ll num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(num &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(num == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    ll base = <span class="number">1</span>;</span><br><span class="line">    ll sum = <span class="number">1</span>;</span><br><span class="line">    ll n = num;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//区别在于这一行代码，减掉了1</span></span><br><span class="line">        sum += base * (n / <span class="number">10</span> - <span class="number">1</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="type">int</span> cur = n % <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="number">0</span>) &#123;</span><br><span class="line">            sum += num % base + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cur &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            sum += base;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        base *= <span class="number">10</span>;</span><br><span class="line">        n = n / <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-博弈论"><a href="#3-博弈论" class="headerlink" title="3.博弈论"></a>3.博弈论</h3><p>Nim博弈：</p><p>即n堆个物品，每次可以里面取任意个。</p><p>所有数异或如果为0则先手输</p><p>所有数异或如果不为0则先手胜</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= n; k++)</span><br><span class="line">&#123;</span><br><span class="line">    ans ^= num[k];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-数论"><a href="#4-数论" class="headerlink" title="4.数论"></a>4.数论</h3><h4 id="1-唯一分解定理"><a href="#1-唯一分解定理" class="headerlink" title="1.唯一分解定理"></a>1.唯一分解定理</h4><p>任何一个大于1的自然数N，都可以被分解为有限个质数的乘积</p><p>即</p><script type="math/tex; mode=display">N=P_1^{a_1}*P_2^{a_2}*P_3^{a_3}*P_4^{a_4}*P_5^{a_5}······</script><p>其中$P_i$均为质数且$P_1&lt;P_2&lt;P_3&lt;P_4$</p><p>这样的分解称为$N的标准分解式$</p><h4 id="2-欧几里得算法"><a href="#2-欧几里得算法" class="headerlink" title="2.欧几里得算法"></a>2.欧几里得算法</h4><ol><li><h4 id="欧几里得算法求gcd-a-b"><a href="#欧几里得算法求gcd-a-b" class="headerlink" title="欧几里得算法求gcd(a,b)"></a>欧几里得算法求gcd(a,b)</h4></li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> b==<span class="number">0</span>?a:<span class="built_in">gcd</span>(b,a%b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><h4 id="扩展欧几里得算法"><a href="#扩展欧几里得算法" class="headerlink" title="扩展欧几里得算法"></a>扩展欧几里得算法</h4></li></ol><p>ax + by = d = gcd(a, b)</p><p><strong>$通解 = 特解 + 齐次解$</strong></p><p><strong>齐次解 :</strong></p><p>ax + by = gcd(a,b);</p><p><strong>通解：</strong></p><p>设d = gcd(a, b)</p><p>所以 x = r <em> b / d, y = －r </em> a / d;</p><p>x = x0 ＋ b / d * k</p><p>y = y0 － a / d * k</p><p>在欧几里得算法中</p><p>b = 0 时：ax + by = gcd = a, 既：x = 1, y = 0;</p><p>b != 0 时：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ax + by = gcd = <span class="built_in">d</span> (本层)</span><br><span class="line">bx1 + (a mod b)y1 = <span class="built_in">d</span> (裴蜀定理) （下一层）</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">bx1 + (a - [a / b] * b) * y1 = d</span><br><span class="line">ay1 + <span class="built_in">b</span>(x1 - [a / b] * y1) = d</span><br></pre></td></tr></table></figure><p> 所以：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">x = y1</span><br><span class="line">y = x1 - [a / b] * y1</span><br></pre></td></tr></table></figure><h4 id="3-同余定理"><a href="#3-同余定理" class="headerlink" title="3.同余定理"></a>3.同余定理</h4><ol><li><h4 id="同余定理即："><a href="#同余定理即：" class="headerlink" title="同余定理即："></a>同余定理即：</h4></li></ol><script type="math/tex; mode=display">若(a-b)\bmod m = 0 ，则a\bmod m = b\bmod m</script><ul><li>证明：</li></ul><script type="math/tex; mode=display">假设a\bmod m= b \bmod m\\可设a=m*k+d\\可设b=m*t+d\\则(a-b)\bmod m= (m*(k+t)+d-d)\bmod m=0</script><p>​        其实就是余数在相减的过程中被减去了</p><ol><li><h4 id="其他性质"><a href="#其他性质" class="headerlink" title="其他性质"></a>其他性质</h4><script type="math/tex; mode=display">(a+b) \bmod m=((a \bmod m)+(b \bmod m))\bmod m\\(a*b) \bmod m=((a \bmod m)*(b \bmod m))\bmod m</script><p>可以在题目中对大数取余的时候可以用到</p></li></ol><script type="math/tex; mode=display">a\bmod m =b \bmod m\\则a^n \bmod m= b^n \bmod m\\则a+c \bmod m= b+c \bmod m\\则a*c \bmod m= b*c \bmod m\\则gcd(a,m)=gcd(b,m)\\\\若d|m\\则a\bmod d =b \bmod d\\\\若c\bmod m =d \bmod m \\则a*c\bmod m =b*d \bmod m\\则a+c\bmod m =b+d \bmod m\\</script><p>​        两个数同余，那么他们的平方也同余，他们加上同样的数也同余</p><script type="math/tex; mode=display">a\bmod b=0\\c\bmod d=0\\a*b \bmod b*d =0</script><p>​        </p><h4 id="4-逆元"><a href="#4-逆元" class="headerlink" title="4.逆元"></a>4.逆元</h4><blockquote><p><code>逆元 —— 广义化的倒数 - 知乎 (zhihu.com)[https://zhuanlan.zhihu.com/p/449221995]</code></p></blockquote><p>定义x为mod p下的逆元</p><p>$a*x\equiv1 \pmod p$,且a与p互质</p><ol><li><h4 id="应用"><a href="#应用" class="headerlink" title="应用:"></a><strong>应用:</strong></h4><p>求$\frac{a}{b} \pmod p$</p><p>先求出$b \bmod p$下的逆元，再乘上$ a \bmod p$ </p></li><li><h4 id="求解："><a href="#求解：" class="headerlink" title="求解："></a>求解：</h4></li></ol><p>​        <strong>扩展欧几里得定理：</strong></p><p>​                有解的条件是a与p互素</p><p>​                求解$a*x\equiv1 \pmod p$</p><p>​                转化为$a<em>x+p</em>y=1$</p><p>​                即可以使用扩展欧几里得，解出x，再对x进行处理</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 1e9 + 7</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">exgcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> &amp;x, <span class="type">int</span> &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!b)</span><br><span class="line">    &#123;</span><br><span class="line">        x = <span class="number">1</span>, y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> x1, y1;</span><br><span class="line">    <span class="type">int</span> d = <span class="built_in">exgcd</span>(b, a % b, x1, y1);</span><br><span class="line">    x = y1, y = x1 - a / b * y1;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// a是求解数，b是模数</span></span><br><span class="line"><span class="function">ll <span class="title">inv</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    <span class="built_in">exgcd</span>(a, b, x, y);</span><br><span class="line">    x = (x % b + b) % b;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        <strong>费马小定理：</strong></p><p>​                p比较小，且a，p互质，满足:</p><p>​                $a^{p-1} \equiv 1 (\bmod {p})$</p><p>​                $x \equiv a^{p-2} \pmod p$</p><p>​                即可以用快速幂求解</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 1e9+7</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll m,ll n,ll p)</span></span>&#123;</span><br><span class="line">    ll sum = <span class="number">1</span>;</span><br><span class="line">    ll tmp = m;</span><br><span class="line">    <span class="keyword">while</span>(n != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &amp; <span class="number">1</span> == <span class="number">1</span>) (sum *= tmp)%=p;</span><br><span class="line">        (tmp *= tmp)%=p;</span><br><span class="line">        n = n &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">inv</span><span class="params">(ll a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">qpow</span>(a,MOD<span class="number">-2</span>,MOD);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">inv</span><span class="params">(ll a, ll mod)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">qpow</span>(a,mod<span class="number">-2</span>,mod);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        <strong>快速求阶乘逆元 $O(n)$：</strong></p><p>​                因为有如下一个递推关系。</p><p>​                $inv[i+1]=\frac{1}{(i+1)}!$</p><p>​                $inv[i+1]∗(i+1)=\frac1i!=inv[i]$</p><p>​                所以我们可以求出$n!$的逆元，然后逆推，就可以求出$1…n!$所有的逆元了。</p><p>​                逆递推式为:</p><p>​                $inv[i]=inv[i+1]∗(i+1) \ (\bmod p)$</p><p>​                正递推式为：</p><p>​                $inv[i]=inv[i-1]∗(i)^{-1}\ \ \ \   (\bmod p)$</p><p>​                所以我们可以求出 $∀i,i!,\frac1i$的取值了</p><p>​                <strong>即：</strong></p><p>​                $\displaystyle \frac{1}{i!} \times(i-1)!=\frac{1}{i} \pmod p$</p><p>​    <strong>线性推逆元：</strong></p><p>​                求一连串数字mod一个p的逆元</p><p>​                初始化$1^{−1}≡1(\bmod p)$</p><p>​                设 $p=k∗i+r,(1&lt;r&lt;i&lt;p)$</p><p>​                即$k=\frac pi,r=p\bmod i $</p><p>​                    $k*i+r \equiv 0 \pmod p$</p><p>​                左右同乘$r^{-1},r^{-1}$</p><p>​                最终可以化简得到</p><p>​                $i^{-1}\equiv -\lfloor \frac{p}{i} \rfloor*(p \bmod i)^{-1} \pmod p$</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">inv[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; p; ++ i)</span><br><span class="line">    inv[i] = (p - p / i) * inv[p % i] % p;</span><br></pre></td></tr></table></figure><ol><li><h4 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h4><p>当$gcd(a,p)!=1$时，$a^{−1}≡0\bmod p$</p><p>不存在逆元，有时候需要特判</p></li></ol><h4 id="5-素数筛"><a href="#5-素数筛" class="headerlink" title="5.素数筛"></a>5.素数筛</h4><ul><li><h4 id="埃式筛Eratosthenes"><a href="#埃式筛Eratosthenes" class="headerlink" title="埃式筛Eratosthenes"></a><strong>埃式筛</strong>Eratosthenes</h4></li></ul><blockquote><p>时间复杂度$O(n*log(logn))$</p><p>大O表示法中所展现的$logn$ 仅表示为对数级的数量级，一般认为以 2 为底，但并不做严格限制</p></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 埃式筛原理:如果当前数组是质数，把他的所有倍数都筛掉 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 1000</span></span><br><span class="line"><span class="type">bool</span> isprime[maxn];</span><br><span class="line"><span class="type">int</span> prime[maxn];</span><br><span class="line"><span class="comment">//n生成从2-n</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">eths</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> t=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">2</span>; i&lt;n; i++) &#123;</span><br><span class="line">isprime[i]=<span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span> (isprime[i]) &#123;</span><br><span class="line">prime[t++]=i;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">2</span>;i*j&lt;n;j++)&#123;</span><br><span class="line">isprime[i*j]=<span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><h4 id="欧拉筛"><a href="#欧拉筛" class="headerlink" title="欧拉筛"></a>欧拉筛</h4></li></ul><blockquote><p>注意i=2</p><p>若是n以内包括n，则要i&lt;=n</p><p>每个合数都用最小的质数去筛</p><p>核心：保证prime[j]*i，即被筛的那个数，里面的最小质因子是prime[j]，而不是i的因子。如果除通了，说明已经prime[j]已经是i的最小的质因子了。</p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 10000000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">bool</span> isprime[maxn];</span><br><span class="line"><span class="type">int</span> prime[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Euler</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> t=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">2</span>; i&lt;n; i++) &#123;</span><br><span class="line">isprime[i]=<span class="literal">true</span>;<span class="comment">//2-n初始化</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (isprime[i]) &#123;</span><br><span class="line">prime[t++]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>; j&lt;t &amp;&amp; i*prime[j]&lt;=n; j++) &#123;</span><br><span class="line">          <span class="comment">//判断条件j不能超过现有质数的个数，且相乘即被筛的数不能越上界</span></span><br><span class="line">          isprime[prime[j]*i]=<span class="literal">false</span>;</span><br><span class="line">          <span class="keyword">if</span> (i%prime[j]==<span class="number">0</span>) &#123;<span class="comment">//解析详见下文</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解析</strong></p><ol><li><code>prime[j]%i！=0</code>，由于<code>prime[j]</code>从小到大遍历的质数数组中的一个。除不通，说明i的最小质因子比<code>prime[j]</code>还大，此时所有i的质因子都比<code>primes[j]</code>大，则相乘的那个数的最小质因子一定是<code>prime[j]</code></li><li><code>prime[j]%i==0</code>，则说明<code>prime[j]</code>已经便利到了i的最小质因数，<strong>如果此时不<code>break;</code>，则后面所筛掉的数，也就是prime[j]*i的最小质因子不是<code>prime[j]</code>，而是i的因子</strong>。不能保证<code>prime[j]</code>就是<code>prime[j]*i</code>的最小质因子，那么后面就会被重复筛掉，从而不能达到每个数只被筛一次的算法</li></ol><h4 id="6-GCD和LCM"><a href="#6-GCD和LCM" class="headerlink" title="6.GCD和LCM"></a>6.GCD和LCM</h4><ol><li><h4 id="性质："><a href="#性质：" class="headerlink" title="性质："></a>性质：</h4><ul><li><p><strong>可重复贡献:</strong></p><p>$gcd(a,b,c)=gcd(gcd(a,b),c)=gcd(a,gcd(b,c))$</p></li><li><p>$gcd(a,0)=a,gcd(a,b)=gcd(a,-b)$</p></li><li><p>$gcd(a,b)=gcd(b,a\bmod b)$</p></li><li><p>$gcd(a,b)=d, gcd(a/d,b/d)=1$</p></li></ul></li></ol><p>多个值的GCD和LCM</p><h4 id="7-矩阵快速幂"><a href="#7-矩阵快速幂" class="headerlink" title="7.矩阵快速幂"></a>7.矩阵快速幂</h4><p><img src="https://gitee.com/wzy2002/pic-bed/raw/master/img/9zfncisd.png" alt="img"></p><p>第i行第j列的数=第i行的第k个数*第j列的第k个数</p><p>代码</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; N; j++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; N; k++)</span><br><span class="line">                t[i][j] = (t[i][j] + a[i][k] * b[k][j]);</span><br></pre></td></tr></table></figure><h4 id="8-卡特兰数"><a href="#8-卡特兰数" class="headerlink" title="8.卡特兰数"></a>8.卡特兰数</h4><ol><li><h4 id="求解方法"><a href="#求解方法" class="headerlink" title="求解方法"></a>求解方法</h4><p><strong>通项公式法：</strong></p><p>$Cat_n=\frac{C^{n}_{2n}}{n+1}=\frac{(2n!)}{(n+1)!n!}=C_{2n}^{n}-C_{2n}^{n-1}$</p><p><strong>递推法:</strong></p><p>$Cat_n=\Sigma Cat_k*Cat_{n-k},Cat_0=1$</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ll c[N]=&#123;<span class="number">1</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">catalan</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        c[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            c[i] += c[j] * c[i - <span class="number">1</span> - j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$Cat_n=\frac{4n-2}{n+1}*C_{n-1},Cat_0=1$</p></li><li><h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><p>针对大数取模，可以使用通项公式</p><p>$Cat_n=\frac{C^{n}_{2n}}{n+1}$</p><p>配合预处理阶乘逆元求解</p><p>针对特大数，可用递推公式，配合高精度乘法/加法</p></li></ol><h1 id="三、题解一览"><a href="#三、题解一览" class="headerlink" title="三、题解一览"></a>三、题解一览</h1><h2 id="1-郑州大学-K-魔法数"><a href="#1-郑州大学-K-魔法数" class="headerlink" title="1.郑州大学 - K -魔法数"></a>1.郑州大学 - K -魔法数</h2><h3 id="题目标签"><a href="#题目标签" class="headerlink" title="题目标签"></a>题目标签</h3><p>数论</p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>定义满足以下条件的数为”魔法数”：</p><p>* 该数是正整数<br>* 该数的正约数有55个</p><p>16的正约数有1、2、4、8、16，因此16是魔法数。</p><p>20的正约数有1、2、4、5、10、20，因此20不是魔法数。</p><p>给定 l 和 r，求区间 [l,r]中魔法数的个数。</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><p>结论题，知道结论就非常好做</p><p>一个大于1的正整数N，如果它的标准分解式为：</p><p><img src="https://bkimg.cdn.bcebos.com/formula/d879b88987aa2544a64c94be0e5af01a.svg" alt="img"></p><p> 那么它的正因数个数为</p><p><img src="https://bkimg.cdn.bcebos.com/formula/70a59ee42e34cee1aa27ca4c8803ce72.svg" alt="img"></p><p> 所以求因子为五个的数</p><p>那么只有一种可能，他是某个质数的四倍，也就是$N=P_1^{4}$</p><p>所以先打素数筛，再把所取的数开四次方，求得范围</p><p>然后利用容斥原理，前缀和相减即可得到答案</p><h3 id="通过代码"><a href="#通过代码" class="headerlink" title="通过代码"></a>通过代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 1001</span></span><br><span class="line"><span class="type">bool</span> isprime[N];</span><br><span class="line">ll prime[N];</span><br><span class="line">ll t=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Euler</span><span class="params">(ll n)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (ll i=<span class="number">2</span>; i&lt;=n; i++) &#123;</span><br><span class="line">isprime[i]=<span class="literal">true</span>;<span class="comment">//2-n初始化</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (ll i=<span class="number">0</span>; i&lt;=n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (isprime[i]) &#123;</span><br><span class="line">prime[t++]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (ll j=<span class="number">0</span>; j&lt;t &amp;&amp; i*prime[j]&lt;=n; j++) &#123;</span><br><span class="line">          <span class="comment">//判断条件j不能超过现有质数的个数，且相乘即被筛的数不能越上界</span></span><br><span class="line">          isprime[prime[j]*i]=<span class="literal">false</span>;</span><br><span class="line">          <span class="keyword">if</span> (i%prime[j]==<span class="number">0</span>) &#123;<span class="comment">//解析详见下文</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll m,ll n)</span></span>&#123;</span><br><span class="line">    ll sum = <span class="number">1</span>;</span><br><span class="line">    ll tmp = m;</span><br><span class="line">    <span class="keyword">while</span>(n != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &amp; <span class="number">1</span> == <span class="number">1</span>)&#123;</span><br><span class="line">            sum *= tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        tmp *= tmp;</span><br><span class="line">        n = n &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">Euler</span>(N);</span><br><span class="line">    ll sum[<span class="number">1000</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">0</span>; i &lt;t; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum[prime[i]]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= <span class="number">1000</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum[i]=sum[i]+sum[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    ll t;cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span> (t--)</span><br><span class="line">    &#123;</span><br><span class="line">        ull l,r;cin&gt;&gt;l&gt;&gt;r;</span><br><span class="line">        <span class="type">int</span> kfl=<span class="built_in">floor</span>(<span class="built_in">sqrt</span>(<span class="built_in">sqrt</span>(l)));</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">qpow</span>(l,<span class="number">4</span>)==l)&#123;</span><br><span class="line">            kfl--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> kfr=<span class="built_in">floor</span>(<span class="built_in">sqrt</span>(<span class="built_in">sqrt</span>(r)));</span><br><span class="line">        cout&lt;&lt;sum[kfr]-sum[kfl];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-组合数学1-B-Visible-Trees"><a href="#2-组合数学1-B-Visible-Trees" class="headerlink" title="2.组合数学1 - B - Visible Trees"></a>2.组合数学1 - B - Visible Trees</h2><h3 id="题目标签-1"><a href="#题目标签-1" class="headerlink" title="题目标签"></a>题目标签</h3><p>容斥原理</p><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>给出一个m*n的方格，每个格子里都种了树</p><p>和树在一条直线上的视线都会被挡住，问在起点能看见多少树</p><h3 id="题目解析-1"><a href="#题目解析-1" class="headerlink" title="题目解析"></a>题目解析</h3><p><img src="https://gitee.com/wzy2002/pic-bed/raw/master/img/image-20220811190829095.png" alt="image-20220811190829095" style="zoom: 50%;" /></p><p>如图所示，只有视线的第一颗树会被看到，后面的树都被遮挡住了，可见被挡住的树都和第一颗树都在同一条直线上。</p><p>而后面被挡住的树的坐标$(x_i,y_i)$，自然也就是第一棵树的坐标$(x_1,y_1)$的倍数。</p><p>即$x_i=k<em>x_1,y_i=k</em>y_1$</p><p>所以$gcd(x_i,y_i)!=1$,也就是被挡住的数都是可以约分的</p><p>反过来说，没有被挡住的树，就是坐标$(x,y)$互质的。</p><p>而我们需要求$n*m$对的方格里的被挡住的树，也就是我们只需要.</p><p>对第$1-n$列,求出第$i$列，与坐标$i$互质的$y$的个数就可以了</p><h3 id="通过代码-1"><a href="#通过代码-1" class="headerlink" title="通过代码"></a>通过代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">vector&lt;ll&gt; p;</span><br><span class="line"><span class="comment">//1到m之间与n互素的</span></span><br><span class="line"><span class="function">ll <span class="title">cal</span><span class="params">(ll n, ll m)</span> </span>&#123;</span><br><span class="line">    p.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">2</span>; i * i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n % i == <span class="number">0</span>) &#123;</span><br><span class="line">            p.<span class="built_in">push_back</span>(i);</span><br><span class="line">            <span class="keyword">while</span> (n % i == <span class="number">0</span>) n /= i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">1</span>) p.<span class="built_in">push_back</span>(n); <span class="comment">//求n的素因子</span></span><br><span class="line"></span><br><span class="line">    ll num = p.<span class="built_in">size</span>(); <span class="comment">//素因子的个数</span></span><br><span class="line">    ll s = <span class="number">0</span>;           <span class="comment">// 1到m中与n不互素的数的个数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//枚举子集，不能有空集，所以从1开始</span></span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt; <span class="number">1</span> &lt;&lt; num; i++) &#123; <span class="comment">//从1枚举到(2^素因子个数)</span></span><br><span class="line">        ll cnt = <span class="number">0</span>;</span><br><span class="line">        ll t = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (ll j = <span class="number">0</span>; j &lt; num; j++) &#123; <span class="comment">//枚举每个素因子</span></span><br><span class="line">            <span class="keyword">if</span> (i &amp; (<span class="number">1</span> &lt;&lt; j)) &#123;        <span class="comment">//有第i个因子</span></span><br><span class="line">                cnt++;                 <span class="comment">//计数</span></span><br><span class="line">                t *= p[j];             <span class="comment">//乘上这个质因子</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//容斥原理</span></span><br><span class="line">        <span class="keyword">if</span> (cnt &amp; <span class="number">1</span>) <span class="comment">//选取个数为奇数，加</span></span><br><span class="line">            s += m / t;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">//选取个数为偶数，减</span></span><br><span class="line">            s -= m / t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m - s; <span class="comment">//返回1-m中与n互素的数的个数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ll T;cin&gt;&gt;T;</span><br><span class="line">    <span class="keyword">while</span> (T--)</span><br><span class="line">    &#123;</span><br><span class="line">        ll m,n;</span><br><span class="line">        cin&gt;&gt;m&gt;&gt;n;</span><br><span class="line">        ll res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= m; i++)<span class="comment">//横坐标</span></span><br><span class="line">        &#123;</span><br><span class="line">            res+=<span class="built_in">cal</span>(i,n);</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;res&lt;&lt;endl;<span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-组合数学1-F-Ignatius-and-the-Princess-III"><a href="#3-组合数学1-F-Ignatius-and-the-Princess-III" class="headerlink" title="3.组合数学1 - F - Ignatius and the Princess III"></a>3.组合数学1 - F - Ignatius and the Princess III</h2><h3 id="题目标签-2"><a href="#题目标签-2" class="headerlink" title="题目标签"></a>题目标签</h3><p>组合数学；dp</p><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>把一个数拆分成若干个数，问方案有几种</p><p>拆成的数可以一样，方案之间顺序不一样的只能算一种</p><p>比如5可以拆成</p><p>$(1,1,1,1,1) (1,1,1,2) (1,1,3) (1,4) (1,2,2) (2,3) (5)$</p><h3 id="题目解析-2"><a href="#题目解析-2" class="headerlink" title="题目解析"></a>题目解析</h3><p>如果用dfs，会超时</p><p>使用动态规划的思想，建立dp数组<code>dp[i][j]</code></p><p>代表的是数字i被拆成最大数不超过j的方案数</p><p>比如<code>dp[2][2]</code>就有$(1,1) (2)$两种方案</p><p>于是我们可以推出动态转移方程</p><p>当我们遍历时，</p><ul><li><p>j&gt;i，则可以都可以赋值为<code>dp[i][j-1]</code>，因为当前数字也不过i这么大，就算能限制的数字j大于i，也没用，还是上一次的赋值</p></li><li><p>j=i，则可以赋值为<code>dp[i][j-1]+1</code>，因为j从$i-1→i$的过程中，新增加的一种方案，只有单独一个$(i)$</p></li><li><p>j&lt;i，则可以赋值为<code>dp[i][j-1]+dp[i-j][j]</code>，当j&lt;i时，能出现的方案两种</p><ul><li>不选j——就是j-1时的所有方案</li><li>选j———-剩下的数i-j组成的所有方案</li></ul><p>两种方案相加即可</p></li></ul><p>于是可以得到动态转移方程</p><p>$\begin{align<em>}&amp;\\ \begin{cases}i&gt;j,dp[i][j]=dp[i][j-1]+dp[i-j][j] \\ i=j,dp[i][j]=dp[i][j-1]+1\\i&lt;j,dp[i][j]=dp[i][j-1]\end{cases} &amp;\end{align</em>}$</p><h3 id="通过代码-2"><a href="#通过代码-2" class="headerlink" title="通过代码"></a>通过代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 1001</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//将数字n,分解为不超过m的方案数</span></span><br><span class="line">    <span class="comment">// dp[1][1]=1;</span></span><br><span class="line">    <span class="comment">// dp[2][1]=1;dp[2][2]=2;</span></span><br><span class="line">    <span class="comment">// dp[3][1]=1;dp[3][2]=2;dp[3][3]=3;</span></span><br><span class="line">    <span class="comment">//当m=n，这时只能增加一种情况，也就是单个数，m的情况</span></span><br><span class="line">    <span class="comment">//当m&gt;n，这时就是上一层的数，因为加不了别的了</span></span><br><span class="line">    <span class="comment">//当n&lt;m，这时就是上一层不出现m的时候的方案数和出现m的方案数*n-m的方案数</span></span><br><span class="line">    <span class="type">int</span> dp[N][N] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    dp[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">121</span>; i++)</span><br><span class="line">        dp[i][<span class="number">1</span>] = dp[<span class="number">1</span>][i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">121</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">121</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &gt; i)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][j] = dp[i][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (j == i)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][j] = dp[i][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i &gt; j)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][j] = dp[i][j - <span class="number">1</span>] + dp[i - j][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; dp[n][n] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-排列组合-G-排列组合"><a href="#4-排列组合-G-排列组合" class="headerlink" title="4.排列组合 - G - 排列组合"></a>4.排列组合 - G - 排列组合</h2><h3 id="题目标签-3"><a href="#题目标签-3" class="headerlink" title="题目标签"></a>题目标签</h3><p>有n种物品，并且知道每种物品的数量。要求从中选出m件物品的排列数。例如有两种物品A,B，并且数量都是1，从中选2件物品，则排列有”AB”,”BA”两种</p><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><p>母函数</p><h3 id="题目解析-3"><a href="#题目解析-3" class="headerlink" title="题目解析"></a>题目解析</h3><p>使用指数型母函数，生成解</p><p>即<strong>把组合问题的加法与幂</strong></p><p><strong>级数的乘幂对应起来</strong></p><p><img src="https://gitee.com/wzy2002/pic-bed/raw/master/img/image-20220811195909203.png" alt="image-20220811195909203"></p><p>不断将当前的一个括号内的多项式，与下一个括号内的多项式相乘</p><p>即可得到最终的每一个多项式的系数</p><p>但是要将系数now[n]*fac[n]</p><p>注意：</p><ol><li>最后打印结果要保留整数，使用<code>printf(&quot;%.0f\n&quot;,res);</code></li><li>每次乘完，要将nxt复制到now，并将nxt清零</li></ol><h3 id="通过代码-3"><a href="#通过代码-3" class="headerlink" title="通过代码"></a>通过代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> fac[<span class="number">20</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        fac[i] = fac[i - <span class="number">1</span>] * i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>(<span class="number">20</span>);</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; n &gt;&gt; m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> num[<span class="number">20</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; num[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//每次乘后面一个</span></span><br><span class="line">        <span class="type">double</span> now[<span class="number">20</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="type">double</span> nxt[<span class="number">20</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        now[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="comment">//从第二个开始</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= num[i]; j++) <span class="comment">//下一个</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; j + k &lt;= m; k++)</span><br><span class="line">                &#123;</span><br><span class="line">                    nxt[j + k] += now[k] / fac[j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">memcpy</span>(now, nxt, <span class="built_in">sizeof</span>(nxt));</span><br><span class="line">            <span class="built_in">memset</span>(nxt,<span class="number">0</span>,<span class="built_in">sizeof</span>(nxt));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">double</span> res = now[m] * fac[m];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%.0f\n&quot;</span>,res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-郑州大学-A-想要更多的0"><a href="#5-郑州大学-A-想要更多的0" class="headerlink" title="5.郑州大学 - A - 想要更多的0"></a>5.郑州大学 - A - 想要更多的0</h2><h3 id="题目标签-4"><a href="#题目标签-4" class="headerlink" title="题目标签"></a>题目标签</h3><p>二分；数学</p><h3 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个数n，求一个 [0,n]之间最大的整数m，使得输出区间 [m,n]之间的所有数时至少输出了k个0，如果无解请输出-1</p><p>1&lt;= n,k &lt;= 10^18^</p><h3 id="题目解析-4"><a href="#题目解析-4" class="headerlink" title="题目解析"></a>题目解析</h3><p>本题两个问题有待解决：、</p><ol><li>数据范围过大 </li></ol><p>​        数据范围过大，思路是二分查找答案</p><p>​        查询一个点的0的个数，和n的0的个数进行比较，如果比较出来是不够k个</p><p>​        那么high=mid-1，如果够了或者超了那么low=mid</p><p>​        <strong>问题是边界的处理</strong></p><ol><li><p>如何获取前n个数含有的0的个数</p><p>使用</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ll <span class="title">getCount0</span><span class="params">(ll num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(num &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(num == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    ll base = <span class="number">1</span>;</span><br><span class="line">    ll sum = <span class="number">1</span>;</span><br><span class="line">    ll n = num;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//区别在于这一行代码，减掉了1</span></span><br><span class="line">        sum += base * (n / <span class="number">10</span> - <span class="number">1</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="type">int</span> cur = n % <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="number">0</span>) &#123;</span><br><span class="line">            sum += num % base + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cur &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            sum += base;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        base *= <span class="number">10</span>;</span><br><span class="line">        n = n / <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="通过代码-4"><a href="#通过代码-4" class="headerlink" title="通过代码"></a>通过代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function">ll <span class="title">getCount0</span><span class="params">(ll num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(num &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(num == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    ll base = <span class="number">1</span>;</span><br><span class="line">    ll sum = <span class="number">1</span>;</span><br><span class="line">    ll n = num;</span><br><span class="line">    <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//区别在于这一行代码，减掉了1</span></span><br><span class="line">        sum += base * (n / <span class="number">10</span> - <span class="number">1</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="type">int</span> cur = n % <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="number">0</span>) &#123;</span><br><span class="line">            sum += num % base + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cur &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            sum += base;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        base *= <span class="number">10</span>;</span><br><span class="line">        n = n / <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ull n,k;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    ll low=<span class="number">0</span>,high=n;</span><br><span class="line">    <span class="type">__int128_t</span> s=<span class="built_in">getCount0</span>(n);</span><br><span class="line">    <span class="keyword">while</span> (low&lt;high)</span><br><span class="line">    &#123;</span><br><span class="line">        ull mid=(low+high+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(s-<span class="built_in">getCount0</span>(mid)&gt;=k)&#123;</span><br><span class="line">            low=mid;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            high=mid<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;low+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id=""><a href="#" class="headerlink" title=" "></a> </h2>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法周记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>22暑期ACM集训周记04</title>
      <link href="/2022/08/07/ACM%E5%91%A8%E8%AE%B0/%E6%9A%91%E6%9C%9FACM%E5%91%A8%E8%AE%B04/"/>
      <url>/2022/08/07/ACM%E5%91%A8%E8%AE%B0/%E6%9A%91%E6%9C%9FACM%E5%91%A8%E8%AE%B04/</url>
      
        <content type="html"><![CDATA[<h1 id="一、第四周学习总结表"><a href="#一、第四周学习总结表" class="headerlink" title="一、第四周学习总结表"></a>一、第四周学习总结表</h1><ul><li><h3 id="本周学习完成情况"><a href="#本周学习完成情况" class="headerlink" title="本周学习完成情况"></a>本周学习完成情况</h3><table border="1"><tr><th>Contest</th><th>完成情况</th></tr><tr><td>LCS和LIS</td><td>6/9</td></tr><tr><td>动态规划基础 </td><td>13/22</td></tr><tr><td>高精度计算</td><td>10/10 </td></tr><tr><td>简单递推练习</td><td>13/13</td></tr><tr>  <td>树和二叉树</td>  <td>6/6</td></tr><tr>  <td>牛客</td>  <td>3/10</td></tr><tr>  <td>Atcoder</td>  <td>4/8</td></tr><tr>  <td><b>总计</b></td>  <td><b>55/78</b></td></td></tr></table></li><li><h3 id="个人感悟"><a href="#个人感悟" class="headerlink" title="个人感悟"></a>个人感悟</h3><p>​        本周开始，明显感觉到了难度的提升，每天的题目开始做不完了。而第二天又有新的题目，也没来的及去补题。难点主要在动态规划的思想难以真正的掌握，每道题目如果没有预先学习过相应的模型，具体算法分类。如没有学习区间DP之前，自己完全想不出来怎么写石子合并问题。如果在比赛过程中，遇到此类问题，将毫无下手空间。希望下周开始能把本周没有补完的动态规划补完，并学习更多的动态规划模型。</p></li></ul><h1 id="二、本周学习新内容"><a href="#二、本周学习新内容" class="headerlink" title="二、本周学习新内容"></a>二、本周学习新内容</h1><h3 id="1-inline函数"><a href="#1-inline函数" class="headerlink" title="1.inline函数"></a>1.inline函数</h3><p>inline定义类的内联函数，函数的代码被放入符号表中，在使用时直接进行替换（像宏一样展开）没有了调用的开销，效率也高了</p><p>如果需要多次调用，如快读的时候可以加上inline</p><h3 id="2-位运算技巧"><a href="#2-位运算技巧" class="headerlink" title="2.位运算技巧"></a>2.位运算技巧</h3><p>判断一个整数x是否为2的n次方</p><p>x &amp; (x-1) == 0</p><h3 id="3-算位数"><a href="#3-算位数" class="headerlink" title="3.算位数"></a>3.算位数</h3><p>一个数如果能表示为10^n^那么，他的位数，很显然就是int(n+1)</p><p>如：$10^1=10$位数为2.<br>        $10^{log_{10}20}=20$,$log_{10}20=1.3$ .位数为2</p><p>所以一个数为x^k^次方</p><p>则这个数的位数即为log~10~</p><h3 id="4-nullptr和NULL"><a href="#4-nullptr和NULL" class="headerlink" title="4.nullptr和NULL"></a>4.nullptr和NULL</h3><ul><li>NULL是一个宏定义，在c和c++中的定义不同，c中NULL为（void*)0,而c++中NULL为整数0</li></ul><p>​        所以在c++中int *p=NULL; 实际表示将指针P的值赋为0，而c++中当一个指针的值为0时，认为指针为空指针</p><ul><li>nullptr是一个字面值常量，类型为std::nullptr_t,空指针常数可以转换为任意类型的指针类型</li></ul><h3 id="5-快速求组合数"><a href="#5-快速求组合数" class="headerlink" title="5.快速求组合数"></a>5.快速求组合数</h3><ul><li><h4 id="预处理阶乘逆元求组合数"><a href="#预处理阶乘逆元求组合数" class="headerlink" title="预处理阶乘逆元求组合数"></a>预处理阶乘逆元求组合数</h4><p>有取模条件，根据取模条件，如果模数是质数用费马小定理，用快速幂就可求逆元，否则用扩展欧几里得求逆元</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> ll N = <span class="number">3e6</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> ll MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">ll fac[N], ifac[N];</span><br><span class="line">ll dp[<span class="number">1000010</span>];</span><br><span class="line"><span class="comment">// a 为求逆元的数，b 为模数，运算完成后 x 就是在模 a 下的逆元</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">exgcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> &amp;x, <span class="type">int</span> &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!b)</span><br><span class="line">&#123;</span><br><span class="line">x = <span class="number">1</span>, y = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> d = <span class="built_in">exgcd</span>(b, a % b, y, x);</span><br><span class="line">y -= a / b * x;</span><br><span class="line"><span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll a, ll b, ll MOD)</span> </span>&#123;</span><br><span class="line">    ll res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (b) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>)</span><br><span class="line">            res = <span class="number">1ll</span> * res * a % MOD;</span><br><span class="line">        a = <span class="number">1ll</span> * a * a % MOD;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(ll n)</span> </span>&#123;</span><br><span class="line">fac[<span class="number">0</span>] = ifac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">fac[i] = <span class="number">1ll</span> * fac[i - <span class="number">1</span>] * i % MOD;</span><br><span class="line">ifac[i] = <span class="number">1ll</span> * ifac[i - <span class="number">1</span>] * <span class="built_in">qpow</span>(i, MOD - <span class="number">2</span>, MOD) % MOD;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">C</span><span class="params">(ll a,ll b)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(a&lt;<span class="number">0</span> || b&lt;<span class="number">0</span> || a&lt;b) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> (<span class="number">1ll</span> * fac[a] * ifac[b] % MOD * ifac[a - b] % MOD);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h4 id="卢卡斯定理求组合数"><a href="#卢卡斯定理求组合数" class="headerlink" title="卢卡斯定理求组合数"></a>卢卡斯定理求组合数</h4><p>求大组合数<img src="https://latex.codecogs.com/gif.latex?C_%7Ba%7D%5Eb" alt="C_{a}^b">，a、b &gt; 1e10, and 模数 p 较小的情况下。求逆元根据p的情况来定，为质数可用费马小定理，否则用扩展欧几里得求逆元</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> ll MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">    ll res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (b) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>)</span><br><span class="line">            res = <span class="number">1ll</span> * res * a % MOD;</span><br><span class="line">        a = <span class="number">1ll</span> * a * a % MOD;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">C</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, j = a; i &lt;= b; i++, j--)</span><br><span class="line">&#123;</span><br><span class="line">res = (ll)res * j % MOD;</span><br><span class="line">res = (ll)res * <span class="built_in">qpow</span>(i, MOD - <span class="number">2</span>) % MOD;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lucas</span><span class="params">(ll a, ll b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (a &lt; MOD &amp;&amp; b &lt; MOD) <span class="keyword">return</span> <span class="built_in">C</span>(a, b);</span><br><span class="line"><span class="keyword">return</span> (ll)<span class="built_in">C</span>(a % MOD, b % MOD) * <span class="built_in">lucas</span>(a / MOD, b / MOD) % MOD;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="三、题解一览"><a href="#三、题解一览" class="headerlink" title="三、题解一览"></a>三、题解一览</h1><h2 id="1-AtCoder-Beginner-Contest-261-D-Flipping-and-Bonus"><a href="#1-AtCoder-Beginner-Contest-261-D-Flipping-and-Bonus" class="headerlink" title="1.AtCoder Beginner Contest 261 - D - Flipping and Bonus"></a>1.AtCoder Beginner Contest 261 - D - Flipping and Bonus</h2><h3 id="题目标签"><a href="#题目标签" class="headerlink" title="题目标签"></a>题目标签</h3><p>DP</p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>高桥君可以扔n次硬币，第<code>i</code>枚硬币面朝上加相应的得分<code>a[i]</code>，硬币面朝下则不加分</p><p>此外还有一个奖励机制，即高桥君连续正面朝上<code>j</code>次可以得到<code>c[j]</code>的得分，但是一旦正面朝下，i就会清零</p><p>请你算出高桥君最多能得到几分</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析`"></a>题目解析`</h3><p>本题使用动态规划的思想</p><p>定义DP数组<code>dp[i][j]</code>，i代表第i次扔硬币，j代表这是第j次连胜，转移过程中取最大值</p><p>当硬币面朝上时，$dp[i][j]=max(dp[i-1][j-1]+a[i]+c[j],dp[i][j])$</p><p>当硬币面朝下时，$dp[i][0]=max(dp[i][0],dp[i-1][j])$</p><p>硬币朝下的时候，取的就是前一次连胜为j时的得分的最大值，所以不会出现重复的情况</p><h3 id="通过代码"><a href="#通过代码" class="headerlink" title="通过代码"></a>通过代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> dp[N][N];  </span><br><span class="line"><span class="type">int</span> a[N];  </span><br><span class="line"><span class="type">int</span> w[N];  </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;  </span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;  </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];  </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;  </span><br><span class="line">        <span class="type">int</span> a,b;  </span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b;  </span><br><span class="line">        w[a]=b;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;  </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=i;j++)&#123;  </span><br><span class="line">            <span class="comment">//这回合赢了  </span></span><br><span class="line">            dp[i][j]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+w[j]+a[i],dp[i][j]);  </span><br><span class="line">            <span class="comment">//这回合输了  </span></span><br><span class="line">            dp[i][<span class="number">0</span>]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][j],dp[i][<span class="number">0</span>]);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;  </span><br><span class="line">        ans=<span class="built_in">max</span>(ans,dp[n][j]);  </span><br><span class="line">    &#125;  </span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-AtCoder-Beginner-Contest-261-E-Many-Operations"><a href="#2-AtCoder-Beginner-Contest-261-E-Many-Operations" class="headerlink" title="2.AtCoder Beginner Contest 261 - E - Many Operations"></a>2.AtCoder Beginner Contest 261 - E - Many Operations</h2><h3 id="题目标签-1"><a href="#题目标签-1" class="headerlink" title="题目标签"></a>题目标签</h3><p>位运算</p><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>一共有i次操作，每一次操作用一个ti和一个ai来改变x</p><ul><li>如果 ti=1, x=x&amp;a</li><li>如果 ti=2, x=x|a</li><li>如果 ti=3, x=x^a<br>现在进行n轮操作，<br>第i轮操作，将进行1,2,3…i−1,i次操作<br>询问每一轮操作后的x值，x是一直更新的</li></ul><h3 id="题目解析-1"><a href="#题目解析-1" class="headerlink" title="题目解析"></a>题目解析</h3><p>如果直接暴力方法，毫无意义问会超时</p><p>问题的关键在于如何优化，让每一轮的操作，都能被保留下来，并进行下一次运算，这样就可以减少时间复杂度</p><p>这里考虑二进制拆位，对每一轮的操作都记录并记录</p><p>通过前缀和记录，可以求得</p><h3 id="通过代码-1"><a href="#通过代码-1" class="headerlink" title="通过代码"></a>通过代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 2e5+10</span></span><br><span class="line"><span class="type">int</span> a[N];  </span><br><span class="line"><span class="type">int</span> oper[N];  </span><br><span class="line"><span class="type">int</span> pre[<span class="number">2</span>][<span class="number">30</span>][N];  </span><br><span class="line"><span class="type">int</span> ans[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cin&gt;&gt;oper[i]&gt;&gt;a[i];  </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">30</span>;i++) pre[<span class="number">1</span>][i][<span class="number">0</span>]=<span class="number">1</span>;  </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">30</span>;i++) pre[<span class="number">0</span>][i][<span class="number">0</span>]=<span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">30</span>;j++)&#123;  </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;  </span><br><span class="line">            <span class="type">int</span> x=(a[i]&gt;&gt;j)&amp;<span class="number">1</span>;  </span><br><span class="line">            <span class="keyword">if</span>(oper[i]==<span class="number">1</span>)&#123;  </span><br><span class="line">                pre[<span class="number">1</span>][j][i]=pre[<span class="number">1</span>][j][i<span class="number">-1</span>]&amp;x;  </span><br><span class="line">                pre[<span class="number">0</span>][j][i]=pre[<span class="number">0</span>][j][i<span class="number">-1</span>]&amp;x;  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(oper[i]==<span class="number">2</span>)&#123;  </span><br><span class="line">                pre[<span class="number">1</span>][j][i]=pre[<span class="number">1</span>][j][i<span class="number">-1</span>]|x;  </span><br><span class="line">                pre[<span class="number">0</span>][j][i]=pre[<span class="number">0</span>][j][i<span class="number">-1</span>]|x;  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">else</span> &#123;  </span><br><span class="line">                pre[<span class="number">1</span>][j][i]=pre[<span class="number">1</span>][j][i<span class="number">-1</span>]^x;  </span><br><span class="line">                pre[<span class="number">0</span>][j][i]=pre[<span class="number">0</span>][j][i<span class="number">-1</span>]^x;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">    ans[<span class="number">0</span>]=c;  </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;  </span><br><span class="line">        <span class="type">int</span> pres=ans[i<span class="number">-1</span>];  </span><br><span class="line">        <span class="type">int</span> now=<span class="number">0</span>;  </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">30</span>;j++)&#123;  </span><br><span class="line">            <span class="type">int</span> x=(pres&gt;&gt;j)&amp;<span class="number">1</span>;  </span><br><span class="line">                <span class="keyword">if</span>(pre[x][j][i]) now+=(<span class="number">1</span>&lt;&lt;(j));  </span><br><span class="line">        &#125;  </span><br><span class="line">        ans[i]=now;  </span><br><span class="line">        cout&lt;&lt;ans[i]&lt;&lt;<span class="string">&quot;\n&quot;</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-AtCoder-Beginner-Contest-263-D-Left-Right-Operation"><a href="#3-AtCoder-Beginner-Contest-263-D-Left-Right-Operation" class="headerlink" title="3.AtCoder Beginner Contest 263 - D - Left Right Operation"></a>3.AtCoder Beginner Contest 263 - D - Left Right Operation</h2><h3 id="题目标签-2"><a href="#题目标签-2" class="headerlink" title="题目标签"></a>题目标签</h3><p>DP</p><p>前缀和</p><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个序列，以及数字LR</p><p>你可以把任意前i个数字变成L</p><p>也可以把任意后i个数字变成R</p><p>求变完之后的最小值</p><h3 id="题目解析-2"><a href="#题目解析-2" class="headerlink" title="题目解析"></a>题目解析</h3><p>可以将问题转换：</p><p>改变数字再求最小值，也就是先找出所有改变的数字与原数字之差的和最小值，最后输出这个最小值+原数组的sum即可</p><p>所以我们可以先开两个数组lnum和rnum，记录原数字分别和L，R的差</p><p>然后对这些数字求前缀和/后缀和，并开一个数组dp，记录前/后i个前缀和的最小值</p><p>最后取ldp[i]+rdp[i+1]的最小值即可</p><p><strong>注意点：</strong></p><ol><li>数组的初始化ldp[0]和rdp[n+1]要初始化为0，表示一个数也不改变的情况，就是将原sum+0</li><li>minn的初始化取0，这样可以保证如果改变完数字，比原来还大了。说明不用改变任何一个，也就是让minn=0</li></ol><h3 id="通过代码-2"><a href="#通过代码-2" class="headerlink" title="通过代码"></a>通过代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(false), cin.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 200000+10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 0x3f3f3f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="comment">//前缀和和后缀和+dp</span></span><br><span class="line">ll num[N];</span><br><span class="line">ll lnum[N];</span><br><span class="line">ll rnum[N];</span><br><span class="line">ll lsum[N];</span><br><span class="line">ll rsum[N];</span><br><span class="line">ll ldp[N];</span><br><span class="line">ll rdp[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// freopen(&quot;3output.out&quot;,&quot;w&quot;,stdout);</span></span><br><span class="line">    <span class="comment">// freopen(&quot;1input.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">    ll n, l, r;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld %lld %lld&quot;</span>, &amp;n, &amp;l, &amp;r);</span><br><span class="line">    ll allsum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;num[i]);</span><br><span class="line">        allsum += num[i];</span><br><span class="line"></span><br><span class="line">        lnum[i] = l - num[i];</span><br><span class="line">        rnum[i] = r - num[i];</span><br><span class="line">    &#125;</span><br><span class="line">    ldp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    rdp[n + <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        lsum[i] = lsum[i - <span class="number">1</span>] + lnum[i];</span><br><span class="line">        ldp[i] = <span class="built_in">min</span>(ldp[i - <span class="number">1</span>], lsum[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (ll i = n; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        rsum[i] = rsum[i + <span class="number">1</span>] + rnum[i];</span><br><span class="line">        rdp[i] = <span class="built_in">min</span>(rdp[i + <span class="number">1</span>], rsum[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    ll minn = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        minn = <span class="built_in">min</span>(minn, rdp[i+<span class="number">1</span>] + ldp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; allsum + minn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-哈理工暑假训练赛-F-奇怪的魔法"><a href="#4-哈理工暑假训练赛-F-奇怪的魔法" class="headerlink" title="4.哈理工暑假训练赛 - F - 奇怪的魔法"></a>4.哈理工暑假训练赛 - F - 奇怪的魔法</h2><h3 id="题目标签-3"><a href="#题目标签-3" class="headerlink" title="题目标签"></a>题目标签</h3><p>数论；求组合数</p><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><p>创造长度为n的单调非递减数组，<strong>每个数组需要消耗的魔力为数组的最大值</strong>，数组的最大值不超过K</p><p>求所有不同数组的魔力值之和，对答案1e9+7取模</p><h3 id="题目解析-3"><a href="#题目解析-3" class="headerlink" title="题目解析"></a>题目解析</h3><p>很可惜的一道题，因为不了解详细的原理，逆元和阶乘数组设太小了，最终没有AC</p><p>拿到题先用BFS跑了一遍，并打印每轮每个数作为最大数出现在数组中的次数，并很快找到了规律，</p><p><img src="https://gitee.com/wzy2002/pic-bed/raw/master/img/image-20220807201853000.png" alt="image-20220807201853000" style="zoom:50%;" /></p><p>可以发现这是一个组合数的表，$c[i][j]=c[i-1][j]+c[i][j-1]$</p><p>并且最终答案的状态转移方程为$dp[i]=dp[i-1]+c[i][j]*i$</p><p>每次转移取模即可</p><p>但是问题出现在了复杂度上，如果打二维表空间不够，并且会超时</p><p>仔细观察，又可以发现$c[i][j]=C_{i+j-1}^{i}$</p><p>那么放弃递推打表，只需要找到一种快速求出组合数的方法即可</p><p>于是我们可以通过预处理逆元和阶乘的方式，求出组合数</p><h3 id="通过代码-3"><a href="#通过代码-3" class="headerlink" title="通过代码"></a>通过代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> ll N = <span class="number">3e6</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> ll MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">ll fac[N], ifac[N];</span><br><span class="line">ll dp[<span class="number">1000010</span>];</span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll a, ll b, ll MOD)</span> </span>&#123;</span><br><span class="line">    ll res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (b) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>)</span><br><span class="line">            res = <span class="number">1ll</span> * res * a % MOD;</span><br><span class="line">        a = <span class="number">1ll</span> * a * a % MOD;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(ll n)</span> </span>&#123;</span><br><span class="line">fac[<span class="number">0</span>] = ifac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">fac[i] = <span class="number">1ll</span> * fac[i - <span class="number">1</span>] * i % MOD;</span><br><span class="line">ifac[i] = <span class="number">1ll</span> * ifac[i - <span class="number">1</span>] * <span class="built_in">qpow</span>(i, MOD - <span class="number">2</span>, MOD) % MOD;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">C</span><span class="params">(ll a,ll b)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(a&lt;<span class="number">0</span> || b&lt;<span class="number">0</span> || a&lt;b) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> (<span class="number">1ll</span> * fac[a] * ifac[b] % MOD * ifac[a - b] % MOD);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll row,col;</span><br><span class="line">    cin&gt;&gt;col&gt;&gt;row;</span><br><span class="line">    ll j=col;</span><br><span class="line"><span class="built_in">init</span>(N);</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">0</span>; i &lt;= row ; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ll num=<span class="built_in">C</span>(i+j<span class="number">-1</span>,i);</span><br><span class="line">dp[i]=(dp[i<span class="number">-1</span>]%MOD+(num*i)%MOD)%MOD;</span><br><span class="line">    &#125;</span><br><span class="line">cout&lt;&lt;dp[row];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-哈理工暑假训练赛-A-寂寞如雪"><a href="#5-哈理工暑假训练赛-A-寂寞如雪" class="headerlink" title="5.哈理工暑假训练赛 - A - 寂寞如雪"></a>5.哈理工暑假训练赛 - A - 寂寞如雪</h2><h3 id="题目标签-4"><a href="#题目标签-4" class="headerlink" title="题目标签"></a>题目标签</h3><p>DP；最大子序列和</p><h3 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一段0和1组成的串，每一段由连续n个1的组成的段，都代表一个数：</p><p>也就是$n^2$</p><p>比如111011001111100111代表的是3^2^,2^2^,5^2^,3^2^</p><p>你可以<strong>任意截取一段</strong>，并且求和。</p><p>但是题目规定，当某一段<strong>被截下来后</strong>是第奇数段，那他就是正的，偶数段就是负的</p><blockquote><p><strong>注意：</strong>截取不能把一段1截断，必须完整的截下来，比如11110011不能被截取为1100必须是111100或者0011</p></blockquote><ul><li>比如截取1110110011111，也就是截取前三个数，3^2^,2^2^,5^2^</li></ul><p>​        那么求和就是3^2^+（-2^2^）+5^2^</p><ul><li>比如截取11001111100111也就是截取后三个数，2^2^,5^2^,3^2^</li></ul><p>​        那么求和就是2^2^+（-5^2^）+3^2^</p><h3 id="题目解析-4"><a href="#题目解析-4" class="headerlink" title="题目解析"></a>题目解析</h3><p>由于题目规定，不能拦腰截断，必须截完整（后面广播给出的）</p><p>问题就变得非常简单了。（也就是为什么一开始没做，看到广播的提示才做的原因）</p><p>对于给出的字符串，可以直接将其压缩成一个数组</p><p><strong>比如：</strong></p><p>110011111001100111</p><p>其实可以压缩成数组[3^2^,2^2^,5^2^,3^2^]</p><p>由于不能拦腰截断1——不会改变压缩后的数组的大小，所以只要对压缩成的数组进行截取。使得这个区间求和最大就可以了</p><p>那么这题就转化成了对一个数组，求最大的连续子段和。刚好本周的训练里就有这道题</p><p><strong>而问题难就难在题目给出的限制</strong>：规定截取后的数，是第偶数个就得变成负数</p><p>看似每次截取后的正负都不同，都要判断，每次判断都会很麻烦</p><p>其实仔细推导会发现，不管怎么截取，每个数总共就只有两种状态</p><p>要么这个数的序号是奇数（正），下一个数是偶数（负），再下一个数是奇数（正）</p><p>要么这个数的序号是偶数（负），下一个数是偶数（正），再下一个数是奇数（负）</p><p><strong>即对：</strong></p><ul><li><p>[3^2^,-2^2^,5^2^,-3^2^]，进行任意截取求和，也就是求最大字段和</p></li><li><p>[-3^2^,2^2^,-5^2^,3^2^]，进行任意截取求和，也就是求最大字段和</p></li></ul><p>最后两个最大字段和，取最大的输出即可</p><h3 id="通过代码-4"><a href="#通过代码-4" class="headerlink" title="通过代码"></a>通过代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; vz,vf;</span><br><span class="line">    vz.<span class="built_in">push_back</span>(<span class="number">0</span>);<span class="comment">//占位，下标从1开始</span></span><br><span class="line">    vf.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> flag = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//输入并预处理</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">length</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">            cnt++;</span><br><span class="line">        <span class="keyword">if</span> (cnt &gt; <span class="number">0</span> &amp;&amp; s[i]==<span class="string">&#x27;0&#x27;</span> || i==s.<span class="built_in">length</span>()<span class="number">-1</span> &amp;&amp; s[i]==<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            vz.<span class="built_in">push_back</span>(cnt * cnt * -flag);<span class="comment">//负正负正负正</span></span><br><span class="line">            vf.<span class="built_in">push_back</span>(cnt * cnt * flag);<span class="comment">//正负正负正负</span></span><br><span class="line">            flag = -flag;</span><br><span class="line">            cnt = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//两个数组分别求最大子段和</span></span><br><span class="line">    <span class="type">int</span> maxn=vz[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= vz.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (vz[i - <span class="number">1</span>] &gt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            vz[i] = vz[i - <span class="number">1</span>] + vz[i];</span><br><span class="line">            <span class="comment">//如果是负数，就说明前一个数对和没有贡献，不算进去，重新从i开始求子段和找最大值。初始化vi[i]=0，不需要清零操作</span></span><br><span class="line">        &#125;</span><br><span class="line">        maxn=<span class="built_in">max</span>(vz[i],maxn);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= vf.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (vf[i - <span class="number">1</span>] &gt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            vf[i] = vf[i - <span class="number">1</span>] + vf[i];</span><br><span class="line">        &#125;</span><br><span class="line">        maxn=<span class="built_in">max</span>(vf[i],maxn);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//输出</span></span><br><span class="line">    cout&lt;&lt;maxn;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-MaxSum"><a href="#6-MaxSum" class="headerlink" title="6.MaxSum"></a>6.MaxSum</h2><h3 id="题目标签-5"><a href="#题目标签-5" class="headerlink" title="题目标签"></a>题目标签</h3><p>DP</p><h3 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h3><p>求最大字段和，并输出子段的下标</p><h3 id="题目解析-5"><a href="#题目解析-5" class="headerlink" title="题目解析"></a>题目解析</h3><p>从第一个数开始动态规划</p><p>dp[i]代表了从当前起始点到i的所有数之和</p><p>起始点会随着dp[i]进行动态更新</p><p>那么动态更新的依据是什么呢？</p><p>即：状态转移的过程中，dp[i]每次都加上他的前一个数dp[i-1]</p><p>但是如果dp[i-1]&lt;0。说明dp[i-1]这个数在转移之前是一个很大的负数</p><p>dp[i-1]+dp[i-2]的时候他一加上去，把之前加在一起的全都变成负数了</p><p>说明这个数对求最大的和起不了贡献。</p><p>这个数就放弃加上去，那么前一个起点开始求的子段和就到此为止了</p><p>再加就不礼貌了</p><p>然后开一个新的起点，从新的起点开始加，求连续的最大字段和。</p><p>每次转移的时候更新max，这样再求了所有的子段和之后，就能找到最大的字段和。</p><h3 id="通过代码-5"><a href="#通过代码-5" class="headerlink" title="通过代码"></a>通过代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 100000 + 5</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll dp[N] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    ll t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    ll cnt = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (t--)<span class="comment">//duo&#x27;zu&#x27;shu</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (cnt != <span class="number">1</span>)</span><br><span class="line">            cout &lt;&lt; endl;</span><br><span class="line">        ll n;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        <span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; dp[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ll maxn = <span class="number">-9999999</span>;</span><br><span class="line">        ll st = <span class="number">1</span>, ed = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> tempst=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (dp[i - <span class="number">1</span>] &gt;= <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i] = dp[i - <span class="number">1</span>] + dp[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                tempst = i;<span class="comment">//一旦小于0,然后另起一个新的下去。新的dp从当前i开始,st记录为i</span></span><br><span class="line">            &#125;                 </span><br><span class="line">            <span class="keyword">if</span> (dp[i] &gt; maxn) <span class="comment">//每次都判断，并更新最大值</span></span><br><span class="line">            &#123;</span><br><span class="line">                maxn = dp[i];</span><br><span class="line">                st=tempst;</span><br><span class="line">                ed = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//输出</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Case &quot;</span> &lt;&lt; cnt++ &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; endl</span><br><span class="line">             &lt;&lt; maxn &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; st &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; ed &lt;&lt; endl;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法周记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>22暑期ACM集训周记03</title>
      <link href="/2022/07/31/ACM%E5%91%A8%E8%AE%B0/%E6%9A%91%E6%9C%9FACM%E5%91%A8%E8%AE%B03/"/>
      <url>/2022/07/31/ACM%E5%91%A8%E8%AE%B0/%E6%9A%91%E6%9C%9FACM%E5%91%A8%E8%AE%B03/</url>
      
        <content type="html"><![CDATA[<h1 id="一、第三周学习总结表"><a href="#一、第三周学习总结表" class="headerlink" title="一、第三周学习总结表"></a>一、第三周学习总结表</h1><ul><li><h3 id="本周学习完成情况"><a href="#本周学习完成情况" class="headerlink" title="本周学习完成情况"></a>本周学习完成情况</h3><table border="1"><tr><th>Contest</th><th>完成情况</th></tr><tr><td>DFS练习</td><td>9/12</td></tr><tr><td>BFS练习 </td><td>9/12</td></tr><tr><td>贪心算法练习</td><td>16/21 </td></tr><tr><td>分治算法练习</td><td>16/16</td></tr><tr>  <td>二进制枚举算法练习</td>  <td>8/8</td></tr><tr>  <td>牛客喜迎暑假多校联赛第二场</td>  <td>6/9</td></tr><tr>  <td>Atcoder</td>  <td>3/8</td></tr><tr>  <td><b>总计</b></td>  <td><b>67/82</b></td></td></tr></table></li><li><h3 id="个人感悟"><a href="#个人感悟" class="headerlink" title="个人感悟"></a>个人感悟</h3><p>​        本周是暑期集训的第三周，学习了搜索，分治，贪心等基础的算法。学了这些算法之后，我明显的感受到了思考问题时有了更多的方向。但难就难在，很多题目往往并不是单考察这其中的某一种算法，而是很多算法和数据结构之间的交叉。本周学习的知识越来越难，能明显的感受到，每天的题目有时候并不能完全做完，只能做掉一部分，当天结束后，也没有把所有题目补完。而一种算法仅仅做了几道是十几道题目，我认为是完全不够的。所以对于算法还有待做更多的训练去熟练，对不同算法之间的交叉，有待去总结规律，去总结注意的细节。另外在做题目时，不能因为看到标题为xx算法练习赛，就只往一个xx算法一个方向去思考，毕竟比赛的时候没有人会提醒你这用的是什么算法。<br>​<br>在本周的训练里，我发现了在学习之中可以发散开去学习。比如在贪心算法的食堂买饭问题里，我了解到了动态规划算法，那题需要先用贪心想到解决方法，再转换为背包问题，计算剩下的问题。这道问题引起了我的好奇也补充了我对背包问题的初步认识。而背包问题仅仅只是动态规划算法的其中一部分，整个动态规划又包含了像区间DP，状态压缩DP等高级算法，有待未来的日子里加强对这些算法的训练</p></li></ul><h1 id="二、本周学习新内容"><a href="#二、本周学习新内容" class="headerlink" title="二、本周学习新内容"></a>二、本周学习新内容</h1><h3 id="1-bitset"><a href="#1-bitset" class="headerlink" title="1.bitset"></a>1.bitset</h3><p>一个容器可以直接操作一个数的二进制形式</p><p><code>bitset&lt;n&gt; s</code> n位二进制数</p><p><strong>基本操作：</strong></p><ul><li><p><code>~</code>每一位取反</p></li><li><p><code>&amp;</code> <code>|</code> <code>^</code>两个相同位数的进行按位运算</p></li><li><p><code>&lt;&lt;</code> <code>&gt;&gt;</code>返回一个bitset左/右移若干位的结果</p></li></ul><p><strong>容器方法：</strong></p><ul><li><code>s.count()</code>返回1的个数</li><li><code>s.any()</code>所有位都为0 返回false. 有一位是1 返回true</li><li><code>s.none()</code>所有位都为0 返回true. 有一位是1 返回false</li><li><code>s.set()</code>所有位都变1    <code>s.reset()</code>所有位都变为0</li><li><code>s[n]=1/0</code>直接操作第几位</li></ul><h3 id="2-scanf"><a href="#2-scanf" class="headerlink" title="2.scanf"></a>2.scanf</h3><p>​    scanf(“%1d”,&amp;a);控制输入数字的位数</p><h3 id="3-c-的数学函数"><a href="#3-c-的数学函数" class="headerlink" title="3.c++的数学函数"></a>3.c++的数学函数</h3><p>​    $e^x$即<code>exp(x)</code></p><p>​    $ln(x)$即<code>log(x)</code></p><p>​    $lg(x)$即<code>log10(x)</code></p><p>​    $log_ab$需要用到换底公式</p><p>​    如$log_28$即<code>log(8)/log(2)</code></p><p>​    $a^b$可以转换为$e^{blna}$，也就是<code>exp(b*log(a))</code></p><h3 id="4-setw-n"><a href="#4-setw-n" class="headerlink" title="4.setw(n)"></a>4.setw(n)</h3><p>​    右对齐</p><h3 id="5-基姆拉尔森计算公式"><a href="#5-基姆拉尔森计算公式" class="headerlink" title="5.基姆拉尔森计算公式"></a>5.基姆拉尔森计算公式</h3><script type="math/tex; mode=display">W= (d+2*m+3*(m+1)/5+y+y/4-y/100+y/400+1)MOD7</script><h3 id="6-二进制枚举"><a href="#6-二进制枚举" class="headerlink" title="6.二进制枚举"></a>6.二进制枚举</h3><p>即运用二进制的特殊性质，每一个数都可以转换成01所组成的数</p><p>而0和1可以作为判断的条件</p><p>那么对于有n个数的集合，共有2^n^个子集</p><p>事实上每个子集都是对于该集合的第i个元素选择或者不选产生的结果</p><p>那么面对集合的子集的问题是，往往可以用二进制枚举的方法</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_subset</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt; (<span class="number">1</span>&lt;&lt;n); i++) &#123;</span><br><span class="line">   <span class="comment">//i：0~2^n，每个i的二进制数对应一个子集。</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)<span class="comment">//打印一个子集，即打印i的二进制数中所有的1的位数</span></span><br><span class="line">           <span class="keyword">if</span>(i &amp; (<span class="number">1</span>&lt;&lt;j))<span class="comment">//1&lt;&lt;j，意思是，1向左移动j位，移动以后再和i做&amp;运算，如果i的第j位为1，就会判定成真</span></span><br><span class="line">               cout&lt;&lt; j &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">       cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;           <span class="comment">// n：集合中元素的总数量。</span></span><br><span class="line">    <span class="built_in">print_subset</span>(n);  <span class="comment">// 打印所有的子集。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="7-深搜与广搜"><a href="#7-深搜与广搜" class="headerlink" title="7.深搜与广搜"></a>7.深搜与广搜</h3><ul><li><h4 id="深搜的注意点："><a href="#深搜的注意点：" class="headerlink" title="深搜的注意点："></a>深搜的注意点：</h4></li></ul><ol><li><strong>注意是dfs函数的参数：</strong>如果把结果/新的状态带入dfs，进行下一步搜索，那么回溯时不需要进行撤销操作，因为下一步操作会自动的覆盖掉，而且每次都是用新的数组去搜索，不会对当前状态产生影响，但是使用原数组进行操作/进行标记的时候一定要记得回溯的时候，要撤销原来的标记</li><li><strong>变量的设置：</strong>通常将变量设置为全局变量，这样可以dfs的时候直接使用，但是如果遇到多组数据测试，一定要在每次测试之前将数据清零初始化。如max，cnt等等</li><li><strong>剪枝操作：</strong>剪枝是进行dfs的重要的考虑条件，通常题目不会那么直白，不剪枝则会超时。</li><li><strong>关于回溯：</strong>如果只需要一种条件，那么得到答案的时候，可以设置一个变量，判断是否已经得出结果。通常这个判断放在dfs的下面，也就是回溯的出口。以及判断是否到达终点的下面，避免到达终点后还继续下一步。</li></ol><ul><li><h4 id="广搜的注意点："><a href="#广搜的注意点：" class="headerlink" title="广搜的注意点："></a>广搜的注意点：</h4></li></ul><ol><li><strong>注意顺序：</strong>注意<code>压入队列操作</code>，<code>弹出队列</code>，<code>判断是否能压入队列操作</code>的顺序。如先把数压入队列，等到把他弹出来，判断是否可以扩展的时候，再进行判断，就会导致出现死循环。</li><li><strong>注意进行标记：</strong>不然会造成重复压入队列，造成死循环</li></ol><h3 id="8-快读"><a href="#8-快读" class="headerlink" title="8.快读"></a>8.快读</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">register</span> <span class="type">int</span> x = <span class="number">0</span>, t = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">register</span> <span class="type">char</span> ch=<span class="built_in">getchar</span>(); <span class="comment">// 读入单个字符到寄存器</span></span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">            t=<span class="number">-1</span>;</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>);  <span class="comment">// 移位与异或</span></span><br><span class="line">      <span class="comment">// 第十行可以换成 x = x * 10 + ch - &#x27;0&#x27;</span></span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x*t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-动态规划"><a href="#9-动态规划" class="headerlink" title="9.动态规划"></a>9.动态规划</h3><p>动态规划可以分为五个部分</p><ol><li><p>确定dp数组（dp table）以及下标的含义</p></li><li><p>确定递推公式，找出最优子结构</p></li><li><p>dp数组如何初始化</p></li><li><p>确定遍历顺序</p></li><li><p>举例推导dp数组</p></li></ol><p>01背包问题</p><p>每个物品只有选与不选</p><p>那么对于dp[n个物品][容量]=max(dp[n-1个物品][容量],dp[n-1个物品][容量]+weight[j])</p><p>多重背包就是再用一个k数组，枚举物品的数量即可</p><h1 id="三、题解一览"><a href="#三、题解一览" class="headerlink" title="三、题解一览"></a>三、题解一览</h1><h2 id="1-DFS-C-Network-Saboteur"><a href="#1-DFS-C-Network-Saboteur" class="headerlink" title="1.DFS - C - Network Saboteur"></a>1.DFS - C - Network Saboteur</h2><h3 id="题目标签"><a href="#题目标签" class="headerlink" title="题目标签"></a>题目标签</h3><p>DFS</p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一堆不同的点，以及每个点之间的距离</p><p>给定两个集合，集合中容纳的点的数量无限</p><p>只有当两个点处于不同的集合之中时，才有距离</p><p>现在请你求出所有的距离的最大值</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><p>点的最大数量为20，每个点存在的集合要么A，要么B，只有两种选择</p><p>如果枚举所有的情况，运算的最大次数为2^20^没有超过时间范围。</p><p>所以这题可以直接使用dfs暴力搜索</p><p>可以先初始化，假定所有的点都在集合A之中</p><p>定义一个bool类型，储存了每个点是否在A中。每层搜索都有两种结果。</p><p>分别对和进行计算，求出最大的和即可</p><h3 id="通过代码"><a href="#通过代码" class="headerlink" title="通过代码"></a>通过代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits.stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxnum 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 1000000007</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//先把所有都放进A集合，然后再遍历每个点，每个点都有两种选择，留在A，放进B</span></span><br><span class="line"><span class="comment">//每个点的选择，都求一次和，然后取最大值</span></span><br><span class="line"><span class="type">int</span> dis[<span class="number">21</span>][<span class="number">21</span>];<span class="comment">//每个两个点之间的距离</span></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> maxdis=<span class="number">-1</span>;</span><br><span class="line"><span class="type">bool</span> isInA[<span class="number">21</span>];<span class="comment">//代表每个点是否在A里面</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> cur,<span class="type">int</span> sum)</span></span>&#123;</span><br><span class="line">    maxdis=<span class="built_in">max</span>(maxdis,sum);</span><br><span class="line">    <span class="keyword">if</span> (cur==n+<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//第cur个点离开A,进入B</span></span><br><span class="line">    isInA[cur]=<span class="literal">false</span>;</span><br><span class="line">    <span class="type">int</span> temp=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (isInA[i])</span><br><span class="line">        &#123;</span><br><span class="line">            temp+=dis[i][cur];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            temp-=dis[i][cur];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(cur+<span class="number">1</span>,sum+temp);</span><br><span class="line">    isInA[cur]=<span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(cur+<span class="number">1</span>,sum);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="comment">//初始化，所有点每个点都先假设在A里面</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        isInA[i]=<span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            cin&gt;&gt;dis[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    cout&lt;&lt;maxdis;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-DFS-D-Shredding-Company"><a href="#2-DFS-D-Shredding-Company" class="headerlink" title="2.DFS - D - Shredding Company"></a>2.DFS - D - Shredding Company</h2><h3 id="题目标签-1"><a href="#题目标签-1" class="headerlink" title="题目标签"></a>题目标签</h3><p>dfs</p><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>公司发明了一种碎纸机，对一个数字，可以进行不限次数的裁剪</p><p>如123454 可以裁剪为1 23 45 4</p><p>对裁剪后的数进行求和，求和不超过给定的目标值的最大值时多少</p><h3 id="题目解析-1"><a href="#题目解析-1" class="headerlink" title="题目解析"></a>题目解析</h3><p>对每个间隔有剪和不剪两种选择，分别进行dfs</p><p>并把切下来的数先存到一个数组里面</p><p>切下来的数，就变为0，以便下次不会重复切取</p><p>到数字是最后一个的时候，计算和，并保留最大值</p><p><strong>剪枝：</strong>已有数组已经有数大于目标值</p><p><strong>注意：</strong>最后一位，不能不切。结尾要输出正确的切法。那么每次有最大值的时候，就用anscopy数组把储存的裁切数组拷贝一下</p><h3 id="通过代码-1"><a href="#通过代码-1" class="headerlink" title="通过代码"></a>通过代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> target;</span><br><span class="line">string s;</span><br><span class="line"><span class="comment">//判断条件：必须小于等于</span></span><br><span class="line"><span class="comment">//对字符串进行分割，每一个间隔选择切or不切进行dfs.</span></span><br><span class="line"><span class="comment">//切的话，加上sum，然后传递剩下的字符串</span></span><br><span class="line"><span class="comment">//求和判断</span></span><br><span class="line"><span class="comment">//剪枝：已有数组已经有数大于目标值</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">chage</span><span class="params">(string s)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">length</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum=sum*<span class="number">10</span>+(s[i]-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cut</span><span class="params">(string &amp;s,<span class="type">int</span> cur)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= cur; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        s[i]=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> maxans=<span class="number">-1</span>;</span><br><span class="line"><span class="type">int</span> ansnum=<span class="number">0</span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; anscopy;<span class="comment">//储存结果，dfs回溯之后ans不会保留</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> cur,string now,<span class="type">int</span> sum,<span class="type">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(sum&gt;target) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(cur==len+<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (maxans&lt;sum)</span><br><span class="line">        &#123;   </span><br><span class="line">            maxans=sum;</span><br><span class="line">            ansnum=<span class="number">1</span>;</span><br><span class="line">            anscopy=ans;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(maxans==sum)&#123;</span><br><span class="line">            ansnum++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//切</span></span><br><span class="line">    string temp=now.<span class="built_in">substr</span>(<span class="number">1</span>,cur);<span class="comment">//取切掉的</span></span><br><span class="line">    <span class="type">int</span> tempnum=<span class="built_in">chage</span>(temp);<span class="comment">//取切下来的</span></span><br><span class="line">    ans.<span class="built_in">push_back</span>(tempnum);</span><br><span class="line">    string newnow=now;</span><br><span class="line">    <span class="built_in">cut</span>(newnow,cur);<span class="comment">//把切了的变0，下次切就不会取数</span></span><br><span class="line">    <span class="type">int</span> newsum=sum+tempnum;</span><br><span class="line">    <span class="built_in">dfs</span>(cur+<span class="number">1</span>,newnow,newsum,len);</span><br><span class="line">    <span class="comment">//不切</span></span><br><span class="line">    ans.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="keyword">if</span>(cur&lt;len)&#123;<span class="comment">//最后一位不能不切了</span></span><br><span class="line">        <span class="built_in">dfs</span>(cur+<span class="number">1</span>,now,sum,len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (cin&gt;&gt;target&gt;&gt;s &amp;&amp; target!=<span class="number">0</span> &amp;&amp; s!=<span class="string">&quot;0&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        anscopy.<span class="built_in">clear</span>();</span><br><span class="line">        ans.<span class="built_in">clear</span>();</span><br><span class="line">        maxans=<span class="number">-1</span>;</span><br><span class="line">        ansnum=<span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (t++!=<span class="number">0</span>) cout&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">chage</span>(s)==target)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;s&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;target;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> len=s.<span class="built_in">length</span>();</span><br><span class="line">        s=<span class="string">&quot;0&quot;</span>+s;<span class="comment">//占位符，让下标从1开始</span></span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">1</span>,s,<span class="number">0</span>,len);</span><br><span class="line">        <span class="keyword">if</span> (ansnum==<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;maxans;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; anscopy.<span class="built_in">size</span>(); i++)</span><br><span class="line">            &#123;</span><br><span class="line">                cout&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">                cout&lt;&lt;anscopy[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ansnum&gt;<span class="number">1</span>)&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;rejected&quot;</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (ansnum==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;error&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-DFS-E-Sudoku"><a href="#3-DFS-E-Sudoku" class="headerlink" title="3.DFS - E - Sudoku"></a>3.DFS - E - Sudoku</h2><h3 id="题目标签-2"><a href="#题目标签-2" class="headerlink" title="题目标签"></a>题目标签</h3><p>DFS</p><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个9*9的数独</p><p>0代表空的</p><p>输出一种解</p><h3 id="题目解析-2"><a href="#题目解析-2" class="headerlink" title="题目解析"></a>题目解析</h3><p>dfs爆搜</p><p>用三个数组分别保存了第n行的k是否可填。第n列的k是否可填，第i，j个小方格是否可填</p><p>一个一个点的搜索，如果该点已经有数，那么就搜索下一个数。如果没有就枚举每个可以的数</p><p>当到达最后一个点的next点后，回溯。并再回溯的地方增加判断回溯的条件，达到快速回溯的目的</p><p><strong>注意：</strong></p><ol><li><p>回溯的时候，要把数字变回0</p></li><li><p>把该点的某个数变回可以填</p></li><li><p>判断小方格是否可以填写的是<code>isMatrixValid[(row+2)/3][(col+2)/3][value]=true;</code></p><p>这样可以把三个数归为一</p></li></ol><h3 id="通过代码-2"><a href="#通过代码-2" class="headerlink" title="通过代码"></a>通过代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> num[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="comment">//用数组标记该行的数哪些可以填，每次填数都进行一个check操作</span></span><br><span class="line"><span class="comment">//check不仅包括行和列，3*3的小格子是难点</span></span><br><span class="line"><span class="comment">//用num[10][10]来记录填了哪些数</span></span><br><span class="line"><span class="comment">//如果遇到填过了，就跳过，没填就依次挑选，依次check。可以填就填，然后dfs下一个点</span></span><br><span class="line"><span class="type">bool</span> isRowValid[<span class="number">10</span>][<span class="number">10</span>];<span class="comment">//记录行的某个数是否可以填</span></span><br><span class="line"><span class="type">bool</span> isColValid[<span class="number">10</span>][<span class="number">10</span>];<span class="comment">//记录列的某个数是否可以填</span></span><br><span class="line"><span class="type">bool</span> isMatrixValid[<span class="number">4</span>][<span class="number">4</span>][<span class="number">10</span>];<span class="comment">//记录第i,j个小方格能否填</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> row,<span class="type">int</span> col,<span class="type">int</span> value)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isRowValid[row][value]==<span class="literal">true</span> &amp;&amp; isColValid[col][value]==<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(isMatrixValid[(row+<span class="number">2</span>)/<span class="number">3</span>][(col+<span class="number">2</span>)/<span class="number">3</span>][value]==<span class="literal">true</span>)&#123;<span class="comment">//小方格</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">next</span><span class="params">(<span class="type">int</span> &amp;row,<span class="type">int</span> &amp;col)</span></span>&#123;<span class="comment">//下一个点</span></span><br><span class="line">    <span class="keyword">if</span> (col==<span class="number">9</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        row++;col=<span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        col++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> ok=<span class="literal">false</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> row,<span class="type">int</span> col)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (row==<span class="number">10</span>)<span class="comment">//完成</span></span><br><span class="line">    &#123;</span><br><span class="line">        ok=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (num[row][col]&gt;<span class="number">0</span>)<span class="comment">//填了</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> newrow=row,newcol=col;</span><br><span class="line">        <span class="built_in">next</span>(newrow,newcol);</span><br><span class="line">        <span class="built_in">dfs</span>(newrow,newcol);</span><br><span class="line">        <span class="keyword">if</span>(ok==<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> value = <span class="number">1</span>; value &lt;= <span class="number">9</span>; value++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">check</span>(row,col,value)==<span class="literal">true</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                num[row][col]=value;</span><br><span class="line">                isRowValid[row][value]=<span class="literal">false</span>;</span><br><span class="line">                isColValid[col][value]=<span class="literal">false</span>;</span><br><span class="line">                isMatrixValid[(row+<span class="number">2</span>)/<span class="number">3</span>][(col+<span class="number">2</span>)/<span class="number">3</span>][value]=<span class="literal">false</span>;</span><br><span class="line">                <span class="type">int</span> newrow=row,newcol=col;</span><br><span class="line">                <span class="built_in">next</span>(newrow,newcol);</span><br><span class="line">                <span class="built_in">dfs</span>(newrow,newcol);</span><br><span class="line">                <span class="keyword">if</span>(ok==<span class="literal">true</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                num[row][col]=<span class="number">0</span>;</span><br><span class="line">                isRowValid[row][value]=<span class="literal">true</span>;</span><br><span class="line">                isColValid[col][value]=<span class="literal">true</span>;</span><br><span class="line">                isMatrixValid[(row+<span class="number">2</span>)/<span class="number">3</span>][(col+<span class="number">2</span>)/<span class="number">3</span>][value]=<span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ok == <span class="literal">false</span>)&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="type">char</span> c=<span class="built_in">getchar</span>();<span class="comment">//读换行</span></span><br><span class="line">    <span class="keyword">while</span> (n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">9</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> value=<span class="number">1</span>;value&lt;=<span class="number">9</span>;value++)&#123;</span><br><span class="line">                isRowValid[i][value]=<span class="literal">true</span>;</span><br><span class="line">                isColValid[i][value]=<span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">3</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">3</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> value=<span class="number">1</span>;value&lt;=<span class="number">9</span>;value++)&#123;</span><br><span class="line">                    isMatrixValid[i][j][value]=<span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ok=<span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//输入</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">9</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">9</span>; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">char</span> temp=<span class="built_in">getchar</span>();</span><br><span class="line">                <span class="type">int</span> value=(temp-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">                num[i][j]=value;</span><br><span class="line">                isRowValid[i][value]=<span class="literal">false</span>;</span><br><span class="line">                isColValid[j][value]=<span class="literal">false</span>;</span><br><span class="line">                isMatrixValid[(i+<span class="number">2</span>)/<span class="number">3</span>][(j+<span class="number">2</span>)/<span class="number">3</span>][value]=<span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">getchar</span>();<span class="comment">//读换行</span></span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//输出</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">9</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">9</span>; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                cout&lt;&lt;num[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">            cout&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-Set-Operation"><a href="#4-Set-Operation" class="headerlink" title="4.Set Operation"></a>4.Set Operation</h2><h3 id="题目标签-3"><a href="#题目标签-3" class="headerlink" title="题目标签"></a>题目标签</h3><p>bitset的使用</p><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定n个集合</p><p>每个集合中有c个数</p><p>接下来给定q个询问</p><p>每个询问包含两个数，对于所有的n个集合，判定是否两数在一个集合中</p><h3 id="题目解析-3"><a href="#题目解析-3" class="headerlink" title="题目解析"></a>题目解析</h3><p>对于每一个数，记录他存在的所有集合</p><p>对于查询的数a,b只要查询他们所存在过的集合有没有交集即可</p><p>如果每个数存在的集合用map+vector来储存，求交集必然会超时</p><p>所以这时候bitset就是一个很好的选择</p><p>可以用一个数来作为标记，很好的进行了状态压缩</p><p>比如7——1101也就是代表在第1，3，4个集合中出现过</p><p>而bitset支持单个位数的修改，还能保证占用的空间小</p><p>同时求交集只需要将两个数的bitset 进行按位与操作&amp;。</p><p>某一位都为1才会保留，也就是都存在过一个集合里就会保留</p><p>然后统计他们与的结果里的1个个数是否&gt;0即可</p><p>使用bitset自带的count()方法</p><h3 id="通过代码-3"><a href="#通过代码-3" class="headerlink" title="通过代码"></a>通过代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits.stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(false),cin.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxnum 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 1000000007</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//st[i][j]表示i存在的集合</span></span><br><span class="line"><span class="comment">//[j]为桶</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll t;<span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;t);</span><br><span class="line">    bitset&lt;1000&gt; mp[<span class="number">10005</span>];</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">0</span>; i &lt; t; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ll num;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;num);</span><br><span class="line">        <span class="keyword">for</span> (ll j = <span class="number">0</span>; j &lt; num; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            ll temp;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;temp);</span><br><span class="line">            mp[temp][i]=<span class="number">1</span>;<span class="comment">//第temp个数的第i位变1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ll q;<span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;q);</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">0</span>; i &lt; q; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ll a,b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld %lld&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">        bitset&lt;1000&gt; t=mp[a]&amp;mp[b];</span><br><span class="line">        <span class="keyword">if</span>(t.<span class="built_in">count</span>()==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;No\n&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Yes\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-BFS-D-Prime-Path"><a href="#5-BFS-D-Prime-Path" class="headerlink" title="5.BFS - D - Prime Path"></a>5.BFS - D - Prime Path</h2><h3 id="题目标签-4"><a href="#题目标签-4" class="headerlink" title="题目标签"></a>题目标签</h3><p>bfs</p><h3 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个素数，和目标数</p><p>要求每次改一个位上的数</p><p>要求转换完的数也是素数</p><p>求最终转换成目标数需要的最少次数</p><h3 id="题目解析-4"><a href="#题目解析-4" class="headerlink" title="题目解析"></a>题目解析</h3><p>bfs广搜</p><p>先打素数表</p><p>每个数，变换每个位置的数</p><p>判断是否位素数</p><p>是的话加入，记录当前数经过变换的次数</p><p>对进入过队列的数要标记</p><h3 id="通过代码-4"><a href="#通过代码-4" class="headerlink" title="通过代码"></a>通过代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 1000000007</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="type">bool</span> isprime[maxn];</span><br><span class="line"><span class="type">int</span> prime[maxn];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Euler</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        isprime[i] = <span class="literal">true</span>; <span class="comment">// 2-n初始化</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (isprime[i])</span><br><span class="line">        &#123;</span><br><span class="line">            prime[t++] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; t &amp;&amp; i * prime[j] &lt;= n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//判断条件j不能超过现有质数的个数，且相乘即被筛的数不能越上界</span></span><br><span class="line">            isprime[prime[j] * i] = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % prime[j] == <span class="number">0</span>)</span><br><span class="line">            &#123; <span class="comment">//解析详见下文</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//打质数表</span></span><br><span class="line">    <span class="built_in">Euler</span>(<span class="number">10000</span>);</span><br><span class="line">    <span class="type">int</span> src, dst;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--)</span><br><span class="line">    &#123;</span><br><span class="line">        map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line">        map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; vis;</span><br><span class="line">        cin &gt;&gt; src &gt;&gt; dst;</span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(src);</span><br><span class="line">        mp[src] = <span class="number">0</span>;</span><br><span class="line">        vis[src]=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> curnum = q.<span class="built_in">front</span>();</span><br><span class="line">            <span class="keyword">if</span> (curnum == dst)</span><br><span class="line">            &#123;</span><br><span class="line">                cout &lt;&lt; mp[curnum] &lt;&lt; endl;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">9</span>; i += <span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> newnum = curnum / <span class="number">10</span> * <span class="number">10</span> + i;</span><br><span class="line">                <span class="keyword">if</span> (isprime[newnum] &amp;&amp; !vis[newnum])</span><br><span class="line">                &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(newnum);</span><br><span class="line">                    mp[newnum]=mp[curnum]+<span class="number">1</span>;</span><br><span class="line">                    vis[newnum] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">9</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> newnum = curnum / <span class="number">100</span> * <span class="number">100</span> + i * <span class="number">10</span> + curnum % <span class="number">10</span>;</span><br><span class="line">                <span class="keyword">if</span> (isprime[newnum] &amp;&amp; !vis[newnum])</span><br><span class="line">                &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(newnum);</span><br><span class="line">                    mp[newnum]=mp[curnum]+<span class="number">1</span>;</span><br><span class="line">                    vis[newnum] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">9</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> newnum = curnum / <span class="number">1000</span> * <span class="number">1000</span> + i * <span class="number">100</span> + curnum % <span class="number">100</span>;</span><br><span class="line">                <span class="keyword">if</span> (isprime[newnum] &amp;&amp; !vis[newnum])</span><br><span class="line">                &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(newnum);</span><br><span class="line">                    mp[newnum]=mp[curnum]+<span class="number">1</span>;</span><br><span class="line">                    vis[newnum] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">9</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> newnum = i * <span class="number">1000</span> + curnum % <span class="number">1000</span>;</span><br><span class="line">                <span class="keyword">if</span> (isprime[newnum] &amp;&amp; !vis[newnum])</span><br><span class="line">                &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(newnum);</span><br><span class="line">                    mp[newnum]=mp[curnum]+<span class="number">1</span>;</span><br><span class="line">                    vis[newnum] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-BFS-D-Prime-Path-1"><a href="#5-BFS-D-Prime-Path-1" class="headerlink" title="5.BFS - D - Prime Path"></a>5.BFS - D - Prime Path</h2><h3 id="题目标签-5"><a href="#题目标签-5" class="headerlink" title="题目标签"></a>题目标签</h3><p>bfs</p><h3 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你两杯水A.B</p><p>你可以进行三种操作</p><ol><li>把A，B中的一杯填满</li><li>把A，B中的一杯倒掉</li><li>把A倒入B/B倒入A</li></ol><p>给出三个数分别为</p><p>A的容量 B的容量 目标容量</p><p>求需要多少步，可以达到最终的容量。</p><p>并输出这些步骤</p><p>如果不可能则输出”impossible”</p><h3 id="题目解析-5"><a href="#题目解析-5" class="headerlink" title="题目解析"></a>题目解析</h3><p>BFS广搜即可</p><p>队列加入的是一个状态</p><p>用struct来定义</p><p>定义的struct包含</p><ul><li>A的水量</li><li>B的水量</li><li>经过的步骤</li></ul><p>注意点：</p><ol><li>要用vis数组，对已经产生过的AB的水量进行标记，避免重复进行，无法走出循环</li><li>经过的步骤可以用vector<int\> 来储存，最终输出的时候再转换</li></ol><h3 id="通过代码-5"><a href="#通过代码-5" class="headerlink" title="通过代码"></a>通过代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxnum 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 1000000007</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//储存的是一个自定义的结构体，即当前的状态</span></span><br><span class="line"><span class="comment">//此外还要储存一个字符串数组，记录的时当前状态已经做了哪些操作</span></span><br><span class="line"><span class="type">int</span> fulA,fulB,dst;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">state</span>&#123;</span><br><span class="line">    <span class="type">int</span> A;</span><br><span class="line">    <span class="type">int</span> B;</span><br><span class="line">    <span class="type">int</span> step;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; op;</span><br><span class="line">    <span class="built_in">state</span>(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> stp)&#123;</span><br><span class="line">        A=a;</span><br><span class="line">        B=b;</span><br><span class="line">        step=stp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">state</span>(<span class="type">void</span>)&#123;</span><br><span class="line">        A=<span class="number">0</span>;</span><br><span class="line">        B=<span class="number">0</span>;</span><br><span class="line">        step=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">string ans[<span class="number">7</span>]=&#123;<span class="string">&quot;&quot;</span>,<span class="string">&quot;FILL(1)&quot;</span>,<span class="string">&quot;FILL(2)&quot;</span>,<span class="string">&quot;DROP(1)&quot;</span>,<span class="string">&quot;DROP(2)&quot;</span>,<span class="string">&quot;POUR(1,2)&quot;</span>,<span class="string">&quot;POUR(2,1)&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; v)</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;v.<span class="built_in">size</span>()&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; v.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i!=<span class="number">0</span>) cout&lt;&lt;endl;</span><br><span class="line">        cout&lt;&lt;ans[v[i]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">bool</span> vis[<span class="number">1000</span>][<span class="number">1000</span>]=&#123;<span class="literal">false</span>&#125;;</span><br><span class="line">    cin&gt;&gt;fulA&gt;&gt;fulB&gt;&gt;dst;</span><br><span class="line">    queue&lt;state&gt; q;</span><br><span class="line">    <span class="function">state <span class="title">s</span><span class="params">(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">    vis[<span class="number">0</span>][<span class="number">0</span>]=<span class="literal">true</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(s);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        state curState = q.<span class="built_in">front</span>();</span><br><span class="line">        <span class="keyword">if</span> (curState.A==dst || curState.B==dst)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">print</span>(curState.op);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//三种选择2种方案</span></span><br><span class="line">        <span class="comment">//fill A</span></span><br><span class="line">        <span class="function">state <span class="title">newState1</span><span class="params">(fulA,curState.B,curState.step+<span class="number">1</span>)</span></span>;</span><br><span class="line">        newState1.op=curState.op;</span><br><span class="line">        newState1.op.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(vis[newState1.A][newState1.B]!=<span class="literal">true</span>)&#123;</span><br><span class="line">            q.<span class="built_in">push</span>(newState1);</span><br><span class="line">            vis[newState1.A][newState1.B]=<span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//fill B</span></span><br><span class="line">        <span class="function">state <span class="title">newState2</span><span class="params">(curState.A,fulB,curState.step+<span class="number">1</span>)</span></span>;</span><br><span class="line">        newState2.op=curState.op;</span><br><span class="line">        newState2.op.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span>(vis[newState2.A][newState2.B]!=<span class="literal">true</span>)&#123;</span><br><span class="line">            q.<span class="built_in">push</span>(newState2);</span><br><span class="line">            vis[newState2.A][newState2.B]=<span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//Drop A</span></span><br><span class="line">        <span class="function">state <span class="title">newState3</span><span class="params">(<span class="number">0</span>,curState.B,curState.step+<span class="number">1</span>)</span></span>;</span><br><span class="line">        newState3.op=curState.op;</span><br><span class="line">        newState3.op.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">if</span>(vis[newState3.A][newState3.B]!=<span class="literal">true</span>)&#123;</span><br><span class="line">            q.<span class="built_in">push</span>(newState3);</span><br><span class="line">            vis[newState3.A][newState3.B]=<span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//Drop B</span></span><br><span class="line">        <span class="function">state <span class="title">newState4</span><span class="params">(curState.A,<span class="number">0</span>,curState.step+<span class="number">1</span>)</span></span>;</span><br><span class="line">        newState4.op=curState.op;</span><br><span class="line">        newState4.op.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">        <span class="keyword">if</span>(vis[newState4.A][newState4.B]!=<span class="literal">true</span>)&#123;</span><br><span class="line">            q.<span class="built_in">push</span>(newState4);</span><br><span class="line">            vis[newState4.A][newState4.B]=<span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Pour A to B</span></span><br><span class="line">        <span class="comment">//A&gt;B 剩下的， B加满</span></span><br><span class="line">        <span class="type">int</span> newA,newB;</span><br><span class="line">        <span class="keyword">if</span> (curState.A&gt;=fulB-curState.B)</span><br><span class="line">        &#123;</span><br><span class="line">            newB=fulB;</span><br><span class="line">            newA=curState.A-(fulB-curState.B);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//A&lt;B 剩下的， B+A A=0</span></span><br><span class="line">        <span class="keyword">if</span> (curState.A&lt;fulB-curState.B)</span><br><span class="line">        &#123;</span><br><span class="line">            newA=<span class="number">0</span>;</span><br><span class="line">            newB=curState.B+curState.A;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">state <span class="title">newState5</span><span class="params">(newA,newB,curState.step+<span class="number">1</span>)</span></span>;</span><br><span class="line">        newState5.op=curState.op;</span><br><span class="line">        newState5.op.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">if</span>(vis[newState5.A][newState5.B]!=<span class="literal">true</span>)&#123;</span><br><span class="line">            q.<span class="built_in">push</span>(newState5);</span><br><span class="line">            vis[newState5.A][newState5.B]=<span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Pour B to A</span></span><br><span class="line">        <span class="comment">//A&gt;B 剩下的， B加满</span></span><br><span class="line">        <span class="keyword">if</span> (curState.B&gt;=fulA-curState.A)</span><br><span class="line">        &#123;</span><br><span class="line">            newA=fulA;</span><br><span class="line">            newB=curState.B-(fulA-curState.A);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//A&lt;B 剩下的， B+A A=0</span></span><br><span class="line">        <span class="keyword">if</span> (curState.B&lt;fulA-curState.A)</span><br><span class="line">        &#123;</span><br><span class="line">            newB=<span class="number">0</span>;</span><br><span class="line">            newA=curState.A+curState.B;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">state <span class="title">newState6</span><span class="params">(newA,newB,curState.step+<span class="number">1</span>)</span></span>;</span><br><span class="line">        newState6.op=curState.op;</span><br><span class="line">        newState6.op.<span class="built_in">push_back</span>(<span class="number">6</span>);</span><br><span class="line">        <span class="keyword">if</span>(vis[newState6.A][newState6.B]!=<span class="literal">true</span>)&#123;</span><br><span class="line">            q.<span class="built_in">push</span>(newState6);</span><br><span class="line">            vis[newState6.A][newState6.B]=<span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;impossible&quot;</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-贪心-D-Prime-Path"><a href="#5-贪心-D-Prime-Path" class="headerlink" title="5.贪心 - D - Prime Path"></a>5.贪心 - D - Prime Path</h2><h3 id="题目标签-6"><a href="#题目标签-6" class="headerlink" title="题目标签"></a>题目标签</h3><p>贪心</p><h3 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h3><p>有n档节目，每档节目有开始时间和结束时间</p><p>求最多能看完整的节目</p><h3 id="题目解析-6"><a href="#题目解析-6" class="headerlink" title="题目解析"></a>题目解析</h3><p>经典的区间调度问题</p><p>因为求的是最多，所以要把节目按照结束的时间来排序</p><p>遍历每一个节目，如果下一个节目的开始时间晚于上一个节目的结束时间</p><p>那么cnt++</p><p>将当前选择的节目更新</p><h3 id="通过代码-6"><a href="#通过代码-6" class="headerlink" title="通过代码"></a>通过代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxnum 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 1000000007</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="type">bool</span> flag=<span class="literal">false</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">act</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> start;</span><br><span class="line">    <span class="type">int</span> end;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(act a,act b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a.end!=b.end) <span class="keyword">return</span> a.end&lt;b.end;</span><br><span class="line">    <span class="keyword">return</span> a.start&lt;b.start;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ios::sync_with_stdio(false);</span></span><br><span class="line">    <span class="comment">// cin.tie(0);</span></span><br><span class="line">    <span class="comment">// freopen(&quot;3output.out&quot;,&quot;w&quot;,stdout);</span></span><br><span class="line">    <span class="comment">// freopen(&quot;1input.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">    <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">while</span> (cin&gt;&gt;n &amp;&amp; n!=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sum=<span class="number">0</span>;</span><br><span class="line">        act a[<span class="number">101</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            cin&gt;&gt;a[i].start&gt;&gt;a[i].end;    </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(a,a+n,cmp);</span><br><span class="line">        <span class="type">int</span> nowend=a[<span class="number">0</span>].end;</span><br><span class="line">        sum+=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i].start&gt;=nowend)<span class="comment">//下一个活动的时间，开始晚于上一个活动的结束时间</span></span><br><span class="line">            &#123;</span><br><span class="line">                sum++;</span><br><span class="line">                nowend=a[i].end;<span class="comment">//选下一个活动</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;sum&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// printf(&quot;Time used = %.2lf\n&quot;, (double)clock() / CLOCKS_PER_SEC);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-贪心-E-Doing-Homework-again"><a href="#6-贪心-E-Doing-Homework-again" class="headerlink" title="6.贪心 - E - Doing Homework again"></a>6.贪心 - E - Doing Homework again</h2><h3 id="题目标签-7"><a href="#题目标签-7" class="headerlink" title="题目标签"></a>题目标签</h3><p>贪心</p><h3 id="题目描述-7"><a href="#题目描述-7" class="headerlink" title="题目描述"></a>题目描述</h3><p>小明有n个作业，没有做完</p><p>每个作业有相应的分值和截止日期</p><p>规定如果某个作业没有在截止日期之前写完，就会扣除相应的分值</p><p>请你计算小明扣分最少为多少</p><h3 id="题目解析-7"><a href="#题目解析-7" class="headerlink" title="题目解析"></a>题目解析</h3><p>贪心+日程安排</p><p>将所有作业按照分值从大到小来做，尽量把这个作业做的时间靠近他的截止日期的时间</p><p>以便把前面的时间留出来做其他作业</p><p>分值相同的按照截止日期排名，靠前的排在前面</p><p>用一个vis数组来记录当天的日程有没有被安排</p><p>先按分值大的来计算，查看他的截止日期那天有没有安排</p><p>没有安排，那么就安排在那天。</p><p>有安排就往前排，实在没有那就不做</p><p>不用担心被扣分，因为如果没有安排的话，说明被安排的都是分值比他大的</p><p>所以扣分一定是最小的</p><h3 id="通过代码-7"><a href="#通过代码-7" class="headerlink" title="通过代码"></a>通过代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxnum 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 1000000007</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">bool</span> flag=<span class="literal">false</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">work</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> time;</span><br><span class="line">    <span class="type">int</span> score;</span><br><span class="line">    <span class="type">bool</span> vis=<span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(work a,work b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.score!=b.score)&#123;</span><br><span class="line">        <span class="keyword">return</span> a.score&gt;b.score;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a.time&lt;b.time;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//转化为日程安排问题</span></span><br><span class="line"><span class="comment">//总共n天，从大到小分值进行安排。</span></span><br><span class="line"><span class="comment">//第i个作业，如果原本是第timei天完成，那么就timei完成。如果那天被占，就从后往前安排</span></span><br><span class="line"><span class="comment">//反正是分大的，就算占用了同样本来是这天完成的作业，也没有关系</span></span><br><span class="line"><span class="comment">//vis来记录是否已经完成，最后统计所有没有完成的作业。然后逐个扣分</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ios::sync_with_stdio(false);</span></span><br><span class="line">    <span class="comment">// cin.tie(0);</span></span><br><span class="line">    <span class="comment">// freopen(&quot;3output.out&quot;,&quot;w&quot;,stdout);</span></span><br><span class="line"><span class="comment">//     freopen(&quot;1input.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">    <span class="type">int</span> t;cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span> (t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> day[<span class="number">1001</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="type">int</span> n;cin&gt;&gt;n;</span><br><span class="line">        work w[<span class="number">1001</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) cin&gt;&gt;w[i].time;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) cin&gt;&gt;w[i].score;</span><br><span class="line">        <span class="built_in">sort</span>(w,w+n,cmp);</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (day[w[i].time]==<span class="number">0</span>)<span class="comment">//没有安排</span></span><br><span class="line">            &#123;</span><br><span class="line">                day[w[i].time]=<span class="number">1</span>;</span><br><span class="line">                w[i].vis=<span class="literal">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">//从后往前</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = w[i].time<span class="number">-1</span>; j &gt;= <span class="number">1</span>; j--)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (day[j]==<span class="number">0</span>)<span class="comment">//从后往前的没有安排</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        day[j]=<span class="number">1</span>;</span><br><span class="line">                        w[i].vis=<span class="literal">true</span>;</span><br><span class="line">                        <span class="keyword">break</span>;<span class="comment">//找到了就及时推出，不然一直循环下去把所有日子都占了</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//没有找到空的，不安排，扣分</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (w[i].vis==<span class="literal">false</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                sum+=w[i].score;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;sum&lt;&lt;endl;   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-饭卡"><a href="#7-饭卡" class="headerlink" title="7.饭卡"></a>7.饭卡</h2><h3 id="题目标签-8"><a href="#题目标签-8" class="headerlink" title="题目标签"></a>题目标签</h3><p>贪心；背包dp</p><h3 id="题目描述-8"><a href="#题目描述-8" class="headerlink" title="题目描述"></a>题目描述</h3><p>有一张饭卡，当他大于等于五块钱的时候，购买一个东西不管钱够不够，一定能买成功</p><p>现在你的饭卡里有x元</p><p>共有n个菜</p><p>每道菜的价格为ai元</p><p>求饭卡最低能花到多少钱</p><h3 id="题目解析-8"><a href="#题目解析-8" class="headerlink" title="题目解析"></a>题目解析</h3><p>要让饭卡最低，肯定要最贵的菜在只有五块钱的时候买</p><p>那么接下来就转化成一个01背包的问题</p><p>只要让x-5元尽可能被花光即可</p><h3 id="通过代码-8"><a href="#通过代码-8" class="headerlink" title="通过代码"></a>通过代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span>&lt;bits/stdc</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(false),cin.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxnum 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 1000000007</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="comment">//排序出最贵的菜，等到用的只有五块的时候再用</span></span><br><span class="line"><span class="comment">//前n-1个菜就转化为01背包问题</span></span><br><span class="line"><span class="comment">//如果钱的总数已经大于菜的总数，那么直接输出，不用再计算</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">while</span> (cin&gt;&gt;n &amp;&amp; n!=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> value[<span class="number">2000</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            cin&gt;&gt;value[i];</span><br><span class="line">            sum+=value[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> cap;</span><br><span class="line">        cin&gt;&gt;cap;</span><br><span class="line">        <span class="keyword">if</span>(cap-sum&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            cout&lt;&lt;cap-sum&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cap&lt;<span class="number">5</span>)&#123;</span><br><span class="line">            cout&lt;&lt;cap&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(value,value+n);</span><br><span class="line">        <span class="comment">//dp前n-1个菜，每个菜的容量是value[i]，价值也是value[i]</span></span><br><span class="line">        <span class="type">int</span> dp[<span class="number">2000</span>]=&#123;<span class="number">0</span>&#125;;<span class="comment">//dp[j]：表示，用j块钱能花的最多的菜</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n<span class="number">-1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = cap<span class="number">-5</span>; j &gt;=value[i]; j--)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[j]=<span class="built_in">max</span>(dp[j],dp[j-value[i]]+value[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;cap-dp[cap<span class="number">-5</span>]-value[n<span class="number">-1</span>]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-贪心-H-Coins"><a href="#8-贪心-H-Coins" class="headerlink" title="8.贪心 - H - Coins"></a>8.贪心 - H - Coins</h2><h3 id="题目标签-9"><a href="#题目标签-9" class="headerlink" title="题目标签"></a>题目标签</h3><p>贪心</p><h3 id="题目描述-9"><a href="#题目描述-9" class="headerlink" title="题目描述"></a>题目描述</h3><p>现在有1，5，10，50，100元的纸币各若干张，需要用这些纸币去支付C元。<br>最多需要多少张纸币？最少需要多少张纸币？</p><h3 id="题目解析-9"><a href="#题目解析-9" class="headerlink" title="题目解析"></a>题目解析</h3><p>最少需要的纸币，从大到小选择即可</p><p>最多需要的纸币可以利用逆向思维，即求最少能剩下的纸币即可</p><h3 id="通过代码-9"><a href="#通过代码-9" class="headerlink" title="通过代码"></a>通过代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxnum 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 1000000007</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="type">bool</span> flag=<span class="literal">false</span>;</span><br><span class="line"><span class="comment">//没有输出-1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll T;cin&gt;&gt;T;</span><br><span class="line">    <span class="keyword">while</span> (T--)</span><br><span class="line">    &#123;</span><br><span class="line">        ll maxn=<span class="number">0</span>;ll minn=<span class="number">0</span>;</span><br><span class="line">        ll dst,y1,y5,y10,y50,y100;</span><br><span class="line">        cin&gt;&gt;dst&gt;&gt;y1&gt;&gt;y5&gt;&gt;y10&gt;&gt;y50&gt;&gt;y100;</span><br><span class="line">        ll all=y1+y5*<span class="number">5</span>+y10*<span class="number">10</span>+y50*<span class="number">50</span>+y100*<span class="number">100</span>;</span><br><span class="line">        ll redst=dst;</span><br><span class="line">        <span class="comment">//求最少从大到小贪心</span></span><br><span class="line">        <span class="keyword">if</span>(all&lt;dst)&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;-1 -1&quot;</span>&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">continue</span>;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(dst/<span class="number">100</span>&lt;=y100)&#123;</span><br><span class="line">            maxn+=dst/<span class="number">100</span>;</span><br><span class="line">            dst-=(dst/<span class="number">100</span>)*<span class="number">100</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            maxn+=y100;</span><br><span class="line">            dst-=y100*<span class="number">100</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(dst/<span class="number">50</span>&lt;=y50)&#123;</span><br><span class="line">            maxn+=dst/<span class="number">50</span>;</span><br><span class="line">            dst-=(dst/<span class="number">50</span>)*<span class="number">50</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            maxn+=y50;</span><br><span class="line">            dst-=y50*<span class="number">50</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(dst/<span class="number">10</span>&lt;=y10)&#123;</span><br><span class="line">            maxn+=dst/<span class="number">10</span>;</span><br><span class="line">            dst-=(dst/<span class="number">10</span>)*<span class="number">10</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            maxn+=y10;</span><br><span class="line">            dst-=y10*<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(dst/<span class="number">5</span>&lt;=y5)&#123;</span><br><span class="line">            maxn+=dst/<span class="number">5</span>;</span><br><span class="line">            dst-=(dst/<span class="number">5</span>)*<span class="number">5</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            maxn+=y5;</span><br><span class="line">            dst-=y5*<span class="number">5</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(dst/<span class="number">1</span>&lt;=y1)&#123;</span><br><span class="line">            maxn+=dst/<span class="number">1</span>;</span><br><span class="line">            dst-=(dst/<span class="number">1</span>)*<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            maxn+=y1;</span><br><span class="line">            dst-=y1*<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(dst==<span class="number">0</span>)&#123;</span><br><span class="line">            cout&lt;&lt;maxn&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;-1 &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dst=all-redst;</span><br><span class="line">        maxn=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//求最少从大到小贪心</span></span><br><span class="line">        <span class="keyword">if</span>(dst/<span class="number">100</span>&lt;=y100)&#123;</span><br><span class="line">            maxn+=dst/<span class="number">100</span>;</span><br><span class="line">            dst-=(dst/<span class="number">100</span>)*<span class="number">100</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            maxn+=y100;</span><br><span class="line">            dst-=y100*<span class="number">100</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(dst/<span class="number">50</span>&lt;=y50)&#123;</span><br><span class="line">            maxn+=dst/<span class="number">50</span>;</span><br><span class="line">            dst-=(dst/<span class="number">50</span>)*<span class="number">50</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            maxn+=y50;</span><br><span class="line">            dst-=y50*<span class="number">50</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(dst/<span class="number">10</span>&lt;=y10)&#123;</span><br><span class="line">            maxn+=dst/<span class="number">10</span>;</span><br><span class="line">            dst-=(dst/<span class="number">10</span>)*<span class="number">10</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            maxn+=y10;</span><br><span class="line">            dst-=y10*<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(dst/<span class="number">5</span>&lt;=y5)&#123;</span><br><span class="line">            maxn+=dst/<span class="number">5</span>;</span><br><span class="line">            dst-=(dst/<span class="number">5</span>)*<span class="number">5</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            maxn+=y5;</span><br><span class="line">            dst-=y5*<span class="number">5</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(dst/<span class="number">1</span>&lt;=y1)&#123;</span><br><span class="line">            maxn+=dst/<span class="number">1</span>;</span><br><span class="line">            dst-=(dst/<span class="number">1</span>)*<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            maxn+=y1;</span><br><span class="line">            dst-=y1*<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        minn=y1+y5+y10+y50+y100-maxn;</span><br><span class="line">        <span class="keyword">if</span>(dst==<span class="number">0</span>)&#123;</span><br><span class="line">            cout&lt;&lt;minn&lt;&lt;endl;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;-1 &quot;</span>&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="9-分治练习-A-Inversion"><a href="#9-分治练习-A-Inversion" class="headerlink" title="9.分治练习 - A - Inversion"></a>9.分治练习 - A - Inversion</h2><h3 id="题目标签-10"><a href="#题目标签-10" class="headerlink" title="题目标签"></a>题目标签</h3><p>分治</p><h3 id="题目描述-10"><a href="#题目描述-10" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个序列，和你可以进行的交换的次数</p><p>每次交换只能交换相邻的两位数字</p><p>求最少的逆序对</p><h3 id="题目解析-10"><a href="#题目解析-10" class="headerlink" title="题目解析"></a>题目解析</h3><p>每次交换只能交换相邻的，那么每次交换最多只能消除一个逆序对</p><p>所以只要先求总的逆序对，再减去交换的次数即可</p><p><strong>求总逆序对的方法：</strong>在归并排序的同时，如果遇到逆序的元素，那就ans++</p><p><strong>归并排序的方法：</strong></p><p>先不断的二分，直到分为两个数</p><p>然后把开一个新的数组</p><p>把左右两个序列中的数正确的排到新的序列里面</p><p>每次放进去的时候事先比较，在两个数的大小</p><p>如果左序列的数大于有序列，说明产生逆序</p><p>此时需要ans+=mid-i+1</p><p>即把有序列中的那个数后面的数也算进答案中</p><p>因为当前的序列一定是上一个序列中已经排好的，所以比当前左序列的数还要大的数，肯定也比有序列当前的数大</p><p>所以逆序对这个变量都要把他们记录</p><h3 id="通过代码-10"><a href="#通过代码-10" class="headerlink" title="通过代码"></a>通过代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">#includeM&lt;bits/stdc++.h&gt;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(false),cin.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxnum 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 1000000007</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">/**归并排序</span></span><br><span class="line"><span class="comment"> * 先拆分，拆到两数字相同了，开始比较，两个区间的，如果有逆序对，记录</span></span><br><span class="line"><span class="comment"> * 完事了要合并</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line">ll ans=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> n,num[<span class="number">5000001</span>], temp[<span class="number">5000001</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mergesort</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span><span class="comment">//归并排序</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> mid = (l + r) / <span class="number">2</span>;<span class="comment">//取中间 </span></span><br><span class="line"><span class="keyword">if</span>(l == r)<span class="comment">//若l == r了，就代表这个子序列就只剩1个元素了，需要返回 </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">mergesort</span>(l, mid);<span class="comment">//分成l和中间一段，中间 + 1和r一段（二分） </span></span><br><span class="line"><span class="built_in">mergesort</span>(mid + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> i = l;<span class="comment">//i从l开始，到mid，因为现在排序的是l ~ r的区间且要二分合并 </span></span><br><span class="line"><span class="type">int</span> j = mid + <span class="number">1</span>;<span class="comment">//j从mid + 1开始，到r原因同上</span></span><br><span class="line"><span class="type">int</span> t = l;<span class="comment">//数组b的下标，数组b存的是l ~ r区间排完序的值 </span></span><br><span class="line"><span class="keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= r)<span class="comment">//同上i，j的解释 </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(num[i] &gt; num[j])<span class="comment">//如果前面的元素比后面大(l ~ mid中的元素 &gt; mid + 1 ~ r中的元素</span></span><br><span class="line">&#123; </span><br><span class="line">ans += mid - i + <span class="number">1</span>;</span><br><span class="line">temp[t++] = num[j];</span><br><span class="line">++j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">temp[t++] = num[i];<span class="comment">//i小，存a[i] </span></span><br><span class="line">++i;<span class="comment">//同理 </span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(i &lt;= mid)<span class="comment">//把剩的元素(因为较大所以在上面没选) </span></span><br><span class="line">&#123;</span><br><span class="line">temp[t++] = num[i];<span class="comment">//存进去 </span></span><br><span class="line">++i; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(j &lt;= r)<span class="comment">//同理 </span></span><br><span class="line">&#123;</span><br><span class="line">temp[t++] = num[j];</span><br><span class="line">++j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">int</span> i = l; i &lt;= r; ++i)<span class="comment">//把有序序列b赋值到a里 </span></span><br><span class="line">&#123;</span><br><span class="line">num[i] = temp[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (cin&gt;&gt;n&gt;&gt;cnt)</span><br><span class="line">&#123;</span><br><span class="line">ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;num[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">mergesort</span>(<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">if</span>(ans-cnt&gt;<span class="number">0</span>)&#123;</span><br><span class="line">cout&lt;&lt;ans-cnt;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">cout&lt;&lt;<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="10-分治-F-Building-for-UN"><a href="#10-分治-F-Building-for-UN" class="headerlink" title="10.分治 - F - Building for UN"></a>10.分治 - F - Building for UN</h2><h3 id="题目标签-11"><a href="#题目标签-11" class="headerlink" title="题目标签"></a>题目标签</h3><p>思维</p><h3 id="题目描述-11"><a href="#题目描述-11" class="headerlink" title="题目描述"></a>题目描述</h3><p>有一个大厦，大厦中有n个国家</p><p>左右相邻上下相邻以及在同一位置上下楼也算相邻</p><p>求一种排布方式，使得每两个国家之间的办公室都有相邻</p><h3 id="题目解析-11"><a href="#题目解析-11" class="headerlink" title="题目解析"></a>题目解析</h3><p>只需要两层</p><p>第一层第i行全是国家ai</p><p>第二层第j列全是国家aj</p><p>即</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AAAA</span><br><span class="line">BBBB</span><br><span class="line">CCCC</span><br><span class="line">DDDD</span><br><span class="line"></span><br><span class="line">ABCD</span><br><span class="line">ABCD</span><br><span class="line">ABCD</span><br><span class="line">ABCD</span><br></pre></td></tr></table></figure><h3 id="通过代码-11"><a href="#通过代码-11" class="headerlink" title="通过代码"></a>通过代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(false), cin.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxnum 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 1000000007</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string ss=<span class="string">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz&quot;</span>;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="number">2</span> &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; n &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                cout&lt;&lt;ss[i];</span><br><span class="line">            &#125;</span><br><span class="line">            cout&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                cout&lt;&lt;ss[j];</span><br><span class="line">            &#125;</span><br><span class="line">            cout&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="11-分治-H-Wine-trading-in-Gergovia"><a href="#11-分治-H-Wine-trading-in-Gergovia" class="headerlink" title="11.分治 - H - Wine trading in Gergovia"></a>11.分治 - H - Wine trading in Gergovia</h2><h3 id="题目标签-12"><a href="#题目标签-12" class="headerlink" title="题目标签"></a>题目标签</h3><p>贪心</p><h3 id="题目描述-12"><a href="#题目描述-12" class="headerlink" title="题目描述"></a>题目描述</h3><p>有n个酒馆</p><p>每个酒馆可以卖酒也可以买酒</p><p>并且他们的需求和产出之和一定为0</p><p>但是运酒需要花费劳动力</p><p>劳动力为酒的数量</p><p>求出最少的劳动力，是所有的酒馆都能买到所有需求的酒和卖掉所有需求的酒</p><h3 id="题目解析-12"><a href="#题目解析-12" class="headerlink" title="题目解析"></a>题目解析</h3><p>其实是一道贪心问题、</p><p>不管每个酒馆是买酒还是卖酒，只要从第1个酒馆开始</p><p>把当前酒馆所有的能卖的都搬到下一个酒馆即可</p><h3 id="通过代码-12"><a href="#通过代码-12" class="headerlink" title="通过代码"></a>通过代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(false), cin.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxnum 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 1000000007</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//常量，就是pi</span></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>)</span><br><span class="line"><span class="type">int</span> <span class="built_in">main</span>()</span><br><span class="line">&#123;</span><br><span class="line">    ll n;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; n &amp;&amp; n!=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ll num[n];</span><br><span class="line">        <span class="keyword">for</span> (ll i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; num[i];</span><br><span class="line">        &#125;</span><br><span class="line">        ll ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (ll i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            ans += <span class="built_in">abs</span>(num[i]);</span><br><span class="line">            num[i + <span class="number">1</span>] += num[i];</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="12-牛客喜迎暑假多校联赛-D-N数之和"><a href="#12-牛客喜迎暑假多校联赛-D-N数之和" class="headerlink" title="12.牛客喜迎暑假多校联赛 - D - N数之和"></a>12.牛客喜迎暑假多校联赛 - D - N数之和</h2><h3 id="题目标签-13"><a href="#题目标签-13" class="headerlink" title="题目标签"></a>题目标签</h3><p>快读</p><h3 id="题目描述-13"><a href="#题目描述-13" class="headerlink" title="题目描述"></a>题目描述</h3><p>读入n个数，求和</p><h3 id="题目解析-13"><a href="#题目解析-13" class="headerlink" title="题目解析"></a>题目解析</h3><p>直接做会超时，必须用快读</p><p>快读要用getchar() 一个一个字符的读入并计算</p><h3 id="通过代码-13"><a href="#通过代码-13" class="headerlink" title="通过代码"></a>通过代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(false),cin.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxnum 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 1000000007</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n;<span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;n);</span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line">    ll sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">        ll temp=<span class="number">0</span>;</span><br><span class="line">        <span class="type">char</span> c;</span><br><span class="line">        <span class="keyword">while</span> ((c=<span class="built_in">getchar</span>())!=<span class="string">&#x27; &#x27;</span> &amp;&amp; c!=<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            temp=temp*<span class="number">10</span>+(c-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        sum+=temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,sum);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法周记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>22暑期ACM集训周记02</title>
      <link href="/2022/07/24/ACM%E5%91%A8%E8%AE%B0/%E6%9A%91%E6%9C%9FACM%E5%91%A8%E8%AE%B02/"/>
      <url>/2022/07/24/ACM%E5%91%A8%E8%AE%B0/%E6%9A%91%E6%9C%9FACM%E5%91%A8%E8%AE%B02/</url>
      
        <content type="html"><![CDATA[<h1 id="一、第二周学习总结表"><a href="#一、第二周学习总结表" class="headerlink" title="一、第二周学习总结表"></a>一、第二周学习总结表</h1><ul><li><h4 id="本周学习完成情况"><a href="#本周学习完成情况" class="headerlink" title="本周学习完成情况"></a>本周学习完成情况</h4><table border="1"><tr><th>Contest</th><th>完成情况</th></tr><tr><td>PTA函数与递归练习</td><td>12/13</td></tr><tr><td>函数与递归练习 </td><td>6/10</td></tr><tr><td>STL(vector,stack,queue)练习</td><td>6/6 </td></tr><tr><td>STL经典练习</td><td>12/12</td></tr><tr>  <td>回溯应用练习赛</td>  <td>5/5</td></tr><tr>  <td>其他练习</td>  <td>5/5</td></tr><tr>  <td>比赛补题</td>  <td>2/2</td></tr></table></li><li><h4 id="个人感悟"><a href="#个人感悟" class="headerlink" title="个人感悟"></a>个人感悟</h4></li></ul><p>​        本周为ACM集训的第二周，回顾了函数递归，学习了新的回溯算法。这一周里，几场练习赛下来，深刻感受到了学习新算法和数据结构的重要性。比如牛客的大部分题目，题面看起来并不算难，但是数据范围总是会让传统的办法无效，这时候新的算法和数据结构的重要性就体现的很重要。比如前一天的Atcoder，前三十分钟我便写完了前三题，而后一个小时因为知识点的受限，虽然后面的题能看出来大概方向但是依旧写不出实际的代码。比如D题能直接看出来是动态规划，但是没有系统的学习和大量的练习我最终也没有推出最优子结构。再比如C题，熟悉了map以后，我仅仅花了五分多钟就写了出来。如果没有接触到STL容器，可能要做很久。再比如周日的河南大学萌新赛的J题，自学了同余定理之后，我一下就有了思路，虽然最后没有优化好还是有部分超时，没有完整的把题目通过，但是对知识点有了深刻的理解，对解题思路有了更新的感悟。</p><p>​        所以接下来一周，我对自己的计划是完成日常练习题的基础上，学习更多新的知识点，和做题的技巧。不但要刷日常的练习还要刷不同平台的题目，感受出题的不同方向和考察知识点的角度。</p><h1 id="二、本周学习新内容"><a href="#二、本周学习新内容" class="headerlink" title="二、本周学习新内容"></a>二、本周学习新内容</h1><h3 id="1-四舍五入简便写法"><a href="#1-四舍五入简便写法" class="headerlink" title="1.四舍五入简便写法"></a>1.四舍五入简便写法</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">floor</span>(x+<span class="number">0.5</span>)</span><br></pre></td></tr></table></figure><h3 id="2-使用assert来调试程序"><a href="#2-使用assert来调试程序" class="headerlink" title="2.使用assert来调试程序"></a>2.使用assert来调试程序</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x=<span class="number">2</span>;</span><br><span class="line"><span class="built_in">assert</span>(x&gt;=<span class="number">3</span>);</span><br><span class="line">cout&lt;&lt;x&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*报错</span></span><br><span class="line"><span class="comment">Assertion failed!</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Program: E:\Code\VSCode\Test.exe</span></span><br><span class="line"><span class="comment">File: Test.cpp, Line 15\``</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Expression: x&gt;=3</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="3-auto-register"><a href="#3-auto-register" class="headerlink" title="3.auto register"></a>3.auto register</h3><p><code>auto</code>可以自动根据后面的表达式，来给变量赋予类型。</p><p><code>register</code>可以将常用的变量放到寄存器中，提高运行的效率。</p><h3 id="4-gcd"><a href="#4-gcd" class="headerlink" title="4._gcd"></a>4._gcd</h3><p>c++<algorithm\>自带的求最大公约数的函数，底层原理是欧几里得算法。</p><h3 id="5-深度优先搜索-DFS"><a href="#5-深度优先搜索-DFS" class="headerlink" title="5.深度优先搜索(DFS)"></a>5.深度优先搜索(DFS)</h3><ol><li><h4 id="核心"><a href="#核心" class="headerlink" title="核心"></a><strong>核心</strong></h4></li></ol><p>​        沿着树的深度<code>遍历解答树的结点</code>，尽可能的深的搜索。前进中遭遇失败，则<code>回溯到前进前的结点</code>，另寻别的同路继续搜索，<code>直到满足条件</code></p><ol><li><h4 id="思想"><a href="#思想" class="headerlink" title="思想"></a><strong>思想</strong></h4></li></ol><p>​        在寻找终点的过程中将<code>当前状态</code>压入栈，若遇到死路则栈顶出栈，直到某个状态可以继续发散</p><ol><li><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4></li></ol><p>​        注意时间复杂度满不满足使用DFS，容易爆栈</p><ol><li><h4 id="核心思想代码："><a href="#核心思想代码：" class="headerlink" title="核心思想代码："></a>核心思想代码：</h4></li></ol><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(当前状态)</span></span>&#123;</span><br><span class="line">如果到终点就返回;</span><br><span class="line">  标记当前状态已经访问过;</span><br><span class="line">  <span class="keyword">for</span> (当前状态能走的所有步)&#123;</span><br><span class="line">    新状态=当前状态转移之后的状态;</span><br><span class="line">    <span class="keyword">if</span>(新状态不符合要求)&#123;</span><br><span class="line">      <span class="keyword">continue</span>;<span class="comment">//直接跳过，寻找当前状态的下一种新状态</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(新状态没有访问过 &amp;&amp; 符合要求)&#123;</span><br><span class="line">      <span class="built_in">dfs</span>(新状态);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-998244353"><a href="#6-998244353" class="headerlink" title="6.998244353"></a>6.998244353</h3><p>一个神奇的数，常用被取模。</p><h3 id="7-同余定理"><a href="#7-同余定理" class="headerlink" title="7.同余定理"></a>7.同余定理</h3><ol><li><h4 id="同余定理即"><a href="#同余定理即" class="headerlink" title="同余定理即"></a>同余定理即</h4></li></ol><script type="math/tex; mode=display">若(a-b)\bmod m = 0 ，则a\bmod m = b\bmod m</script><ul><li>证明：</li></ul><script type="math/tex; mode=display">假设a\bmod m= b \bmod m\\可设a=m*k+d\\可设b=m*t+d\\则(a-b)\bmod m= (m*(k+t)+d-d)\bmod m=0</script><p>​        其实就是余数在相减的过程中被减去了</p><ol><li><h4 id="其他性质"><a href="#其他性质" class="headerlink" title="其他性质"></a>其他性质</h4><script type="math/tex; mode=display">(a+b) \bmod m=((a \bmod m)+(b \bmod m))\bmod m\\(a*b) \bmod m=((a \bmod m)*(b \bmod m))\bmod m</script><p>可以在题目中对大数取余的时候可以用到</p></li></ol><script type="math/tex; mode=display">a\bmod m =b \bmod m\\则a^n \bmod m= b^n \bmod m\\则a+c \bmod m= b+c \bmod m\\则a*c \bmod m= b*c \bmod m</script><p>​        两个数同余，那么他们的平方也同余，他们加上同样的数也同余</p><script type="math/tex; mode=display">a\mod b=0\\c\mod d=0\\a*b \bmod b*d =0</script><h2 id=""><a href="#" class="headerlink" title=" "></a> </h2><h3 id="8-容器的一些不熟悉的使用方法"><a href="#8-容器的一些不熟悉的使用方法" class="headerlink" title="8.容器的一些不熟悉的使用方法"></a>8.容器的一些不熟悉的使用方法</h3><ol><li><h4 id="priority-queue"><a href="#priority-queue" class="headerlink" title="priority_queue"></a><strong>priority_queue</strong></h4></li></ol><ul><li>每次push和pop都会动态调整容器内的序列</li><li><p>其实就是一个堆，默认为最大堆，从小到大排，所以<code>q.top()</code>为最大值,<code>q.pop()</code>就是把最大值移除</p></li><li><p>erase的返回值为删除元素后的迭代器下一个，所以删除完了有时候需要iter—</p></li><li><p>定义应该这样<code>priority_queue&lt;Type, [Container],Funtional&gt;</code></p><p>而如果使用了第三个参数，第二个参数也必须加上</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">priority_queue&lt;<span class="type">int</span>, greater&lt;&gt;&gt; pq;<span class="comment">//这是错误的</span></span><br><span class="line">priority_queue&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt; , greater&lt;&gt;&gt; pq;<span class="comment">//这是对的</span></span><br></pre></td></tr></table></figure></li></ul><ol><li><h4 id="set"><a href="#set" class="headerlink" title="set"></a>set</h4></li></ol><ul><li>访问速度是O(log~n~)</li><li>底层是二叉搜索树</li><li><code>erase(item)</code>把item元素删除</li><li><code>lower_bound(item)</code>：返回大于等于目标item的第一个值</li><li><code>lower_bound(item)</code>：返回大于目标item的第一个值</li></ul><ol><li><h4 id="transform"><a href="#transform" class="headerlink" title="transform"></a>transform</h4></li></ol><ul><li><p>transform(s.begin(),s.end(),s.begin(),::tolower);</p></li><li><p>字符串全部转换大小写</p></li></ul><ol><li><h4 id="pair"><a href="#pair" class="headerlink" title="pair"></a>pair</h4></li></ol><ul><li>一个二元组</li><li>用法<code>pair&lt;string,int&gt; p</code></li><li><code>p.first()</code>表示第一个元素，<code>p.second()</code>表示第二个元素</li></ul><h1 id="三、题解一览"><a href="#三、题解一览" class="headerlink" title="三、题解一览"></a>三、题解一览</h1><h2 id="1-河南理工大学萌新赛-B-宝石"><a href="#1-河南理工大学萌新赛-B-宝石" class="headerlink" title="1.河南理工大学萌新赛 - B - 宝石"></a>1.河南理工大学萌新赛 - B - 宝石</h2><p><a href="https://ac.nowcoder.com/acm/contest/37344/B">题目链接</a></p><h3 id="题目标签"><a href="#题目标签" class="headerlink" title="题目标签"></a>题目标签</h3><p>打表；哈希</p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>小Y得到了一堆宝石，但是其中有一些宝石是假的没有价值，显然小Y并不想要这些假的宝石，小Y被告诉了一个鉴别真假宝石的方法。将这些宝石排成一行，按照从 1∼n标上标号并得出其真实度，<strong>如果第 i 个宝石的真实度等于标号大于 i 的三个宝石的真实度乘积(可以使用标号相同的三个宝石)</strong>，这个宝石被认为是真的，你能帮小Y找出所有真的宝石的数量吗。</p><p>第一行一个整数 n (4≤n≤1500)，表示所有宝石数量。</p><p>第二行 n个整数 ai(−10^6^≤ai≤10^6^)，表示每个宝石的真实度。</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><p>直接暴力毫无疑问，数据量过大会TLE。</p><p>那么我就想到了打表，将两个宝石的乘积乘起来，再用map存起来。遍历宝石，如果除的通，且在map里面，即宝石为真的，ans++。</p><p>但是新的问题又出现了：如果直接每个宝石都正序打表，从头开始数据量过大。如果储存起来，可以采用记忆化思想减少重复运算，但又不能在针对某个宝石进行遍历时，知道表中的数据是不是宝石后面的乘积。</p><p>由此可以尝试一下倒序打表，这样打表的好处在于倒序打表，针对每一个新遍历的宝石i，进行打表。这样一来不会重复打表，可以保证表中的数据一定时某个宝石i后面的数据的乘积</p><p>带着这种思想便可以大致写出程序的大概了，但是仍需注意一些问题：</p><ol><li><strong>下标问题</strong>：针对第i个宝石判断真假时，对下标为<strong>n-1</strong>的宝石到<strong>i+1</strong>的宝石进行求积，并存入map中，再用宝石i ÷ [n-1,i+1]的宝石求商，如果商被标记过，ans++</li><li><strong>求商</strong>：必须判断num[i]!=0，不然会报错</li><li><strong>特判</strong>：对a[i] == 0 &amp;&amp; a[j] == 0 的情况需要特判</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxnum 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 1000000007</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="type">int</span> num[n + <span class="number">100</span>];</span><br><span class="line">    <span class="built_in">memset</span>(num, <span class="number">0</span>, <span class="built_in">sizeof</span>(num));</span><br><span class="line">    unordered_map&lt;ll, <span class="type">bool</span>&gt; mp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; num[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//需要倒序，并且一边打表一边判断</span></span><br><span class="line">    <span class="comment">//正序打表，储存下来不能判断是不是该宝石后的，所以必须倒序</span></span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) <span class="comment">//倒序，i作为判断的宝石</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = n - <span class="number">1</span>; j &gt; i; j--) <span class="comment">//倒序更新，并且随着i的不断减小，只更新没有出现过的乘积</span></span><br><span class="line">        &#123;</span><br><span class="line">            mp[num[i + <span class="number">1</span>] * num[j]] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = n - <span class="number">1</span>; j &gt; i; j--) <span class="comment">//关于第i个宝石，针对其后面的所有宝石，进行试除，如果可除通，并且被标记过，说明成功的</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (num[i] == <span class="number">0</span> &amp;&amp; mp[<span class="number">0</span>] == <span class="number">1</span>)<span class="comment">//对于1 1 0 0 这种情况，需要特判，因为除数和被除数都为0</span></span><br><span class="line">            &#123;</span><br><span class="line">                ans++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (num[j] != <span class="number">0</span> &amp;&amp; num[i] % num[j] == <span class="number">0</span> &amp;&amp; mp[num[i] / num[j]] == <span class="number">1</span>)<span class="comment">//常规判断</span></span><br><span class="line">            &#123;</span><br><span class="line">                ans++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-计算24点，并输出"><a href="#2-计算24点，并输出" class="headerlink" title="2.计算24点，并输出"></a>2.计算24点，并输出</h2><h3 id="题目标签-1"><a href="#题目标签-1" class="headerlink" title="题目标签"></a>题目标签</h3><p>递归；搜索</p><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>给出4个数，计算能否组成24点。</p><p>计算为+ - × ÷</p><p>可以加小括号</p><h3 id="题目解析-1"><a href="#题目解析-1" class="headerlink" title="题目解析"></a>题目解析</h3><p>递归函数的参数为</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dfs</span>(num,len,str);</span><br><span class="line"><span class="comment">//num为数组</span></span><br><span class="line"><span class="comment">//len为</span></span><br><span class="line"><span class="comment">//str为保存的输出字符串的数组</span></span><br></pre></td></tr></table></figure><p>对于数组num，每次任取两个不一样的数，相互操作，分别dfs</p><p>len为数组中的数的个数。如果len为1，说明已经完成全部操作</p><p>str以字符串的形式记录了对应操作的字符串</p><p>不过每次dfs时，需要新开一个数组</p><p>先记录不被选中的两个数，再把新合并的数存入数组中，再进行下一步操作</p><p>如果用原数组，或者全局变量，数据会被记录，不同的操作还需要回溯，不方便dfs</p><h3 id="通过代码"><a href="#通过代码" class="headerlink" title="通过代码"></a>通过代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> true 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> false 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> eps 1e-6</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> bool int</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> vis[<span class="number">4</span>];</span><br><span class="line"><span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line"><span class="type">bool</span> flag=<span class="literal">false</span>;</span><br><span class="line"><span class="type">bool</span> fflag;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">double</span> a[],<span class="type">int</span> len,string aa[<span class="number">4</span>])</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (len==<span class="number">1</span>)<span class="comment">//剩下一个数，说明操作完了</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">fabs</span>(<span class="number">24</span>-a[<span class="number">0</span>])&lt;eps)<span class="comment">//因为有小数，存在误差</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// printf(&quot;Yes&quot;);//不能直接输出，因为有多种情况，就会输出多次</span></span><br><span class="line">            flag=<span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (flag==<span class="literal">true</span>)<span class="comment">//如果已经找到了，就不再进行下面的计算了</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (fflag==<span class="literal">false</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;aa[<span class="number">0</span>]&lt;&lt;endl;</span><br><span class="line">            fflag=<span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len ; i++)<span class="comment">//挑选两个数操作</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; len ; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i==j)<span class="comment">//不能选相同的</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">double</span> t[<span class="number">4</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">            string tt[<span class="number">4</span>];</span><br><span class="line">            <span class="built_in">memset</span>(tt,<span class="number">0</span>,<span class="built_in">sizeof</span>(tt));</span><br><span class="line">            <span class="type">int</span> l=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; len; k++)<span class="comment">//先把除了选中的数以外的数存入新数组，不然等会不同的操作每次都要存，重复操作</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (k!=i &amp;&amp; k!=j)</span><br><span class="line">                &#123;</span><br><span class="line">                    t[l]=a[k];<span class="comment">//除了选中的数以外的数存入新数组</span></span><br><span class="line">                    tt[l]=aa[k];<span class="comment">//除了选中以外的数</span></span><br><span class="line">                    l++;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//控制括号的输出</span></span><br><span class="line">            string ykh=<span class="string">&quot;)&quot;</span>;</span><br><span class="line">            string zkh=<span class="string">&quot;(&quot;</span>;</span><br><span class="line">            <span class="comment">//如果最后一步不用加括号</span></span><br><span class="line">            <span class="keyword">if</span> (len==<span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ykh=<span class="string">&quot;&quot;</span>;</span><br><span class="line">                zkh=<span class="string">&quot;&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            t[l]=a[i]+a[j];<span class="comment">//把合并的两个数存入新数组</span></span><br><span class="line">            tt[l]=zkh+aa[i]+<span class="string">&quot;+&quot;</span>+aa[j]+ykh;<span class="comment">//表达式存入新数组</span></span><br><span class="line">            <span class="built_in">dfs</span>(t,len<span class="number">-1</span>,tt);<span class="comment">//下一步搜索</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            t[l]=a[i]-a[j];<span class="comment">//把合并的两个数存入新数组</span></span><br><span class="line">            tt[l]=zkh+aa[i]+<span class="string">&quot;-&quot;</span>+aa[j]+ykh;<span class="comment">//表达式存入新数组</span></span><br><span class="line">            <span class="built_in">dfs</span>(t,len<span class="number">-1</span>,tt);<span class="comment">//下一步搜索</span></span><br><span class="line"></span><br><span class="line">            t[l]=a[j]-a[i];<span class="comment">//把合并的两个数存入新数组</span></span><br><span class="line">            tt[l]=zkh+aa[j]+<span class="string">&quot;-&quot;</span>+aa[i]+ykh;<span class="comment">//表达式存入新数组</span></span><br><span class="line">            <span class="built_in">dfs</span>(t,len<span class="number">-1</span>,tt);<span class="comment">//下一步搜索</span></span><br><span class="line"></span><br><span class="line">            t[l]=a[i]*a[j];<span class="comment">//把合并的两个数存入新数组</span></span><br><span class="line">            tt[l]=aa[i]+<span class="string">&quot;*&quot;</span>+aa[j];<span class="comment">//表达式存入新数组</span></span><br><span class="line">            <span class="built_in">dfs</span>(t,len<span class="number">-1</span>,tt);<span class="comment">//下一步搜索</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//对除法进行搜索</span></span><br><span class="line">            <span class="keyword">if</span> (a[i]!=<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                t[l]=a[j]/a[i];</span><br><span class="line">                tt[l]=<span class="string">&quot;(&quot;</span>+aa[j]+<span class="string">&quot;/&quot;</span>+aa[i]+<span class="string">&quot;)&quot;</span>;</span><br><span class="line">                <span class="built_in">dfs</span>(t,len<span class="number">-1</span>,tt);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (a[j]!=<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                t[l]=a[i]/a[j];</span><br><span class="line">                tt[l]=<span class="string">&quot;(&quot;</span>+aa[i]+<span class="string">&quot;/&quot;</span>+aa[j]+<span class="string">&quot;)&quot;</span>;</span><br><span class="line">                <span class="built_in">dfs</span>(t,len<span class="number">-1</span>,tt);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">double</span> num[<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%lf %lf %lf %lf&quot;</span>,&amp;num[<span class="number">0</span>],&amp;num[<span class="number">1</span>],&amp;num[<span class="number">2</span>],&amp;num[<span class="number">3</span>]) &amp;&amp; num[<span class="number">0</span>]+num[<span class="number">1</span>]+num[<span class="number">2</span>]+num[<span class="number">3</span>]!=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        flag=<span class="literal">false</span>;</span><br><span class="line">        fflag=<span class="literal">false</span>;</span><br><span class="line">        string str[<span class="number">4</span>]=&#123;<span class="built_in">to_string</span>(<span class="built_in">int</span>(num[<span class="number">0</span>])),<span class="built_in">to_string</span>(<span class="built_in">int</span>(num[<span class="number">1</span>])),<span class="built_in">to_string</span>(<span class="built_in">int</span>(num[<span class="number">2</span>])),<span class="built_in">to_string</span>(<span class="built_in">int</span>(num[<span class="number">3</span>]))&#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">dfs</span>(num,<span class="number">4</span>,str);</span><br><span class="line">        <span class="keyword">if</span> (flag==<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;-1\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-PTA-汉诺塔问题"><a href="#3-PTA-汉诺塔问题" class="headerlink" title="3.PTA - 汉诺塔问题"></a>3.PTA - 汉诺塔问题</h2><h3 id="题目标签-2"><a href="#题目标签-2" class="headerlink" title="题目标签"></a>题目标签</h3><p>递归</p><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>将n个盘子从<code>原始柱子a</code>借助<code>过渡柱b</code>移动到<code>目标柱c</code></p><h3 id="题目解析-2"><a href="#题目解析-2" class="headerlink" title="题目解析"></a>题目解析</h3><p>将n个盘子从a借助b移动到c需经过以下三步操作</p><ol><li>将n-1个盘子从a借助c移动到b</li><li>将第n个盘子从a移动到c</li><li>将n-1个盘子从b借助a移动到c</li></ol><p>而每一步操作又可以递归一次</p><p>递归的出口就在于</p><p>当只有一个盘子时可以直接将a移动到c</p><h3 id="通过代码-1"><a href="#通过代码-1" class="headerlink" title="通过代码"></a>通过代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MoveTower</span><span class="params">(<span class="type">int</span> num, <span class="type">char</span> src, <span class="type">char</span> dst, <span class="type">char</span> trs)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1</span> == num)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;%d: %c -&gt; %c\n&quot;</span>,num, src, dst);;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="built_in">MoveTower</span>(num - <span class="number">1</span>, src, trs, dst);</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;%d: %c -&gt; %c\n&quot;</span>,num, src, dst);</span><br><span class="line">          <span class="built_in">MoveTower</span>(num - <span class="number">1</span>, trs, dst, src);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">char</span> s, d, t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %c %c %c&quot;</span>, &amp;n, &amp;s, &amp;d, &amp;t);</span><br><span class="line">    <span class="built_in">MoveTower</span>(n, s, d, t);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-函数递归-E-正方形"><a href="#4-函数递归-E-正方形" class="headerlink" title="4.函数递归 - E - 正方形"></a>4.函数递归 - E - 正方形</h2><blockquote><p><a href="https://vjudge.net/problem/UVA-201">题目链接</a></p></blockquote><h3 id="题目标签-3"><a href="#题目标签-3" class="headerlink" title="题目标签"></a>题目标签</h3><p>模拟;矩阵</p><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><p>设有一个n×n的矩阵,给出点与点之间连接的关系,求出一共有多少个正方形</p><h3 id="题目解析-3"><a href="#题目解析-3" class="headerlink" title="题目解析"></a>题目解析</h3><p>由于数据量少,采用纯暴力法;</p><p>遍历每一个点,对该点遍历每一个正方形的边长,判断是否有连线,有的话则cnt[边长]++</p><p>那么对于每一个边长的正方形,该如何去遍历,判断有无连线呢</p><p>因为连线是离散的,还没有学图论还不知道怎么优化,去松弛点与点的关系</p><p>这里直接先用一个四维数组num[i~1~][j~1~][i~2~][j~2~]表示i~1~j~1~到i~2~j~2~之间有连线</p><p>那么如何判断边长为2及以上的点有连线呢</p><p>这里直接用一个循环判断</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">边长为k时</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> l;l&lt;=k;l++)&#123;</span><br><span class="line"></span><br><span class="line">对点之间的判断加上一个l,表示当前从原始的点出发了几步,来判断当前点到目标点之间的点之间有没有连线</span><br><span class="line">num[i][j+l][i][j+l+<span class="number">1</span>]==<span class="number">1</span>;</span><br><span class="line">    num[i+k][j+l][i+k][j+l+<span class="number">1</span>]==<span class="number">1</span>;</span><br><span class="line">    num[i+l][j][i+l+<span class="number">1</span>][j]==<span class="number">1</span>;</span><br><span class="line">    num[i+l][j+k][i+l+<span class="number">1</span>][j+k]==<span class="number">1</span></span><br><span class="line">    上述四个关系式来表示边长为l的长方形走步长为k时是否点与点之间连着线</span><br><span class="line">&#125;</span><br><span class="line">如下图黑线表示l的长度</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/wzy2002/pic-bed/raw/master/img/image-20220719205736448.png" alt="image-20220719205736448"  /></p><p><strong>几个细节要注意:</strong></p><ol><li>k的步长部分要循环到<code>k&lt;=min(n-i,n-j)</code>这样可以减少无用的循环</li><li>输入部分要注意,Vertical的输入是先输入列再输入行</li><li>uva的输入输出很严格,换行要多注意细节,与标准输出进行对比</li></ol><h3 id="通过代码-2"><a href="#通过代码-2" class="headerlink" title="通过代码"></a>通过代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxnum 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 1000000007</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;n&gt;&gt;m)&#123;</span><br><span class="line">        <span class="keyword">if</span> (t!=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;\n**********************************\n&quot;</span>&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">        ++t;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> num[<span class="number">11</span>][<span class="number">11</span>][<span class="number">11</span>][<span class="number">11</span>];<span class="comment">//四维数组，存储</span></span><br><span class="line">        <span class="built_in">memset</span>(num,<span class="number">0</span>,<span class="built_in">sizeof</span>(num));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; m; k++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">char</span> opt;</span><br><span class="line">            <span class="type">int</span> i,j;</span><br><span class="line">            cin&gt;&gt;opt&gt;&gt;i&gt;&gt;j;</span><br><span class="line">            <span class="keyword">if</span> (opt==<span class="string">&#x27;H&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                num[i][j][i][j+<span class="number">1</span>]=<span class="number">1</span>;<span class="comment">//两双向链接</span></span><br><span class="line">                num[i][j+<span class="number">1</span>][i][j]=<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                num[j][i][j+<span class="number">1</span>][i]=<span class="number">1</span>;</span><br><span class="line">                num[j+<span class="number">1</span>][i][j][i]=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//枚举i j</span></span><br><span class="line">        <span class="type">int</span> cnt[<span class="number">10</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j&lt;= n;j++)&#123;</span><br><span class="line">                <span class="comment">//对于点i，j根据步长k枚举</span></span><br><span class="line"></span><br><span class="line">                </span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=<span class="built_in">min</span>(n-i,n-j);k++)&#123;<span class="comment">//k为步长</span></span><br><span class="line">                    <span class="type">bool</span> flag=<span class="literal">true</span>;</span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">0</span>; l &lt; k; l++)<span class="comment">//l为到i，j+k之间的点,一步一步判断</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">if</span>( num[i][j+l][i][j+l+<span class="number">1</span>]==<span class="number">1</span> &amp;&amp; </span><br><span class="line">                            num[i+k][j+l][i+k][j+l+<span class="number">1</span>]==<span class="number">1</span> &amp;&amp; </span><br><span class="line">                            num[i+l][j][i+l+<span class="number">1</span>][j]==<span class="number">1</span> &amp;&amp; </span><br><span class="line">                            num[i+l][j+k][i+l+<span class="number">1</span>][j+k]==<span class="number">1</span>)</span><br><span class="line">                        &#123;<span class="comment">//判断四个点的步长</span></span><br><span class="line"><span class="keyword">continue</span>;<span class="comment">//步长内再走一步</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">//走完k步以后判断走不走得通</span></span><br><span class="line">                    <span class="keyword">if</span> (flag==<span class="literal">false</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;<span class="comment">//走不通,下一个步长</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (flag==<span class="literal">true</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        cnt[k]++;<span class="comment">//走的通,正方形大小为k的++</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                &#125; </span><br><span class="line">                </span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Problem #&quot;</span>&lt;&lt;t&lt;&lt;endl&lt;&lt;endl;</span><br><span class="line">        <span class="type">bool</span> f=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span> ; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(cnt[i]!=<span class="number">0</span>)&#123;</span><br><span class="line">                cout&lt;&lt;cnt[i]&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;<span class="string">&quot;square (s) of size &quot;</span>&lt;&lt;i&lt;&lt;endl;</span><br><span class="line">                f=<span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(f==<span class="literal">false</span>)&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;No completed squares can be found.&quot;</span>&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// printf(&quot;Time used = %.2lf\n&quot;, (double)clock() / CLOCKS_PER_SEC);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-火车站出栈合法性问题"><a href="#5-火车站出栈合法性问题" class="headerlink" title="5.火车站出栈合法性问题"></a>5.火车站出栈合法性问题</h2><blockquote><h3 id="两种方法"><a href="#两种方法" class="headerlink" title="两种方法"></a>两种方法</h3><p>1.枚举每一种出栈顺序。用dfs做</p><p>2.模拟出栈</p></blockquote><h2 id="6-The-Blocks-Problem"><a href="#6-The-Blocks-Problem" class="headerlink" title="6.The Blocks Problem"></a>6.The Blocks Problem</h2><h3 id="题目标签-4"><a href="#题目标签-4" class="headerlink" title="题目标签"></a>题目标签</h3><p>vector</p><h3 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h3><p>有n个小方块，编号从0-n-1</p><p>给出一序列指令操作</p><p>求出最终小方块的摆放方式</p><p>move a onto b</p><ul><li>a和b都是方块的编号，先将a和b上面所有的方块都放回原处，再将a放在b上。</li></ul><p>move a over b</p><ul><li>a和b都是方块的编号，先将a上面所有的方块放回原处，再将a放在b上。（b上原有方块不动）</li></ul><p>pile a onto b</p><ul><li>a和b都是方块的编号，将a和其上面所有的积极组成的一摞整体移动到b上。在移动前要先将b上面所有的积极都放回原处。移动的一摞方块要保持原来的顺序不变。</li></ul><p>pile a over b</p><ul><li>a和b都是方块的编号，将a和其上面所有的方块组成的一摞整体移动到b所在一摞方块的最上面一个方块上。移动的一摞方块要保持原来的顺序不变。</li></ul><p><em>quit</em></p><ul><li>结束方块的操纵。</li></ul><h3 id="题目解析-4"><a href="#题目解析-4" class="headerlink" title="题目解析"></a>题目解析</h3><p><strong>一开始的想法：</strong></p><p>搞十个栈，然后存入一个结构体，结构体记录了当前结点存在的栈的位置</p><p>一番尝试后发现过于复杂</p><p>容易把自己绕晕，而且push进栈里的结构体，也只能push值进去，而不是原来的，所以不能直接从读入的a，b进行查找，反而不如遍历查找来的效率高</p><p><strong>正确解法：</strong></p><p>使用一个vector数组；</p><p>使用resizie操作可以轻松的把上面不需要的元素清楚。比栈方便很多</p><p>而读入进来的结点在哪个位置只需要手写一个find函数，参数是调用了传入形参的引用，这样就可以在外部函数里操作。也不用把查找完的值放回主函数内。</p><p><strong>关于指令操作：</strong></p><p>其实只需要2种指令；一种清理上方元素归为，一种为把所有元素全部放进去</p><p>因为一个元素的时候，某一元素上面的所有元素就是他自己，所以不用做单独的放一个元素的操作</p><h3 id="通过代码-3"><a href="#通过代码-3" class="headerlink" title="通过代码"></a>通过代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxnum 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 1000000007</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">25</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v[N];</span><br><span class="line"><span class="comment">//用vector来模拟</span></span><br><span class="line"><span class="comment">//每次要先找到</span></span><br><span class="line"><span class="comment">//定理：</span></span><br><span class="line"><span class="comment">//      onto清空b上的</span></span><br><span class="line"><span class="comment">//      move清空a上的</span></span><br><span class="line"><span class="comment">//      两种情况都需要把x上的放到y上</span></span><br><span class="line"><span class="comment">//注意：</span></span><br><span class="line"><span class="comment">//      都设置为全局变量，方便操作</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; i &lt;&lt; <span class="string">&quot;:&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; v[i].<span class="built_in">size</span>(); j++)</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; v[i][j];</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">find</span><span class="params">(<span class="type">int</span> key,<span class="type">int</span> &amp;x,<span class="type">int</span> &amp;y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; v[i].<span class="built_in">size</span>(); j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(v[i][j]==key)&#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//clear：把v[ax][ay]-v[ax][max]的清空，归位</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">(<span class="type">int</span> ax,<span class="type">int</span> ay)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = ay+<span class="number">1</span>; j &lt; v[ax].<span class="built_in">size</span>(); j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> b = v[ax][j];</span><br><span class="line">        v[b].<span class="built_in">push_back</span>(b);</span><br><span class="line">    &#125;</span><br><span class="line">    v[ax].<span class="built_in">resize</span>(ay + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//把v[ax]上从ay到最大元素全部搬到v[bx]上，然后再重新resize v[ax]的大小，不需要做过多的删除操作</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">renew</span><span class="params">(<span class="type">int</span> ax,<span class="type">int</span> ay,<span class="type">int</span> bx)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = ay; i &lt; v[ax].<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        v[bx].<span class="built_in">push_back</span>(v[ax][i]);</span><br><span class="line">    &#125;</span><br><span class="line">    v[ax].<span class="built_in">resize</span>(ay);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        v[i].<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    string op;</span><br><span class="line">    <span class="keyword">while</span> (cin&gt;&gt;op &amp;&amp; op!=<span class="string">&quot;quit&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        string way;</span><br><span class="line">        <span class="type">int</span> a,b;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;way&gt;&gt;b;</span><br><span class="line">        <span class="comment">//先找到点的位置，再进行下一步操作</span></span><br><span class="line">        <span class="comment">//定义两个坐标来储存变量，让外部函数调用他们的引用</span></span><br><span class="line">        <span class="type">int</span> ax,bx,ay,by;</span><br><span class="line">        <span class="built_in">find</span>(a,ax,ay);<span class="comment">//操作，让ax，ay变成a所在的位置</span></span><br><span class="line">        <span class="built_in">find</span>(b,bx,by);<span class="comment">//操作，让bx，by变成b所在的位置</span></span><br><span class="line">        <span class="keyword">if</span> (ax==bx)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (op==<span class="string">&quot;move&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">clear</span>(ax,ay);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (way==<span class="string">&quot;onto&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">clear</span>(bx,by);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">renew</span>(ax,ay,bx);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">print</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-组合数问题"><a href="#7-组合数问题" class="headerlink" title="7.组合数问题"></a>7.组合数问题</h2><h3 id="题目标签-5"><a href="#题目标签-5" class="headerlink" title="题目标签"></a>题目标签</h3><p>搜索</p><h3 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定n个数，从中取r个数进行组合，求解法和个数</p><h3 id="题目解析-5"><a href="#题目解析-5" class="headerlink" title="题目解析"></a>题目解析</h3><p>n个数，取r个进行组合。也就是dfs r层，每层都要取数，数的范围是前一层取的数+1 ~ n。</p><p>为了保证组合没有重复的，所以每层取得数都是前一层数的+1.同时还能保证是按照升序进行输出。</p><h3 id="通过代码-4"><a href="#通过代码-4" class="headerlink" title="通过代码"></a>通过代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxnum 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 1000000007</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="type">int</span> n;<span class="type">int</span> r; </span><br><span class="line"><span class="type">int</span> all;</span><br><span class="line"><span class="type">int</span> a[<span class="number">22</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> begin)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (begin==r+<span class="number">1</span>)<span class="comment">//终点</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= r; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%3d&quot;</span>,a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = a[begin<span class="number">-1</span>]+<span class="number">1</span>; i &lt;= n; i++)<span class="comment">//i是必须是递增的</span></span><br><span class="line">    &#123;</span><br><span class="line">        a[begin]=i;</span><br><span class="line">        <span class="built_in">dfs</span>(begin+<span class="number">1</span>);<span class="comment">//递增后的下一步搜索</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;r;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-数的全排列"><a href="#8-数的全排列" class="headerlink" title="8.数的全排列"></a>8.数的全排列</h2><h3 id="题目标签-6"><a href="#题目标签-6" class="headerlink" title="题目标签"></a>题目标签</h3><p>搜索</p><h3 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定n个数1-n，求全排列</p><h3 id="题目解析-6"><a href="#题目解析-6" class="headerlink" title="题目解析"></a>题目解析</h3><p>除了next_permutation以外，还有几种使用深度优先搜素的算法来进行求解</p><p>首先将1-n全部存入数组，存进去之后，用dfs来进行数的交换，交换的顺序是从最后交换到第一个。</p><h3 id="通过代码-5"><a href="#通过代码-5" class="headerlink" title="通过代码"></a>通过代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxnum 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 1000000007</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="type">int</span> a[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> num=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//定义一个数组，让搜索时可以访问到那些元素</span></span><br><span class="line"><span class="comment">//每次让他们交换一个位置，然后该交换位置之后的继续向下搜索交换位置的</span></span><br><span class="line"><span class="comment">//每次交换位置的是begin和i交换，i++，也就是从begin开始，到begin以后的要进行交换</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Perm</span><span class="params">(<span class="type">int</span> begin, <span class="type">int</span> end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//先写出出口</span></span><br><span class="line">    <span class="keyword">if</span> (begin == end)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; end; i++)<span class="comment">//必须是&lt;=end</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%5d&quot;</span>, a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        num++;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = begin; i &lt; end; i++)<span class="comment">//必须是&lt;=end</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">swap</span>(a[i], a[begin]);</span><br><span class="line">        <span class="built_in">Perm</span>(begin + <span class="number">1</span>, end);</span><br><span class="line">        <span class="built_in">swap</span>(a[i], a[begin]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        a[i] = i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//初始化完成</span></span><br><span class="line">    <span class="built_in">Perm</span>(<span class="number">0</span>, n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="9-N皇后问题"><a href="#9-N皇后问题" class="headerlink" title="9.N皇后问题"></a>9.N皇后问题</h2><h3 id="题目标签-7"><a href="#题目标签-7" class="headerlink" title="题目标签"></a>题目标签</h3><p>深度优先搜索</p><h3 id="题目描述-7"><a href="#题目描述-7" class="headerlink" title="题目描述"></a>题目描述</h3><p>一个N*N的棋盘上有N个棋子，棋子的攻击范围是同一行，同一列，同一对角线（正副两个对角线），要求求出一种摆放的顺序，使得摆放八个棋子不会相互攻击到。</p><h3 id="题目解析-7"><a href="#题目解析-7" class="headerlink" title="题目解析"></a>题目解析</h3><p>采用dfs的方式求解。</p><p>因为棋子不可能会被放在同一行，所以从上往下的行数进行dfs，注意每次放置一个棋子，都需要为他的攻击范围进行标记，即该点不能被放置新的棋子。</p><p>即一行一行的往下搜索，每一层的搜索，都将选择1-n的位置判断是否能摆放，能摆放则进行摆放，每种摆放位置都进入棋盘的下一行进行下一步dfs搜索。</p><ul><li><h4 id="需要注意的点："><a href="#需要注意的点：" class="headerlink" title="需要注意的点："></a><strong>需要注意的点：</strong></h4></li></ul><p><strong>1. 如果采用二维数组进行标记：</strong></p><p>那么需要在走不通的路之后进行回溯时，需要对标记过的进行撤销。而标记和撤销标记的关键步骤在于，不要使用a[i][j]=1 或这a[i][j]=0的方式进行标记撤销，而要使用a[i][j]=++或这a[i][j]—的方式。原因在于，如果一个点被他上面的棋子标记了，同时也被另一个棋子标记了，如果另一个棋子走不通，撤销标记时，直接把该点置为0的话，那么第一个棋子标记他的效果则会被另一个棋子的撤销而失效。所以采用++ — 的方式，即一个棋子不再是被标记而是被标记x次。这样撤销的时候不会直接撤销全部效果。而是—，如果&gt;0，说明还有标记他的。只有当他变为0，也就是所有标记他的棋子都回溯了以后，才能说明这一点被真正的重新可以使用</p><p><strong>2. 优化后的简便方法：</strong></p><p>只需要用ans数组记录摆放的列即可，因为ans[i]=x.就已经说明了是i行x列的被放上了棋子。</p><p>由于采用二维数组做的复杂性，和回溯撤销非常麻烦。这里引入一个刘汝佳《算法竞赛入门经典》中的一个快速判断是否能放置棋子的办法。</p><p>同一列其实非常好判断，只需在下一个棋子的时候，枚举之前全部下过的棋子的列数(用ans数组保存的哪个)，当前列和之前下过的列是否相等，如果相等说明在同一列。</p><p>而同一对角线则需要一些数学性质：</p><ol><li>同一主对角线上的点，y-x的值都是相等的。如(1,1) (2,2) (3,3)都处于同一对角线上，而他们的y-x值都相等。再如(1,2) (2,3) (3,4) 也是存在于同一主对角线上。y-x的值也相等。</li><li>副对角线上的点则是x+y的值都相等，详见下图</li></ol><p><img src="https://gitee.com/wzy2002/pic-bed/raw/master/img/image-20220723120939376.png" alt="image-20220723120939376"></p><h3 id="通过代码-6"><a href="#通过代码-6" class="headerlink" title="通过代码"></a>通过代码</h3><ul><li><h4 id="二维数组标记版本"><a href="#二维数组标记版本" class="headerlink" title="二维数组标记版本"></a>二维数组标记版本</h4></li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxnum 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 1000000007</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> tree = <span class="number">0</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[<span class="number">13</span>][<span class="number">13</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> ans[<span class="number">13</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (k == n) <span class="comment">//终点</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (num &lt; <span class="number">3</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d%s&quot;</span>, ans[i], i == n - <span class="number">1</span> ? <span class="string">&quot;\n&quot;</span> : <span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        num++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//每个深度(行)，枚举列放棋子，i为列，k为行</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[k][i] &lt; <span class="number">1</span>) <span class="comment">//没被标记可以放</span></span><br><span class="line">        &#123;</span><br><span class="line">            tree++;</span><br><span class="line">            ans[k] = i + <span class="number">1</span>;</span><br><span class="line">            a[k][i]++;</span><br><span class="line">            <span class="comment">//标记不能放置的棋子,同行同列，斜边</span></span><br><span class="line">            <span class="comment">//同行可以其实不标记，因为是一行一行下去的</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = k; j &lt; n; j++) <span class="comment">//同一列</span></span><br><span class="line">            &#123;</span><br><span class="line">                a[j][i]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = k + <span class="number">1</span>, xie = <span class="number">1</span>; j &lt; n; j++) <span class="comment">//向下的斜边</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (i + xie &lt; n)</span><br><span class="line">                    a[j][i + xie]++;</span><br><span class="line">                <span class="keyword">if</span> (i - xie &gt;= <span class="number">0</span>)</span><br><span class="line">                    a[j][i - xie]++;</span><br><span class="line">                xie++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">dfs</span>(k + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果用新数组递归下去，回溯不用删除</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = k; j &lt; n; j++) <span class="comment">//同一列</span></span><br><span class="line">            &#123;</span><br><span class="line">                a[j][i]--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = k + <span class="number">1</span>, xie = <span class="number">1</span>; j &lt; n; j++) <span class="comment">//向下的斜边</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (i + xie &lt; n)</span><br><span class="line">                    a[j][i + xie]--;</span><br><span class="line">                <span class="keyword">if</span> (i - xie &gt;= <span class="number">0</span>)</span><br><span class="line">                    a[j][i - xie]--;</span><br><span class="line">                xie++;</span><br><span class="line">            &#125;</span><br><span class="line">            a[k][i]--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line">    cout &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><h4 id="一维数组优化版本"><a href="#一维数组优化版本" class="headerlink" title="一维数组优化版本"></a>一维数组优化版本</h4></li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxnum 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 1000000007</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> tree = <span class="number">0</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[<span class="number">13</span>][<span class="number">13</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> ans[<span class="number">13</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//优化方法：</span></span><br><span class="line"><span class="comment">//主要是对判断是否被标记做优化</span></span><br><span class="line"><span class="comment">//引理：处于同一主对角线上的，纵坐标值-横坐标值相等。处于同一副对角线上的，纵坐标值+横坐标值值相等。</span></span><br><span class="line"><span class="comment">//我们也不需要使用二维数组来储存，因为a[i]的i就是行号，a[i]的值就是列号。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (k == n) <span class="comment">//终点</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (num &lt; <span class="number">3</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d%s&quot;</span>, ans[i], i == n - <span class="number">1</span> ? <span class="string">&quot;\n&quot;</span> : <span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        num++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)<span class="comment">//针对每一行有n种不同的列可以摆放棋子</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">bool</span> ok = <span class="literal">true</span>;</span><br><span class="line">        ans[k] = i + <span class="number">1</span>;<span class="comment">//下标从0开始，但输出的是从1开始，i+1。不会影响引理的判断，因为所有的列号都被+1了</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; k; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (ans[k] == ans[j] || k - ans[k] == j - ans[j] || k + ans[k] == j + ans[j]) <span class="comment">//引理</span></span><br><span class="line">            &#123;</span><br><span class="line">                ok = <span class="literal">false</span>;<span class="comment">//如果位于同一列/斜边---不能进行下一步dfs</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ok == <span class="literal">true</span>)</span><br><span class="line">            <span class="built_in">dfs</span>(k + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line">    cout &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="10-信息编码"><a href="#10-信息编码" class="headerlink" title="10.信息编码"></a>10.信息编码</h2><h3 id="题目标签-8"><a href="#题目标签-8" class="headerlink" title="题目标签"></a>题目标签</h3><p>哈希</p><h3 id="题目描述-8"><a href="#题目描述-8" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一串字符串，为解码的信息。</p><p>每个字符分别对应着 0 01 10 000 001 010 011 100 101 110 0000 0001 ······。没有全部为1的解码串</p><p>当读取到这样的字符是，可以解码。</p><p>给出一串01组成的密钥，前三个代表着字符的长度，后面相应的字符串代表着字符的解码串，读到全1时表面当前长度的解码串结束，读到000时表示当前case结束</p><h3 id="题目解析-8"><a href="#题目解析-8" class="headerlink" title="题目解析"></a>题目解析</h3><p>用一个二维数组来表示解码的信息。code[len][value],前一个代表长度，后一个储存信息。</p><p>value将2进制信息转换成10进制来储存</p><p>注意结尾要把换行符读取掉</p><h3 id="通过代码-7"><a href="#通过代码-7" class="headerlink" title="通过代码"></a>通过代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxnum 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 1000000007</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">change</span><span class="params">(string s)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">length</span>();i++)&#123;</span><br><span class="line">        sum=sum*<span class="number">2</span>+(s[i]-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// code[len][value];len为长度;value为值；value有2^len - 1个</span></span><br><span class="line">    <span class="type">char</span> code[<span class="number">100</span>][<span class="number">1000</span>] = &#123;<span class="string">&quot;&quot;</span>&#125;;</span><br><span class="line">    string head;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">getline</span>(cin, head))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//编码</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; t &lt; head.<span class="built_in">length</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> len = <span class="built_in">pow</span>(<span class="number">2</span>, i) - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; len; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                code[i][j] = head[t];</span><br><span class="line">                t++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)<span class="comment">//解码</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//读取长度</span></span><br><span class="line">            string slen = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="type">char</span> c;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">               </span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>, &amp;c);</span><br><span class="line">                <span class="keyword">if</span>(c==<span class="string">&#x27;\n&#x27;</span>)&#123;</span><br><span class="line">                    <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;c);</span><br><span class="line">                &#125;</span><br><span class="line">                slen += c;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> l = <span class="built_in">change</span>(slen);</span><br><span class="line">            <span class="keyword">if</span>(l==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//读取对应码值</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                string s;</span><br><span class="line">                <span class="type">char</span> cc;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; l; i++) <span class="comment">//读取l个字符</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>, &amp;cc);</span><br><span class="line">                    <span class="keyword">if</span>(cc==<span class="string">&#x27;\n&#x27;</span>)&#123;</span><br><span class="line">                        <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;cc);</span><br><span class="line">                    &#125;</span><br><span class="line">                    s += cc;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">int</span> num = <span class="built_in">change</span>(s);</span><br><span class="line">                <span class="keyword">if</span> (num == <span class="built_in">pow</span>(<span class="number">2</span>, l) - <span class="number">1</span>)</span><br><span class="line">                &#123; <span class="comment">// 111跳出当前循环</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                cout &lt;&lt; code[l][num];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="11-产生冠军"><a href="#11-产生冠军" class="headerlink" title="11.产生冠军"></a>11.产生冠军</h2><h3 id="题目标签-9"><a href="#题目标签-9" class="headerlink" title="题目标签"></a>题目标签</h3><p>拓扑排序/Set</p><h3 id="题目描述-9"><a href="#题目描述-9" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一组数据，代表xx输给了xx。</p><p>请求判定这局有没有冠军</p><h3 id="题目解析-9"><a href="#题目解析-9" class="headerlink" title="题目解析"></a>题目解析</h3><p><strong>解法一：</strong></p><p>仅当有人一人没输过时才能产生冠军，所以只需用两个set，分别记录所有人和输的人，比较他们的size的差是否为1即可。</p><p><strong>解法二：</strong></p><p>拓扑排序解法，给所有人记录入度和出度，仅当有一人的入度为0时，即可产生冠军</p><h3 id="通过代码-8"><a href="#通过代码-8" class="headerlink" title="通过代码"></a>通过代码</h3><p><strong>解法二：</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; n &amp;&amp; n != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        map&lt;string, <span class="type">int</span>&gt; mp;　　<span class="comment">// 分别为名字，入度</span></span><br><span class="line">        string a, b;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">            mp[b] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(mp[a] != <span class="number">1</span>)</span><br><span class="line">                mp[a] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;    <span class="comment">// 入度为0的节点个数</span></span><br><span class="line">        <span class="keyword">for</span>(map&lt;string, <span class="type">int</span>&gt;::iterator it = mp.<span class="built_in">begin</span>(); it != mp.<span class="built_in">end</span>(); ++it)</span><br><span class="line">            <span class="keyword">if</span>(it-&gt;second == <span class="number">0</span>)</span><br><span class="line">                cnt++;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(cnt == <span class="number">1</span>)</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法周记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>22暑期ACM集训周记01</title>
      <link href="/2022/07/17/ACM%E5%91%A8%E8%AE%B0/%E6%9A%91%E6%9C%9FACM%E5%91%A8%E8%AE%B01/"/>
      <url>/2022/07/17/ACM%E5%91%A8%E8%AE%B0/%E6%9A%91%E6%9C%9FACM%E5%91%A8%E8%AE%B01/</url>
      
        <content type="html"><![CDATA[<h1 id="一、第一周学习总结表"><a href="#一、第一周学习总结表" class="headerlink" title="一、第一周学习总结表"></a>一、第一周学习总结表</h1><ul><li><h4 id="本周学习完成情况"><a href="#本周学习完成情况" class="headerlink" title="本周学习完成情况"></a>本周学习完成情况</h4><table border="1"><tr><th>Contest</th><th>完成情况</th></tr><tr><td>数组和字符串进阶练习</td><td>11/13</td></tr><tr><td>简单数学题、数组字符串练习</td><td>13/13</td></tr><tr><td>ACM入门练习-hdu</td><td>13/13</td></tr><tr><td><b>枚举算法练习</b></td><td><b>7/7</b></td></tr><tr><td><b>总计</b></td><td><b>44/46</b></td></tr></table></li><li><h4 id="个人小结"><a href="#个人小结" class="headerlink" title="个人小结"></a>个人小结</h4><ol><li><p><strong>个人感悟</strong></p><p>经过一周的训练，收获颇多。题目虽然不难，但是对于英文的快速阅读能力，和不同OJ平台的输入输出的考验是前所未有的。每次写题不再是使用单纯纯暴力写法，更多的会再一开始就去分析题目背后的真正含义，将其转换成一个较为熟悉的问题。</p></li></ol></li></ul><h1 id="二、本周学习的新内容"><a href="#二、本周学习的新内容" class="headerlink" title="二、本周学习的新内容"></a>二、本周学习的新内容</h1><p>本以为第一周的内容都是已经了然于心的基础知识，没想到在刷题中也学到了许多未曾注意的细节。</p><ul><li>对于EOF输入结尾的题目可以使用<code>while(~scanf(&quot;%d&quot;,&amp;n));</code>来处理</li><li>OJ上浏览大佬代码，学会了使用<code>ios::sync_with_stdio(false);cin.tie(0);</code>来加快io流中cin，cout的读写速度</li><li><p>学会了使用</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">clock start,end;</span><br><span class="line">start=<span class="built_in">clock</span>();</span><br><span class="line">end=<span class="built_in">clock</span>();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Time used = %.2lf\n&quot;</span>, (<span class="type">double</span>)(sta) / CLOCKS_PER_SEC);</span><br></pre></td></tr></table></figure><p>来输出程序花费的时间</p></li><li>熟练掌握了对拍来检查程序与标程的区别，从而检查出自己代码的错误之处<br>使用<code>freopen(&quot;3output.out&quot;,&quot;w&quot;,stdout);freopen(&quot;1input.in&quot;,&quot;r&quot;,stdin);</code>输出重定向至文件，检查不同代码之间的区别</li><li>对于询问次数多，复杂度高的问题，用打表做更方便</li><li>学会了Joseph的递推公式为$f(N,M)=(f(N−1,M)+M)modN$</li></ul><h1 id="三、题解一览"><a href="#三、题解一览" class="headerlink" title="三、题解一览"></a>三、题解一览</h1><h2 id="1-ACM入门练习-I-Download-Manager"><a href="#1-ACM入门练习-I-Download-Manager" class="headerlink" title="1.ACM入门练习- I - Download Manager"></a>1.ACM入门练习- I - Download Manager</h2><p><a href="https://vjudge.net/contest/503256#problem/I">ACM入门练习-hdu - Virtual Judge (vjudge.net)</a></p><h3 id="题目标签"><a href="#题目标签" class="headerlink" title="题目标签"></a>题目标签</h3><p>数学；技巧</p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>本题要求我们模拟一个下载器，根据输入的最大宽带B，和同时下载文件数n作为限制条件。</p><p>针对已给出文件大小和完成进度的多少，计算总任务完成的所需时间。</p><p>下载器会根据如下规律下载文件：</p><ol><li>优先挑选大小最小的n个文件，如果文件大小相同则先选择完成进度大的</li><li>一个文件完成后，即开始下一个文件的下载，速度平均分配给每个文件</li><li>如果少于n个文件，那么速度也平均分配给n个文件</li></ol><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><p>本题乍一看下，以为是个模拟题，操作步骤极为繁琐。但其实仔细分析，推导出背后的原理，会发现这题非常的简单。</p><p>题目要求我们求出的是下载的时间，而难点就在于不同的文件完成进度不一样，大小也不一样。如果用结构体来模拟下载的文件，并循环直至文件全部下载好，这将花费大量的精力在编写运算条件上。</p><p>而如果我们不从文件出发，换个角度从下载器下载的大小出发，问题就会变得简单。</p><p>根据推导我们可以发现</p><ul><li>假如有三个文件时，每个文件的下载速度是总文件大小总共是</li></ul><script type="math/tex; mode=display">3*时间*\frac{速度}{3}</script><ul><li>假如有两个文件时，每个文件的下载速度是总文件大小总共是</li></ul><script type="math/tex; mode=display">2*时间*\frac{速度}{2}</script><ul><li>假如有n个文件时，每个文件的下载速度是总文件大小总共是</li></ul><script type="math/tex; mode=display">n*时间*\frac{速度}{n}</script><p>我们发现无论多少个文件同时下载，下载器的下载总速度是不变的，即</p><script type="math/tex; mode=display">时间*速度</script><p>所以只需要将剩余未下载完的所有大小全部加起来再除以最大带宽速度即可</p><h3 id="通过代码"><a href="#通过代码" class="headerlink" title="通过代码"></a>通过代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxnum 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 1000000007</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> T,m,maxn;</span><br><span class="line">        <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>,&amp;T,&amp;m,&amp;maxn))&#123;</span><br><span class="line">        <span class="keyword">if</span> (T==<span class="number">0</span> &amp;&amp; m==<span class="number">0</span> &amp;&amp; maxn==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">double</span> size;<span class="type">double</span> com;<span class="type">double</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; T; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            cin&gt;&gt;size&gt;&gt;com;</span><br><span class="line">            sum+=size*(<span class="number">100</span>-com)*<span class="number">0.01</span>;<span class="comment">//总下载剩余量</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Case %d: %.2lf\n\n&quot;</span>,t,sum/maxn);</span><br><span class="line">        t++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-数学、字符串-A-Joseph"><a href="#2-数学、字符串-A-Joseph" class="headerlink" title="2.数学、字符串 - A - Joseph"></a>2.数学、字符串 - A - Joseph</h2><blockquote><p>约瑟夫环总结：<a href="https://blog.csdn.net/mzpqq/article/details/124568918">https://blog.csdn.net/mzpqq/article/details/124568918</a></p></blockquote><h3 id="题目标签-1"><a href="#题目标签-1" class="headerlink" title="题目标签"></a>题目标签</h3><p>数学；打表</p><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个数字n，总共2n个人围成一圈，前n个坏人，后n个好人，求最m为几，使得踢出去的都是坏人</p><h3 id="题目解析-1"><a href="#题目解析-1" class="headerlink" title="题目解析"></a>题目解析</h3><p>n很小所以可以直接枚举，打表输出</p><p>根据递推公式$f(N,M)=(f(N−1,M)+M)%N$，枚举m，保证每次出列的人都是坏人，如果是坏人，则运行，如果是好人则退出枚举下一个</p><h3 id="通过代码-1"><a href="#通过代码-1" class="headerlink" title="通过代码"></a>通过代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxnum 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 1000000007</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="function">ll <span class="title">getf</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (ll i = n+<span class="number">1</span>;; i++)<span class="comment">//枚举第m个</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> all=<span class="number">2</span>*n;</span><br><span class="line">        <span class="type">bool</span> flag=<span class="literal">true</span>;</span><br><span class="line">        ll l=<span class="number">0</span>;    </span><br><span class="line">        <span class="keyword">while</span> (all&gt;n)</span><br><span class="line">        &#123;</span><br><span class="line">            l=(l+i<span class="number">-1</span>)%all;</span><br><span class="line">            <span class="keyword">if</span> (l &lt; n)</span><br><span class="line">            &#123;</span><br><span class="line">                flag=<span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            all--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag==<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    ll a[<span class="number">14</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">14</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        a[i]=<span class="built_in">getf</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n) &amp;&amp; n!=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;a[n]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="3-数学、字符串-B-Number-Sequence"><a href="#3-数学、字符串-B-Number-Sequence" class="headerlink" title="3.数学、字符串 - B - Number Sequence"></a>3.数学、字符串 - B - Number Sequence</h2><h3 id="题目标签-2"><a href="#题目标签-2" class="headerlink" title="题目标签"></a>题目标签</h3><p>数学；打表</p><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>给出A，B，N。根据给出的公式:</p><p>$f(1) = 1, f(2) = 1, f(n) = (A <em> f(n - 1) + B </em> f(n - 2)) mod 7$</p><p>求出f(N)</p><h3 id="题目解析-2"><a href="#题目解析-2" class="headerlink" title="题目解析"></a>题目解析</h3><p>若使用传统方式一直递推，由于数据量过大，会导致最终超时。</p><p>对小的数据进行打表，发现f(x)呈现一个循环，只需求出循环的循环节，再对N取模，即可求出f(n)</p><p>根据同余定理，f(n)有7*7种取得方式，所以循环最多有49种情况，只需打表打至49个就可以了，甚至不需要求出循环节，只需要让其对49取余，超出循环节的部分也可以得到</p><h3 id="通过代码-2"><a href="#通过代码-2" class="headerlink" title="通过代码"></a>通过代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxnum 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 1000000007</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// freopen(&quot;1output.out&quot;,&quot;w&quot;,stdout);</span></span><br><span class="line">    <span class="comment">// freopen(&quot;1input.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">    <span class="type">int</span> a,b;</span><br><span class="line">    ll q;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ll f[<span class="number">60</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        f[<span class="number">1</span>]=<span class="number">1</span>;f[<span class="number">2</span>]=<span class="number">1</span>;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b&gt;&gt;q;</span><br><span class="line">        <span class="keyword">if</span> (a==<span class="number">0</span> &amp;&amp; b==<span class="number">0</span> &amp;&amp; q==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">3</span>; i &lt; <span class="number">55</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            f[i]=((f[i<span class="number">-1</span>]*(a))+(f[i<span class="number">-2</span>]*(b)))%<span class="number">7</span>;<span class="comment">//公式递推打表</span></span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;f[q%<span class="number">49</span>];</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-枚举算法练习-G-Ants"><a href="#4-枚举算法练习-G-Ants" class="headerlink" title="4.枚举算法练习 - G - Ants"></a>4.枚举算法练习 - G - Ants</h2><h3 id="题目标签-3"><a href="#题目标签-3" class="headerlink" title="题目标签"></a>题目标签</h3><p>思维</p><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><p>一个树枝长lcm，上面有n个蚂蚁，蚂蚁以1cm/s的速度运动，蚂蚁相撞会往反方向走，给出n个蚂蚁的位置，但是不知道每只蚂蚁运动的方向，求出每个样例中，最后一只蚂蚁掉落的时间的最大值和最小值</p><h3 id="题目解析-3"><a href="#题目解析-3" class="headerlink" title="题目解析"></a>题目解析</h3><p>如果单纯的枚举，则情况会变得非常复杂，并且没有蚂蚁数量是动态的很难用n个for循环嵌套</p><p>即使用搜索也没有给出方向。</p><p>而其实这题是考验我们的思维能力，两只蚂蚁相撞，再往反方向走，其实就是可以看成蚂蚁一直往一个方向走。由此题目就变得非常简单，只需要根据距离，不断比较，求出最大和最小的最后一只蚂蚁掉落时间即可</p><h3 id="通过代码-3"><a href="#通过代码-3" class="headerlink" title="通过代码"></a>通过代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> max(x, y) x &gt; y ? x : y</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> min(x, y) x &lt; y ? x : y</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxnum 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 1000000007</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t;cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span> (t--)</span><br><span class="line">    &#123;</span><br><span class="line">        ll l;<span class="type">int</span> n;</span><br><span class="line">        cin&gt;&gt;l&gt;&gt;n;</span><br><span class="line">        ll dis[<span class="number">999999</span>]=&#123;<span class="number">0</span>&#125;;<span class="comment">//初始化</span></span><br><span class="line">        ll minn=<span class="number">-1</span>;</span><br><span class="line">        ll maxn=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;   </span><br><span class="line">            cin&gt;&gt;dis[i];</span><br><span class="line">            <span class="type">int</span> fl,fr;</span><br><span class="line">            fl=l-dis[i];fr=dis[i];</span><br><span class="line">            <span class="type">int</span> mi=<span class="built_in">min</span>(fl,fr);</span><br><span class="line">            <span class="type">int</span> ma=<span class="built_in">max</span>(fl,fr);</span><br><span class="line">            minn=<span class="built_in">max</span>(minn,mi);<span class="comment">//求出最小值，虽然是最小值，但是也是最后一个的最小值，所以是max</span></span><br><span class="line">            maxn=<span class="built_in">max</span>(maxn,ma);<span class="comment">//求出最大值</span></span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;minn&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;maxn&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-AtCoder-Regular-Contest-144-A-Digit-Sum-of-2x"><a href="#5-AtCoder-Regular-Contest-144-A-Digit-Sum-of-2x" class="headerlink" title="5.AtCoder Regular Contest 144 - A -Digit Sum of 2x"></a>5.AtCoder Regular Contest 144 - A -<strong>Digit Sum of 2x</strong></h2><h3 id="题目标签-4"><a href="#题目标签-4" class="headerlink" title="题目标签"></a>题目标签</h3><p>思维；数学</p><h3 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h3><p>给出函数f(n)，即求一个数的各个位数的和</p><p>如$f(144)=1+4+4=9$</p><p>给出一个正整数N，找到M使得$f(x)=N$ and$f (2x)=M$ ,M有多个答案，要求找到最大的</p><p>再找出一个x，使得$f(x)=N$ and$f (2x)=M$ ,x有多个答案要求找出最小的</p><h3 id="题目解析-4"><a href="#题目解析-4" class="headerlink" title="题目解析"></a>题目解析</h3><p>如果直接进行打表，问题将变得非常复杂。</p><p>此时分析题面，发现要求如果2*x中有x的某一位&gt;5，则会导致2x，中的该为进位，导致和变小，所以要求找到的x的每一位都必须为小于5，而每一位都小于5，就能保证该数的2倍的各位求和不会变小，所以M=2N</p><p>接下来要求找到能够组成M的最小的数x</p><p>同上定理，要保证每个位的数都小于5，而小于5的数必须保证为最大，这样保证和不变的情况下，分出的位数为最小，这样求能求得的x才为最小的x。</p><p>所以只要把M分解为k个4和分不下去后余下的一个数即可</p><h3 id="通过代码-4"><a href="#通过代码-4" class="headerlink" title="通过代码"></a>通过代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxnum 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 1000000007</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ios::sync_with_stdio(false);</span></span><br><span class="line">    <span class="comment">// cin.tie(0);</span></span><br><span class="line">    <span class="comment">// freopen(&quot;3output.out&quot;,&quot;w&quot;,stdout);</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// freopen(&quot;1input.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="type">int</span> t=n%<span class="number">4</span>;<span class="comment">//余下的数</span></span><br><span class="line">    <span class="type">int</span> k=n/<span class="number">4</span>;<span class="comment">//有k个4</span></span><br><span class="line">    string s;</span><br><span class="line">    <span class="keyword">if</span>(t!=<span class="number">0</span>)&#123;</span><br><span class="line">        s+=<span class="built_in">char</span>(t+<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    &#125;<span class="comment">//如果余下的不是零，则再最后加上这个余下的数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        s+=<span class="string">&#x27;4&#x27;</span>;<span class="comment">//加上k个4</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="number">2</span>*n&lt;&lt;endl&lt;&lt;s;</span><br><span class="line">    <span class="comment">// printf(&quot;Time used = %.2lf\n&quot;, (double)clock() / CLOCKS_PER_SEC);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法周记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法学习日志01-前缀和与差分</title>
      <link href="/2022/01/20/%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86/"/>
      <url>/2022/01/20/%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86/</url>
      
        <content type="html"><![CDATA[<h1 id="前缀和与差分"><a href="#前缀和与差分" class="headerlink" title="前缀和与差分"></a>前缀和与差分</h1><h3 id="0-核心代码"><a href="#0-核心代码" class="headerlink" title="0.核心代码"></a>0.核心代码</h3><p>一维</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">a[i]=a[i<span class="number">-1</span>]+diff[i];</span><br><span class="line"></span><br><span class="line">s[i]=s[i<span class="number">-1</span>]+a[i];</span><br><span class="line"></span><br><span class="line">sum[l,r]= S[r]-S[l<span class="number">-1</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//区间a[l,r]都加x：</span></span><br><span class="line">a[l]+=x;</span><br><span class="line">a[r+<span class="number">1</span>]+=-x;</span><br></pre></td></tr></table></figure><p>二维</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">s[i][j]=a[i][j]+s[i][j<span class="number">-1</span>]+s[i<span class="number">-1</span>][j<span class="number">-1</span>]-s[i<span class="number">-1</span>][j<span class="number">-1</span>];<span class="comment">//前缀和</span></span><br><span class="line"></span><br><span class="line">d[i][j]=a[i][j]-a[i<span class="number">-1</span>][j]-a[i][j<span class="number">-1</span>]+a[i<span class="number">-1</span>][j<span class="number">-1</span>];<span class="comment">//求差分数组</span></span><br><span class="line"></span><br><span class="line">sum[i1j1,i2j2]=s[i2][j2]-s[i1<span class="number">-1</span>][j2]-s[i2][j1<span class="number">-1</span>]+s[i1<span class="number">-1</span>][j1<span class="number">-1</span>]<span class="comment">//求矩阵区间的总和.i1j1为矩阵左上角的点，i2j2位矩阵右下角的点</span></span><br></pre></td></tr></table></figure><h3 id="1-前缀和定义"><a href="#1-前缀和定义" class="headerlink" title="1.前缀和定义"></a>1.前缀和定义</h3><p><img src="/img/code/image-20220117153015275.png" alt="image-20220117153015275"></p><ul><li>对于q次询问</li><li>先把s[i]求出，随后求sum[l,r]，就可以降低时间复杂度。一次询问复杂度为O(1)。总复杂度成为O(n)</li><li>若用遍历，每次询问sum[l,r]的复杂度为O(n).总共则是O(q*n)</li></ul><h3 id="2-差分"><a href="#2-差分" class="headerlink" title="2.差分"></a>2.<strong>差分</strong></h3><p><img src="/img/code/image-20220117165258915.png" alt="image-20220117165258915"></p><ul><li><strong>问题</strong>：<br>对于一个数组a的一个区间[L,R]，要求全部加x。<ul><li>一般方法：遍历数组加上x。单次的复杂度为O(n)，总为O(mn),若n和m过大就会超时。</li><li>采用==差分法==：对这个数组的差分数组diff[]。对diff[L]+x，对diff[R+1]-x，再对该差分数组进行前缀和运算。//<code>或者a[i]=a[i-1]+diff[i]</code> 便可以求出加完之后的数组。</li></ul></li></ul><blockquote><p>多次区间修改也是一样。</p></blockquote><ul><li><p><strong>差分数组的由来</strong><br>差分数组是原数组前缀和的逆运算，即a[i]-a[i-1]=diff[i]</p><p><img src="/img/code/image-20220117170507308.png" alt="image-20220117170507308"></p></li><li><p>一个点的值就是会影响它的差分数组的前缀和</p></li><li><p>差分数组的前缀和=原数组</p></li><li><p>直接用差分数组b[n]求a[n]的前缀和<img src="/img/code/image-20220119003537519.png" alt="image-20220119003537519"></p></li></ul><h3 id="3-扩展到二维"><a href="#3-扩展到二维" class="headerlink" title="3.扩展到二维"></a>3.扩展到二维</h3><ul><li><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4></li></ul><h4 id=""><a href="#" class="headerlink" title=""></a><img src="/img/code/image-20220117160941693.png" alt="image-20220117160941693"></h4><p>也可以是<code>a[i][j]=a[i-1][j]+a[i][j-1]-a[i-1][j-1]+a[i][j]</code>直接将原数组代替</p><blockquote><p>求红色矩阵，容斥原理：黑-绿-绿+蓝</p></blockquote><p><img src="/img/code/image-20220120225815197.png" alt="image-20220120225815197"></p><ul><li><h4 id="二维差分"><a href="#二维差分" class="headerlink" title="二维差分"></a>二维差分</h4></li></ul><p><img src="/img/code/image-20220117215558796.png" alt="image-20220117215558796"></p><p><strong>定理</strong>：在红色处+x，右下角都会+c</p><p><strong>推导：</strong>想在一个区间+c</p><p><img src="/img/code/image-20220117220306667.png" alt="image-20220117220306667"></p><ul><li>例题</li></ul><p><img src="/img/code/image-20220120154019142.png" alt="image-20220120154019142"></p><ul><li>题解</li></ul><p><img src="/img/code/image-20220120154320375.png" alt="image-20220120154320375"></p><h3 id="4题目"><a href="#4题目" class="headerlink" title="4题目"></a>4题目</h3><h4 id="1-洛谷P1387-最大正方形"><a href="#1-洛谷P1387-最大正方形" class="headerlink" title="1.洛谷P1387 最大正方形"></a><a href="https://www.luogu.com.cn/problem/P1387">1.洛谷P1387 最大正方形</a></h4><p><img src="/img/code/image-20220120230043224.png" alt="image-20220120230043224"></p><ul><li><strong>思路</strong></li></ul><p>采用暴力+前缀和</p><p>从大到小的边长遍历，并遍历数组的各个边长的矩阵的sum是否为边长^2</p><ul><li><strong>题解</strong></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MIN(x,y) ((x)&lt;(y)?(x):(y))</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="type">int</span> a[n+<span class="number">1</span>][m+<span class="number">1</span>];</span><br><span class="line"><span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="built_in">sizeof</span>(a));</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>; j&lt;=m; j++) &#123;</span><br><span class="line">cin&gt;&gt;a[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">//计算前缀和</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>; j&lt;=m; j++) &#123;</span><br><span class="line">a[i][j]=a[i][j]+a[i<span class="number">-1</span>][j]+a[i][j<span class="number">-1</span>]-a[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> max=<span class="number">0</span>;</span><br><span class="line"><span class="type">bool</span> flag=<span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> l=<span class="built_in">MIN</span>(m, n); l&gt;<span class="number">1</span>; l--) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=l<span class="number">-1</span>;i&lt;=n ; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j=l<span class="number">-1</span>; j&lt;=m; j++) &#123;</span><br><span class="line"><span class="type">int</span> s=<span class="built_in">pow</span>(l, <span class="number">2</span>);</span><br><span class="line"><span class="type">int</span> o=a[i][j]-a[i][j-l]-a[i-l][j]+a[i-l][j-l];<span class="comment">//计算矩阵区域的值的总和</span></span><br><span class="line"><span class="keyword">if</span> (s==o) &#123;</span><br><span class="line">max=l;</span><br><span class="line">flag=<span class="literal">true</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (flag==<span class="literal">true</span>) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (flag==<span class="literal">true</span>) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (flag==<span class="literal">false</span>) &#123;</span><br><span class="line">cout&lt;&lt;<span class="number">1</span>&lt;&lt;endl;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">cout&lt;&lt;max&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前缀和 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记录基于hexo的个人博客搭建（未完成）</title>
      <link href="/2021/09/04/%E8%AE%B0%E5%BD%95hexo%E6%90%AD%E5%BB%BA%E4%B8%8E%E4%BC%98%E5%8C%96/"/>
      <url>/2021/09/04/%E8%AE%B0%E5%BD%95hexo%E6%90%AD%E5%BB%BA%E4%B8%8E%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<span class='p large gray'>记录本次个人博客的搭建</span><p>最近几天心血来潮，突发奇想，想也搭建一个个人博客。便从网上搜寻了许多资料与教程。网上教程良莠不齐，或多或少都有不完整，导致终端报错的也是层出不穷。使得本次搭建的过程费时费力。但是在部署完毕，搭建成功的那一刻，成就感还是满满的。所以在此记录一下我的搭建过程，也给同样需要搭建网站的小伙伴指路。</p><h3 id="1-安装node-js"><a href="#1-安装node-js" class="headerlink" title="1.安装node.js"></a>1.安装node.js</h3><h3 id="2-安装git"><a href="#2-安装git" class="headerlink" title="2.安装git"></a>2.安装git</h3><p>添加到环境变量</p><h3 id="3-配置git用户名"><a href="#3-配置git用户名" class="headerlink" title="3.配置git用户名"></a>3.配置git用户名</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;xxx&quot;</span><br><span class="line">git config --global user.email  &quot;xxxxxxxxxxxxx@xxx.com&quot;</span><br></pre></td></tr></table></figure><h3 id="4-配置ssh"><a href="#4-配置ssh" class="headerlink" title="4.配置ssh"></a>4.配置ssh</h3><ul><li><p><strong>一定要知道ssh key的配置是针对每台主机的！</strong>，比如我在某台主机上操作git和我的远程仓库，想要push时不输入账号密码，走ssh协议，就需要配置ssh key，放上去的key是<strong>当前主机的ssh公钥</strong>。那么如果我换了一台其他主机，想要实现无密登录，也就需要重新配置</p></li><li><p>配置的时候是把当前主机的公钥放到了你的github账号下，相当于当前主机和你的账号做了一个关联，你在这台主机上已经登录了你的账号，此时此刻github认为是该账号主人在操作这台主机，在配置ssh后就信任该主机了。所以下次在使用git的时候即使没有登录github，也能直接从本地push代码到远程了。当然这里不要混淆了，你不能随意push你的代码到任何仓库，你只能push到你自己的仓库或者其他你有权限的仓库！</p></li><li><p>验证原理<br>SSH登录安全性由非对称加密保证，产生密钥时，一次产生两个密钥，一个公钥，一个私钥，在git中一般命名为id_rsa.pub, id_rsa。</p></li><li><p>那么如何使用生成的一个私钥一个公钥进行验证呢？</p><ul><li>本地生成一个密钥对，其中公钥放到远程主机，私钥保存在本地<br>当本地主机需要登录远程主机时，本地主机向远程主机发送一个登录请求，远程收到消息后，随机生成一个字符串并用公钥加密，发回给本地。本地拿到该字符串，用存放在本地的私钥进行解密，再次发送到远程，远程比对该解密后的字符串与源字符串是否等同，如果等同则认证成功。            </li></ul></li></ul><p>==遇到问题：==</p><blockquote><p>The authenticity of host ‘github.com (20.205.243.166)’ can’t be established.<br>ECDSA key fingerprint is SHA256:p2QAMXNIC1TJYWeIOttrVc98/R1BUFWu3/LiyKgUfQM.</p><p>缺少文件—-回复yes</p><p>dos系统不能用cat</p><p>解决：使用type命令</p></blockquote><h3 id="5-npm"><a href="#5-npm" class="headerlink" title="5.npm"></a>5.npm</h3><p>node自带的</p><p>更换为淘宝源</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm config set registry https://registry.npm.taobao.org/</span><br></pre></td></tr></table></figure><p>cnpm</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install cnpm -g</span><br><span class="line">npm install nrm -g</span><br></pre></td></tr></table></figure><h3 id="恢复"><a href="#恢复" class="headerlink" title="恢复"></a>恢复</h3><p>迁移数据除了node_modules</p><p>进入文件夹，安装依赖恢复node_modules</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install</span><br><span class="line">npm install hexo-deployer-git --save  # 文章部署到 git 的模块</span><br></pre></td></tr></table></figure><p>恢复插件</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">外挂标签</span></span><br><span class="line">npm install hexo-butterfly-tag-plugins-plus --save</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">更换markdown渲染插件</span></span><br><span class="line">npm uninstall hexo-renderer-marked --save</span><br><span class="line">npm install hexo-renderer-kramed --save</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">更换后，还要配置占点信息</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><p>加速:</p><p>gulp压缩</p><p>图床</p><p>vercel</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>测试文档</title>
      <link href="/2021/09/03/%E6%B5%8B%E8%AF%95%E6%96%87%E6%A1%A3/"/>
      <url>/2021/09/03/%E6%B5%8B%E8%AF%95%E6%96%87%E6%A1%A3/</url>
      
        <content type="html"><![CDATA[<span class='p large center'>这是一个用于测试的文档</span> <h1 id="1-文字测试"><a href="#1-文字测试" class="headerlink" title="1.文字测试"></a>1.文字测试</h1><h2 id="啦啦啦啦-我是大帅哥"><a href="#啦啦啦啦-我是大帅哥" class="headerlink" title="啦啦啦啦 我是大帅哥"></a>啦啦啦啦 我是大帅哥</h2><h3 id="啦啦啦啦-我是大帅哥-1"><a href="#啦啦啦啦-我是大帅哥-1" class="headerlink" title="啦啦啦啦 我是大帅哥"></a>啦啦啦啦 我是大帅哥</h3><h5 id="啦啦啦啦-我是大帅哥-2"><a href="#啦啦啦啦-我是大帅哥-2" class="headerlink" title="啦啦啦啦 我是大帅哥"></a>啦啦啦啦 我是大帅哥</h5><h6 id="啦啦啦啦-我是大帅哥-3"><a href="#啦啦啦啦-我是大帅哥-3" class="headerlink" title="啦啦啦啦 我是大帅哥"></a>啦啦啦啦 我是大帅哥</h6><h1 id="2-图片测试"><a href="#2-图片测试" class="headerlink" title="2.图片测试"></a>2.图片测试</h1><span class='p h4 gray'>示例插入图片方法</span>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">![描述]（地址)</span><br></pre></td></tr></table></figure><ul><li>插入图片可用网络地址<br><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fmmbiz.qpic.cn%2Fmmbiz_jpg%2FFM5xmuv1Zqpg7ETtMgsqicgS3IDxZNogtrTT7L54VEfX0B3ttFsfaruhh16Mp2fR5mSbW6AOZczUiaZp3OiaibYicQg%2F640%3Fwx_fmt%3Djpeg&amp;refer=http%3A%2F%2Fmmbiz.qpic.cn&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1633274795&amp;t=088f07f94b97a015eb32670aa3d8a4e2" alt="偷笑"></li><li>插入图片可用本地地址，默认在/theme/source/img 中，输入只需/img。<br>但是hexo好像不支持添加css，改不了大小<br><img src="/img/shagou.jpg" alt="偷笑的傻狗"></li><li>也可插入HTML语言，可修改大小，样式等等<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;图片地址&quot;</span> <span class="attr">width</span> = <span class="string">&quot;大小&quot;</span> <span class="attr">height</span> = <span class="string">&quot;大小&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;图片描述&quot;</span> <span class="attr">align</span>=<span class="string">对齐</span> /&gt;</span></span><br></pre></td></tr></table></figure><img src="/img/shagou.png" width = "300" height = "300" alt="偷笑的傻狗" align=center /></li></ul><span class='p h4 gray'>图片墙</span> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% gallery %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% endgallery %&#125;</span><br></pre></td></tr></table></figure><div class="fj-gallery"><p><img src="/img/home.png" alt=""><br><img src="/img/noritake/1.jpg" alt=""><br><img src="/img/noritake/3.jpeg" alt=""><br><img src="/img/noritake/5.jpeg" alt=""><br><img src="/img/noritake/7.jpg" alt=""><br><img src="/img/noritake/8.jpeg" alt=""><br><img src="/img/noritake/9.jpg" alt=""><br><img src="/img/noritake/10.jpg" alt=""></p>          </div><h1 id="3-代码测试"><a href="#3-代码测试" class="headerlink" title="3.代码测试"></a>3.代码测试</h1><span class='p h4 gray'>短代码</span> <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span class='p h4 gray'>长代码</span>  <p>测试是否有展开按钮<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sc</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> n, <span class="type">char</span> a[])</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> a[<span class="number">80</span>];</span><br><span class="line">    <span class="type">char</span> b[<span class="number">80</span>];</span><br><span class="line">    <span class="type">char</span> *c;</span><br><span class="line">    <span class="type">int</span> d;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%[^\n]%*c&quot;</span>, a);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%[^\n]%*c&quot;</span>, b);</span><br><span class="line">    <span class="type">int</span> a1,b1,cnt;</span><br><span class="line">    a1=<span class="built_in">strlen</span>(a);</span><br><span class="line">    b1=<span class="built_in">strlen</span>(b);</span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line">    <span class="keyword">while</span> (c)</span><br><span class="line">    &#123;</span><br><span class="line">    c=<span class="built_in">strstr</span>(a,b);</span><br><span class="line">    d=c-a;</span><br><span class="line">    sc(d,b1,a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sc</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> n, <span class="type">char</span> a[])</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> j;</span><br><span class="line"><span class="keyword">for</span> ( j=i+n;j&lt;<span class="number">81</span> ; i++)</span><br><span class="line">&#123;</span><br><span class="line">a[i]=a[i+n];</span><br><span class="line">j=i+n;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="4-地图测试"><a href="#4-地图测试" class="headerlink" title="4.地图测试"></a>4.地图测试</h1><span class='p h4 gray'>语法</span> <p><a href="https://guole.fun/posts/41887/#参数取值">参数参考地址</a><br><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% + 标签值 + 经度 + 纬度 + 文本 + 缩放等级 + 宽 + 高 + 默认图层 + %&#125;</span><br></pre></td></tr></table></figure><br><div class="tabs" id="地图"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#地图-1">混合</button></li><li class="tab"><button type="button" data-href="#地图-2">openstreet</button></li><li class="tab"><button type="button" data-href="#地图-3">高德</button></li><li class="tab"><button type="button" data-href="#地图-4">geoq</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="地图-1"><p><span class='p h4 gray'>混合</span> </p><p><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-tag-map/lib/leaflet@1.7.1.css"><script data-pjax src="https://cdn.jsdelivr.net/npm/hexo-tag-map/lib/leaflet@1.7.1.js"></script><script data-pjax src="https://cdn.jsdelivr.net/npm/hexo-tag-map/lib/leaflet.ChineseTmsProviders@1.0.4.js"></script><div class="map-box"><div id="map-121.5025-31.237015" style="max-width:100%; height:360px;display: block;margin:0 auto;z-index:1;border-radius: 5px;"></div>&lt;/div&gt;<script type="text/javascript">var normalm=L.tileLayer.chinaProvider('GaoDe.Normal.Map',{maxZoom:20,minZoom:1,attribution:'Amap'});var imgm=L.tileLayer.chinaProvider('GaoDe.Satellite.Map',{maxZoom:20,minZoom:1,attribution:'Amap'});var imga=L.tileLayer.chinaProvider('GaoDe.Satellite.Annotion',{maxZoom:20,minZoom:1,attribution:'Amap'});var normalMap=L.tileLayer.chinaProvider('Google.Normal.Map',{maxZoom:20,minZoom:1,attribution:'Google Maps'}),satelliteMap=L.tileLayer.chinaProvider('Google.Satellite.Map',{maxZoom:21,minZoom:1,attribution:'Google Maps'});routeMap=L.tileLayer.chinaProvider('Google.Satellite.Annotion',{maxZoom:21,minZoom:1});var normalMap=L.tileLayer.chinaProvider('Google.Normal.Map',{maxZoom:21,minZoom:1,attribution:'Google Maps'}),satelliteMap=L.tileLayer.chinaProvider('Google.Satellite.Map',{maxZoom:21,minZoom:1,attribution:'Google Maps'}),routeMap=L.tileLayer.chinaProvider('Google.Satellite.Annotion',{maxZoom:21,minZoom:1,attribution:'Google Maps'});var normalm1=L.tileLayer.chinaProvider('Geoq.Normal.Map',{maxZoom:21,minZoom:1,attribution:'GeoQ'});var normal=L.layerGroup([normalm]),image=L.layerGroup([imgm,imga]);var baseLayers={"高德地图":normal,"智图地图":normalm1,"谷歌地图":normalMap,"高德卫星地图":imgm,"谷歌卫星地图":satelliteMap,"高德卫星标注":image,"谷歌卫星标注":routeMap};var mymap=L.map('map-121.5025-31.237015',{center:[31.237015,121.5025],zoom:14,layers:[normal],zoomControl:false});L.control.layers(baseLayers,null).addTo(mymap);L.control.zoom({zoomInTitle:'放大',zoomOutTitle:'缩小'}).addTo(mymap);var marker = L.marker(['31.237015','121.5025']).addTo(mymap);marker.bindPopup("这里是上海陆家嘴，国家级金融中心!").openPopup();</script></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="地图-2"><p><span class='p h4 gray'>openstreet</span> </p><p><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-tag-map/lib/leaflet@1.7.1.css"><script data-pjax src="https://cdn.jsdelivr.net/npm/hexo-tag-map/lib/leaflet@1.7.1.js"></script><div class="map-box"><div id="openstreetMap-120.101101-30.239119" style="max-width:100%; height:360px;display: block;margin:0 auto;z-index:1;border-radius: 5px;"></div></div><script>var mymap = L.map('openstreetMap-120.101101-30.239119', { attributionControl:false }).setView(['30.239119','120.101101'],16);L.tileLayer('http://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {}).addTo(mymap);var marker = L.marker(['30.239119','120.101101']).addTo(mymap);marker.bindPopup("这里是西湖灵隐寺，据说求姻缘很灵验哦!").openPopup();</script></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="地图-3"><p><span class='p h4 gray'>高德</span> </p><p><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-tag-map/lib/leaflet@1.7.1.css"><script data-pjax src="https://cdn.jsdelivr.net/npm/hexo-tag-map/lib/leaflet@1.7.1.js"></script><script data-pjax src="https://cdn.jsdelivr.net/npm/hexo-tag-map/lib/leaflet.ChineseTmsProviders@1.0.4.js"></script><div class="map-box"><div id="gaodeMap-116.397451-39.909187" style="max-width:100%; height:360px;display: block;margin:0 auto;z-index:1;border-radius: 5px;"></div>&lt;/div&gt;<script type="text/javascript">var normalm=L.tileLayer.chinaProvider('GaoDe.Normal.Map',{maxZoom:20,minZoom:1,attribution:'Amap'});var imgm=L.tileLayer.chinaProvider('GaoDe.Satellite.Map',{maxZoom:20,minZoom:1,attribution:'Amap'});var imga=L.tileLayer.chinaProvider('GaoDe.Satellite.Annotion',{maxZoom:20,minZoom:1,attribution:'Amap'});var normal=L.layerGroup([normalm]),image=L.layerGroup([imgm,imga]);var baseLayers={"高德地图":normal,"高德卫星地图":imgm,"高德卫星标注":image};var mymap=L.map('gaodeMap-116.397451-39.909187',{center:[39.909187,116.397451],zoom:17,layers:[normal],zoomControl:false});L.control.layers(baseLayers,null).addTo(mymap);L.control.zoom({zoomInTitle:'放大',zoomOutTitle:'缩小'}).addTo(mymap);var marker = L.marker(['39.909187','116.397451']).addTo(mymap);marker.bindPopup("这里是北京天安门，世界上最大的城市中心广场！").openPopup();</script></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="地图-4"><p><span class='p h4 gray'>geoq</span> </p><p><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-tag-map/lib/leaflet@1.7.1.css"><script data-pjax src="https://cdn.jsdelivr.net/npm/hexo-tag-map/lib/leaflet@1.7.1.js"></script><script data-pjax src="https://cdn.jsdelivr.net/npm/hexo-tag-map/lib/leaflet.ChineseTmsProviders@1.0.4.js"></script><div id="geoqMap-115.542328-34.825508" style="max-width:90%; height:320px;display: block;margin:0 auto;z-index:1;border-radius: 5px;"></div><script type="text/javascript">var normalm1=L.tileLayer.chinaProvider('Geoq.Normal.Map',{maxZoom:20,minZoom:1,attribution:'GeoQ'});var normalm2=L.tileLayer.chinaProvider('Geoq.Normal.PurplishBlue',{maxZoom:20,minZoom:1,attribution:'GeoQ'});var normalm3=L.tileLayer.chinaProvider('Geoq.Normal.Gray',{maxZoom:20,minZoom:1,attribution:'GeoQ'});var normalm4=L.tileLayer.chinaProvider('Geoq.Normal.Warm',{maxZoom:20,minZoom:1,attribution:'GeoQ'});var normalm5=L.tileLayer.chinaProvider('Geoq.Theme.Hydro',{maxZoom:20,minZoom:1,attribution:'GeoQ'});var normal=L.layerGroup([normalm1,normalm2,normalm3,normalm4,normalm5]);var baseLayers={"智图地图":normalm1,"午夜蓝":normalm2,"灰色":normalm3,"暖色":normalm4,"水系":normalm5};var mymap=L.map("geoqMap-115.542328-34.825508",{center:[34.825508,115.542328],zoom:12,layers:[normalm1],zoomControl:false});L.control.layers(baseLayers,null).addTo(mymap);L.control.zoom({zoomInTitle:'放大',zoomOutTitle:'缩小'}).addTo(mymap);var marker = L.marker(['34.825508','115.542328']).addTo(mymap);marker.bindPopup("这里是山东菏泽曹县，牛批666我的宝贝！").openPopup();</script></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div></p><h1 id="5-图标测试"><a href="#5-图标测试" class="headerlink" title="5.图标测试"></a>5.图标测试</h1><p>awesomeicon自带图标<br><i class="fas fa-tv-retro"></i>  </p><p>阿里图标<br><svg class="icon" style="width:1em; height:1em" aria-hidden="true"><use xlink:href="#icon-rat_zi"></use></svg></p><svg class="icon" style="width:1em; height:1em" aria-hidden="true"><use xlink:href="#icon-bilibili-line"></use></svg><svg class="icon" style="width:5em; height:5em" aria-hidden="true"><use xlink:href="#icon-bilibili-fill-copy"></use></svg><svg class="icon" style="width:3em; height:3em" aria-hidden="true"><use xlink:href="#icon-zhaoxiang"></use></svg><h1 id="6-markdown样式测试"><a href="#6-markdown样式测试" class="headerlink" title="6.markdown样式测试"></a>6.markdown样式测试</h1><h2 id="1-删除线"><a href="#1-删除线" class="headerlink" title="1.删除线"></a>1.<del>删除线</del></h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">~~xxx~~</span><br></pre></td></tr></table></figure><h2 id="2-斜体"><a href="#2-斜体" class="headerlink" title="2.斜体"></a>2.<em>斜体</em></h2><h2 id="3-下划线"><a href="#3-下划线" class="headerlink" title="3.下划线"></a>3.<u>下划线</u></h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">u</span>&gt;</span>xxx<span class="tag">&lt;/<span class="name">u</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="4-粗斜体"><a href="#4-粗斜体" class="headerlink" title="4.粗斜体"></a>4.<strong><em>粗斜体</em></strong></h2><p>三个* 包裹</p><h2 id="5-表格"><a href="#5-表格" class="headerlink" title="5.表格"></a>5.表格</h2><div class="table-container"><table><thead><tr><th>这瓜多少钱一斤啊</th><th>价钱</th></tr></thead><tbody><tr><td>1斤</td><td>2块</td></tr><tr><td>15斤</td><td>30块</td></tr></tbody></table></div><span class='p h4 gray'>写法</span>    <figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">| Syntax | Description |  </span><br><span class="line">| ----------- | ----------- |  </span><br><span class="line">| Header | Title |  </span><br><span class="line">| Paragraph | Text |  </span><br></pre></td></tr></table></figure><h2 id="6-脚注"><a href="#6-脚注" class="headerlink" title="6.脚注"></a>6.脚注</h2><p>[^ 数字 ]<br>Here’s a sentence with a footnote.<sup><a href="#fn_1" id="reffn_1">1</a></sup></p><p><sup><a href="#fn_1" id="reffn_1">1</a></sup>:This is the footnote.</p><h2 id="7-引用"><a href="#7-引用" class="headerlink" title="7.引用"></a>7.引用</h2><p>用&gt;放在开头 可嵌套 </p><blockquote><p>这是一条引用</p><blockquote><p>这是引用的引用</p><blockquote><p>这是引用的引用  </p></blockquote></blockquote></blockquote><h2 id="8-标题"><a href="#8-标题" class="headerlink" title="8.标题"></a>8.标题</h2><div class="tabs" id="标题"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#标题-1">效果</button></li><li class="tab"><button type="button" data-href="#标题-2">代码</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="标题-1"><h2 id="小标题"><a href="#小标题" class="headerlink" title="小标题"></a>小标题</h2><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="标题-2"><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">小标题</span><br><span class="line">---</span><br><span class="line">大标题</span><br><span class="line">===</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="9-列表"><a href="#9-列表" class="headerlink" title="9.列表"></a>9.列表</h2><p>用+号或-号</p><ul><li>列表  <ul><li>嵌套列表<ul><li>只需加tab键</li></ul></li></ul></li></ul><h2 id="10-键盘-html标签"><a href="#10-键盘-html标签" class="headerlink" title="10.键盘(html标签)"></a>10.键盘(html标签)</h2><span class='p h4 gray'>语法</span>   <p>使用kbd的尖括号包裹</p><ul><li>使用 <kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>Del</kbd> 重启电脑</li></ul><h1 id=""><a href="#" class="headerlink" title=""></a><span class='p h1'>使用标签外挂</span></h1><h1 id="1-分栏-tabs"><a href="#1-分栏-tabs" class="headerlink" title="1.分栏 tabs"></a>1.分栏 tabs</h1><span class='p h4 gray'>用法</span> <div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab"><button type="button" data-href="#分栏-1">参数</button></li><li class="tab active"><button type="button" data-href="#分栏-2">语法</button></li></ul><div class="tab-contents"><div class="tab-item-content" id="分栏-1"><ol><li><p>Unique name:</p><p> 选项卡块标签的唯一名称，不带逗号。</p><p> 将在 #id 中用作每个标签及其索引号的前缀。</p><p> 如果名称中包含空格，则对于生成 #id，所有空格将由破折号代替。</p><p> 仅当前帖子 / 页面的 URL 必须是唯一的！</p></li><li><p>[index]:</p><p> 活动选项卡的索引号。</p><p> 如果未指定，将选择第一个标签（1）。</p><p> 如果 index 为 - 1，则不会选择任何选项卡。</p></li><li><p>[Tab caption]:</p><p> 当前选项卡的标题。<br> 如果未指定标题，则带有制表符索引后缀的唯一名称将用作制表符的标题。<br> 如果未指定标题，但指定了图标，则标题将为空。  </p></li><li>[@icon]:<br> FontAwesome 图标名称<br> （全名，看起来像 “fas fa-font”）<br> 可以指定带空格或不带空格；<br> 例如’Tab caption @icon’ 和 ‘Tab caption@icon’.</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content active" id="分栏-2"><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% tabs Unique name, [index] %&#125;</span><br><span class="line">&lt;!-- tab [Tab caption] [@icon] --&gt;</span><br><span class="line">Any content (support inline tags too).</span><br><span class="line">&lt;!-- endtab --\&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="2-折叠栏-folding"><a href="#2-折叠栏-folding" class="headerlink" title="2.折叠栏 folding"></a>2.折叠栏 folding</h1><span class='p h4 gray'>语法</span> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% folding 参数（可选）, 标题 %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% endfolding %&#125;</span><br></pre></td></tr></table></figure><span class='p h4 gray'>示例</span> <details class="folding-tag" red><summary> 图片测试 </summary>              <div class='content'>              <p><img src="/img/noritake/12.jpg" alt="haha"></p>              </div>            </details><details class="folding-tag" blue><summary> html图片测试 </summary>              <div class='content'>              <p><img src="/img/noritake/3.jpeg" ></p>              </div>            </details><details class="folding-tag" blue><summary> 文字测试 </summary>              <div class='content'>              <p class='p huge blue'>Hello</p>              </div>            </details><h1 id="3"><a href="#3" class="headerlink" title="3."></a>3.<psw>密码psw</psw></h1><div class="tabs" id="密码"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#密码-1">代码</button></li><li class="tab"><button type="button" data-href="#密码-2">效果</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="密码-1"><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">\\ &#123; % psw文本 % \\ &#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="密码-2"><psw>这是一个密码</psw><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="4-隐藏标签-hideblock"><a href="#4-隐藏标签-hideblock" class="headerlink" title="4.隐藏标签 hideblock"></a>4.隐藏标签 hideblock</h1><span class='p h4 gray'>语法</span> <p>inline<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% hideInline content,display,bg,color %&#125;</span><br></pre></td></tr></table></figure><br>block<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% hideBlock display,bg,color %&#125;</span><br><span class="line">content</span><br><span class="line">&#123;% endhideBlock %&#125;</span><br></pre></td></tr></table></figure><br>content 内容<br>dispaly 显示在外面的东西<br><span class='p h4 gray'>示例</span><br>猜谜语<br>哪個英文字母最酷？<br><span class="hide-inline"><button type="button" class="hide-button" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">因為西裝褲(C裝酷)</span></span>  </p><p>門裏站着一個人?<br><span class="hide-inline"><button type="button" class="hide-button" style="">Click  </button><span class="hide-content">閃</span></span><br>查看答案<br><div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>傻子，怎麼可能有答案</p></div></div></p><h1 id="5-注释-natation"><a href="#5-注释-natation" class="headerlink" title="5.注释 natation"></a>5.注释 natation</h1><span class='p h4 gray'>语法</span> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% nota [label] , [text] %&#125;</span><br></pre></td></tr></table></figure><span class='p h4 gray'>示例</span> <span class='nota' data-nota='可以看到注解内容出现在顶栏'>把鼠标移动到我上面试试</span><h1 id="6-行内文本-span"><a href="#6-行内文本-span" class="headerlink" title="6.行内文本 span"></a>6.行内文本 span</h1><span class='p h4 gray'>自定义颜色和大小文字 占用行距离</span>  <div class="tabs" id="彩色文字"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#彩色文字-1">语法</button></li><li class="tab"><button type="button" data-href="#彩色文字-2">参数</button></li><li class="tab"><button type="button" data-href="#彩色文字-3">效果</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="彩色文字-1"><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123; % span 样式参数(参数以空格划分), 文本内容 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="彩色文字-2"><ul><li>字体: logo, code</li><li>颜色: red,yellow,green,cyan,blue,gray</li><li>大小: small, h4, h3, h2, h1, large, huge,ultra  </li><li>对齐方向: left, center, right</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="彩色文字-3"><p>这是<span class='p small pink'>small</span>的效果<br>这是<span class='p h4 purple'>h4</span>的效果<br>这是<span class='p h3 green'>h3</span>的效果<br>这是<span class='p h2 gray'>h2</span>的效果<br>这是<span class='p h1 cyan'>h1</span>的效果<br>这是<span class='p center large blue'>blue</span>的效果<br>这是<span class='p red huge left'>红色</span>的效果<br>这是<span class='p ultra right yellow'>黄色</span>的效果   </p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="7-段落文本-p"><a href="#7-段落文本-p" class="headerlink" title="7.段落文本 p"></a>7.段落文本 p</h1><span class='p h4 gray'>自定义颜色和大小文字</span> <p>占用段落<br><div class="tabs" id="段落文字"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#段落文字-1">语法</button></li><li class="tab"><button type="button" data-href="#段落文字-2">参数</button></li><li class="tab"><button type="button" data-href="#段落文字-3">效果</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="段落文字-1"><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123; % p 样式参数(参数以空格划分), 文本内容 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="段落文字-2"><ul><li>字体: logo, code</li><li>颜色: red,yellow,green,cyan,blue,gray</li><li>大小: small, h4, h3, h2, h1, large, huge,ultra  </li><li>对齐方向: left, center, right</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="段落文字-3"><p>这是<p class='p small pink'>small</p>的效果<br>这是<p class='p h4 purple'>h4</p>的效果<br>这是<p class='p h3 green'>h3</p>的效果<br>这是<p class='p h2 gray'>h2</p>的效果<br>这是<p class='p h1 cyan'>h1</p>的效果<br>这是<p class='p center large blue'>blue</p>的效果<br>这是<p class='p red huge left'>红色</p>的效果<br>这是<p class='p ultra right yellow'>黄色</p>的效果   </p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div></p><h1 id="8-背景高亮-Label"><a href="#8-背景高亮-Label" class="headerlink" title="8.背景高亮 Label"></a>8.背景高亮 Label</h1><span class='p h4 gray'>语法</span> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% label text color %&#125;</span><br></pre></td></tr></table></figure><span class='p h4 gray'>示例</span> <p>大家<mark class="hl-label red">好</mark> ,<mark class="hl-label blue">我</mark> 是<mark class="hl-label yellow">超级</mark> 大<mark class="hl-label green">帅哥</mark> ，<mark class="hl-label purple">哈哈</mark> <mark class="hl-label oringe">哈哈</mark> <mark class="hl-label pink">哈哈</mark> <mark class="hl-label default">哈哈</mark> </p><h1 id="9-行内图片-inline"><a href="#9-行内图片-inline" class="headerlink" title="9.行内图片 inline"></a>9.行内图片 inline</h1><span class='p h4 gray'>语法</span> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% inlineimage 图片链接, height=高度（可选） %&#125;</span><br></pre></td></tr></table></figure><span class='p h4 gray'>示例</span> <p>这是 <img no-lazy class="inline" src="\img\noritake\8.jpeg" style="height: 100px;"/> 一段话。</p><p>这又是 <img no-lazy class="inline" src="\img\noritake\da.jpg" style="height: 70px;"/> 一段话。</p><h1 id="10-便条-note"><a href="#10-便条-note" class="headerlink" title="10.便条 note"></a>10.便条 note</h1><span class='p h4 gray'>用法</span> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% note [class]/[color] [no-icon]/[icon] [style] %&#125;</span><br><span class="line">Any content (support inline tags too.io).</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><span class='p h4 gray'>参数</span>  <ul><li>class: default / primary / success / info / warning / danger</li><li>color: default / blue / pink / red / purple / orange / green</li><li>style: simple/modern/flat/disabled</li></ul><span class='p h4 gray'>示例</span> <div class="note primary simple"><p>这是一条primary的note</p></div><div class="note success morden simple"><p>这是一条success morden-style的note</p></div><div class="note red fas icon-padding simple"><i class="note-icon fa-address-card"></i><p>这是一条red的自定义icon的note</p></div><div class="note blue flat"><p>这是一条no-icon 嵌套inline图片的note<img class="inline-img" src="https://i.loli.net/2021/03/19/5M4jUB3ynq7ePgw.png" style="height:50px"/></p></div><h1 id="11-上标标签-tip"><a href="#11-上标标签-tip" class="headerlink" title="11. 上标标签 tip"></a>11. 上标标签 tip</h1><p>把note改成tip即可<br>不太常用<br>详见<a href="https://akilar.top/posts/615e2dec/#上标标签-tip">上标标签tip示例</a></p><h1 id="12-动态标签"><a href="#12-动态标签" class="headerlink" title="12. 动态标签"></a>12. 动态标签</h1><p>太花哨了 写起来太麻烦了 懒得用<br>万一要用详见<a href="https://akilar.top/posts/615e2dec/#动态标签-anima">动态标签示例</a></p><h1 id="13-复选列表-checkbox"><a href="#13-复选列表-checkbox" class="headerlink" title="13. 复选列表 checkbox"></a>13. 复选列表 checkbox</h1><span class='p h4 gray'>语法</span> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% checkbox 样式参数（可选）, 文本（支持简单md） %&#125;</span><br></pre></td></tr></table></figure><span class='p h4 gray'>参数</span> <ul><li>样式: plus, minus, times</li><li>颜色: red,yellow,green,cyan,blue,gray</li><li>选中状态: checked<span class='p h4 gray'>示例</span> <div class='checkbox yellow checked'><input type="checkbox" checked="checked"/>            <p><strong>黄色 + 默认选中</strong></p>            </div><div class='checkbox times red checked'><input type="checkbox" checked="checked"/>            <p><em>叉</em></p>            </div><div class='checkbox blue'><input type="checkbox" />            <p>支持简单的 <a href="https://guides.github.com/features/mastering-markdown/">markdown</a> 语法</p>            </div></li></ul><h1 id="14-单选列表-radio"><a href="#14-单选列表-radio" class="headerlink" title="14.单选列表 radio"></a>14.单选列表 radio</h1><span class='p h4 gray'>语法</span> <p>把 checkbox 换成radio<br>但是没有样式了<br><span class='p h4 gray'>示例</span><br><div class='checkbox cyan'><input type="radio" />            <p>青色</p>            </div></p><h1 id="15-进度条-progress"><a href="#15-进度条-progress" class="headerlink" title="15.进度条 progress"></a>15.进度条 progress</h1><span class='p h4 gray'>语法</span> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% progress [width] [color] [text] %&#125;</span><br></pre></td></tr></table></figure><span class='p h4 gray'>示例</span> <div class="progress"><div class="progress-bar-animated progress-bar progress-bar-striped bg-red"  style="width: 10%" aria-valuenow="10" aria-valuemin="0" aria-valuemax="100"><p>10%进度条样式预览</p></div></div><div class="progress"><div class="progress-bar-animated progress-bar progress-bar-striped bg-yellow"  style="width: 30%" aria-valuenow="30" aria-valuemin="0" aria-valuemax="100"><p>30%进度条样式预览</p></div></div><div class="progress"><div class="progress-bar-animated progress-bar progress-bar-striped bg-green"  style="width: 50%" aria-valuenow="50" aria-valuemin="0" aria-valuemax="100"><p>50%进度条样式预览</p></div></div><div class="progress"><div class="progress-bar-animated progress-bar progress-bar-striped bg-cyan"  style="width: 70%" aria-valuenow="70" aria-valuemin="0" aria-valuemax="100"><p>70%进度条样式预览</p></div></div><div class="progress"><div class="progress-bar-animated progress-bar progress-bar-striped bg-blue"  style="width: 90%" aria-valuenow="90" aria-valuemin="0" aria-valuemax="100"><p>90%进度条样式预览</p></div></div><div class="progress"><div class="progress-bar-animated progress-bar progress-bar-striped bg-gray"  style="width: 100%" aria-valuenow="100" aria-valuemin="0" aria-valuemax="100"><p>100%进度条样式预览</p></div></div><h1 id="16-卡片链接-link"><a href="#16-卡片链接-link" class="headerlink" title="16.卡片链接 link"></a>16.卡片链接 link</h1><span class='p h4 gray'>语法</span> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% link 标题, 链接, 图片链接（可选） %&#125;</span><br></pre></td></tr></table></figure><div class="note danger simple"><p>插件好像有错，待解决</p></div><h1 id="17-网站卡片链接（带封面）-sitegroup"><a href="#17-网站卡片链接（带封面）-sitegroup" class="headerlink" title="17.网站卡片链接（带封面） sitegroup"></a>17.网站卡片链接（带封面） sitegroup</h1><p>可连续多张<br><span class='p h4 gray'>语法</span><br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% sitegroup %&#125;</span><br><span class="line">&#123;% site 标题, url=链接, screenshot=截图链接, avatar=头像链接（可选）, description=描述（可选） %&#125;</span><br><span class="line">&#123;% site 标题, url=链接, screenshot=截图链接, avatar=头像链接（可选）, description=描述（可选） %&#125;</span><br><span class="line">&#123;% endsitegroup %&#125;</span><br></pre></td></tr></table></figure><br><span class='p h4 gray'>示例</span><br><div class="site-card-group"><a class="site-card" href="https://wzy2002.vercel.app"><div class="img"><img src="/img/shoot1.png"/></div><div class="info"><img src="/img/noritake/da.jpg"/><span class="title">Serein</span><span class="desc">吴振扬的小站</span></div></a><a class="site-card" href="https://boileddog.top"><div class="img"><img src="/img/shot3.png"/></div><div class="info"><img src="/img/g.jpeg"/><span class="title">来日方长</span><span class="desc">好兄弟飞哥的小站</span></div></a><a class="site-card" href="https://space.bilibili.com/31071444?from=search&seid=12255624408130824120&spm_id_from=333.337.0.0"><div class="img"><img src="/img/shot2.png"/></div><div class="info"><img src="/img/qianye.webp"/><span class="title">千叶结锤</span><span class="desc">最喜欢的up主</span></div></a><a class="site-card" href="https://www.dandyweng.com"><div class="img"><img src="/img/wtx.png"/></div><div class="info"><img src="/img/wtx.jpeg"/><span class="title">翁天信</span><span class="desc">向大佬学习</span></div></a></div></p><h1 id="18-长条按钮链接-button"><a href="#18-长条按钮链接-button" class="headerlink" title="18.长条按钮链接 button"></a>18.长条按钮链接 button</h1><span class='p h4 gray'>语法</span> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% btn [url],[text],[icon],[color] [style] [layout] [position] [size] %&#125;</span><br></pre></td></tr></table></figure><span class='p h4 gray'>参数</span> <p>[url]         : 鏈接<br>[text]        : 按鈕文字<br>[icon]        : [可選] 圖標<br>[color]       : [可選] 按鈕背景顔色(默認style時）<br>                      按鈕字體和邊框顔色(outline時)<br>                      default/blue/pink/red/purple/orange/green<br>[style]       : [可選] 按鈕樣式 默認實心<br>                      outline/留空<br>[layout]      : [可選] 按鈕佈局 默認為line<br>                      block/留空<br>[position]    : [可選] 按鈕位置 前提是設置了layout為block 默認為左邊<br>                      center/right/留空<br>[size]        : [可選] 按鈕大小<br>                      larger/留空<br><span class='p h4 gray'>示例</span><br><a class="btn-beautify blue outline" href="https://wzy2002.vercel.app/"   title="Serein"><i class="fas fa-address-card"></i><span>Serein</span></a></p><h1 id="19-图片按钮链接-btns"><a href="#19-图片按钮链接-btns" class="headerlink" title="19.图片按钮链接 btns"></a>19.图片按钮链接 btns</h1><span class='p h4 gray'>语法</span> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% btns 样式参数 %&#125;</span><br><span class="line">&#123;% cell 标题, 链接, 图片或者图标 %&#125;</span><br><span class="line">&#123;% cell 标题, 链接, 图片或者图标 %&#125;</span><br><span class="line">&#123;% endbtns %&#125;</span><br></pre></td></tr></table></figure><span class='p h4 gray'>参数</span> <ol><li>圆角样式：rounded, circle</li><li>增加文字样式：可以在容器内增加 <b>标题</b>和<p>描述文字</p></li><li>布局方式：默认为自动宽度，适合视野内只有一两个的情况。</li></ol><div class="table-container"><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>wide</td><td>宽一点的按钮</td></tr><tr><td>fill</td><td>填充布局，自动铺满至少一行，多了会换行</td></tr><tr><td>center</td><td>居中，按钮之间是固定间距</td></tr><tr><td>around</td><td>居中分散</td></tr><tr><td>grid2</td><td>等宽最多2列，屏幕变窄会适当减少列数</td></tr><tr><td>grid3</td><td>等宽最多3列，屏幕变窄会适当减少列数</td></tr><tr><td>grid4</td><td>等宽最多4列，屏幕变窄会适当减少列数</td></tr><tr><td>grid5</td><td>等宽最多5列，屏幕变窄会适当减少列数</td></tr></tbody></table></div><span class='p h4 gray'>示例</span> <div class="tabs" id="按钮"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#按钮-1">wide</button></li><li class="tab"><button type="button" data-href="#按钮-2">fill</button></li><li class="tab"><button type="button" data-href="#按钮-3">center</button></li><li class="tab"><button type="button" data-href="#按钮-4">around</button></li><li class="tab"><button type="button" data-href="#按钮-5">grid3</button></li><li class="tab"><button type="button" data-href="#按钮-6">grid4</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="按钮-1"><div class="btns wide rounded">            <a class="button" href='https://wzy2002.vercel.app/' title='Serein'><img src='/img/noritake/da.jpg'>Serein</a><a class="button" href='https://boileddog.top/' title='飞哥的小站'><img src='/img/g.jpeg'>飞哥的小站</a><a class="button" href='https://blog.zhheo.com' title='张洪heo-大佬'><img src='/img/heo.png'>张洪heo-大佬</a>          </div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="按钮-2"><div class="btns fill rounded">            <a class="button" href='https://wzy2002.vercel.app/' title='Serein'><img src='/img/noritake/da.jpg'>Serein</a><a class="button" href='https://boileddog.top/' title='飞哥的小站'><img src='/img/g.jpeg'>飞哥的小站</a><a class="button" href='https://blog.zhheo.com' title='张洪heo-大佬'><img src='/img/heo.png'>张洪heo-大佬</a>          </div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="按钮-3"><div class="btns center rounded">            <a class="button" href='https://wzy2002.vercel.app/' title='Serein'><img src='/img/noritake/da.jpg'>Serein</a><a class="button" href='https://boileddog.top/' title='飞哥的小站'><img src='/img/g.jpeg'>飞哥的小站</a><a class="button" href='https://blog.zhheo.com' title='张洪heo-大佬'><img src='/img/heo.png'>张洪heo-大佬</a>          </div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="按钮-4"><div class="btns around rounded">            <a class="button" href='https://wzy2002.vercel.app/' title='Serein'><img src='/img/noritake/da.jpg'>Serein</a><a class="button" href='https://boileddog.top/' title='飞哥的小站'><img src='/img/g.jpeg'>飞哥的小站</a><a class="button" href='https://blog.zhheo.com' title='张洪heo-大佬'><img src='/img/heo.png'>张洪heo-大佬</a>          </div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="按钮-5"><div class="btns grid3 rounded">            <a class="button" href='https://wzy2002.vercel.app/' title='Serein'><img src='/img/noritake/da.jpg'>Serein</a><a class="button" href='https://boileddog.top/' title='飞哥的小站'><img src='/img/g.jpeg'>飞哥的小站</a><a class="button" href='https://blog.zhheo.com' title='张洪heo-大佬'><img src='/img/heo.png'>张洪heo-大佬</a>          </div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="按钮-6"><div class="btns grid4 rounded">            <a class="button" href='https://wzy2002.vercel.app/' title='Serein'><img src='/img/noritake/da.jpg'>Serein</a><a class="button" href='https://boileddog.top/' title='飞哥的小站'><img src='/img/g.jpeg'>飞哥的小站</a><a class="button" href='https://blog.zhheo.com' title='张洪heo-大佬'><img src='/img/heo.png'>张洪heo-大佬</a>          </div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><span class='p h4 gray'>插入html标签</span> <div class="tabs" id="插入html"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#插入html-1">插入文字</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="插入html-1"><div class="btns center rounded grid3">            <a href='https://apps.apple.com/cn/app/heart-mate-pro-hrm-utility/id1463348922?ls=1'>  <b>来日方长</b>  <p class='p green'>飞哥的小站</p>  <img src='/img/g.jpeg'  ></a><a href='https://wzy2002.vercel.app/'  >  <b>Serein</b>  <p class='p green'>帅扬的小站</p>  <img src='/img/noritake/da.jpg'></a><a href=""><p class='p green'>帅扬的微信</p><img src="/img/wx.jpeg"></a>          </div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><div class="note danger simple"><p>若自定义html 则在<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% btns center rounded grid3  %&#125;</span><br><span class="line">&#123;% endbtns %&#125; </span><br></pre></td></tr></table></figure><br>与中间代码处不该有空隙</p></div><h1 id="20-音频测试-aduio"><a href="#20-音频测试-aduio" class="headerlink" title="20.音频测试 aduio"></a>20.音频测试 aduio</h1><span class='p h4 gray'>语法</span> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% audio 音频链接 %&#125;</span><br></pre></td></tr></table></figure><span class='p h4 gray'>示例</span> <div class="audio"><audio controls preload><source src='/img/music/yuehui.mp3' type='audio/mp3'>Your browser does not support the audio tag.</audio></div><div class="audio"><audio controls preload><source src='/music/硬币硬币.mp3' type='audio/mp3'>Your browser does not support the audio tag.</audio></div><h1 id="21-视频测试-video"><a href="#21-视频测试-video" class="headerlink" title="21.视频测试 video"></a>21.视频测试 video</h1><span class='p h4 gray'>语法</span> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">单个视频</span><br><span class="line">&#123;% video 视频链接 %&#125;</span><br><span class="line">多个视频</span><br><span class="line">&#123;% videos,数量 %&#125;</span><br><span class="line">&#123;% video 视频链接 %&#125;</span><br><span class="line">&#123;% video 视频链接 %&#125;</span><br><span class="line">&#123;% endvideos %&#125;</span><br></pre></td></tr></table></figure><span class='p h4 gray'>示例</span> <p>单个视频</p><div class="video"><video controls preload><source src='/vedio/蛋糕.mp4' type='video/mp4'>Your browser does not support the video tag.</video></div><p>多个视频</p><div class="videos" col='4'><div class="video"><video controls preload><source src='/vedio/吉吉.mp4' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='/vedio/飞哥爆踹.avi' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='/vedio/杰宇.mp4' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='/vedio/冲撞.avi' type='video/mp4'>Your browser does not support the video tag.</video></div></div><p class='p h4'>(站长的高中生活'◡')</p><h1 id="22-诗词-poem"><a href="#22-诗词-poem" class="headerlink" title="22.诗词 poem"></a>22.诗词 poem</h1><span class='p h4 gray'>语法</span><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% poem [title],[author] %&#125;</span><br><span class="line">诗词内容</span><br><span class="line">&#123;% endpoem %&#125;</span><br></pre></td></tr></table></figure><span class='p h4 gray'>示例</span> <div class='poem'><div class='poem-title'>青玉案 元夕</div><div class='poem-author'>辛弃疾</div><p>东风夜放花千树。<br>更吹落、星如雨。<br>宝马雕车香满路。<br>凤箫声动，玉壶光转，<br>一夜鱼龙舞。<br>蛾儿雪柳黄金缕。<br>笑语盈盈暗香去。<br>众里寻他千百度。<br>蓦然回首，那人却在，<br>灯火阑珊处。</p></div><h1 id="23-时间轴"><a href="#23-时间轴" class="headerlink" title="23.时间轴"></a>23.时间轴</h1><p>标记一下 太麻烦 不太可能用到<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% timeline title,color %&#125;</span><br><span class="line">&lt;!-- timeline title --&gt;</span><br><span class="line">xxxxx</span><br><span class="line">&lt;!-- endtimeline --&gt;</span><br><span class="line">&lt;!-- timeline title --&gt;</span><br><span class="line">xxxxx</span><br><span class="line">&lt;!-- endtimeline --&gt;</span><br><span class="line">&#123;% endtimeline %&#125;</span><br></pre></td></tr></table></figure><br><div class="timeline undefined"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>测试</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>01-02</p></div></div><div class='timeline-item-content'><p>这是测试页面1</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>01-03</p></div></div><div class='timeline-item-content'><p>这是测试页面2</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>02 - 6</p></div></div><div class='timeline-item-content'><p>这是测试页面2</p></div></div></div></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>关于本站</title>
      <link href="/2021/09/03/%E5%85%B3%E4%BA%8E/"/>
      <url>/2021/09/03/%E5%85%B3%E4%BA%8E/</url>
      
        <content type="html"><![CDATA[<p><span>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;</span><strong><span class='p ultra'>源于</span><span class='p ultra blue'>热爱</span></strong><br><span>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;</span><strong><span class='p ultra'>所以</span><span class='p ultra blue'>创造</span></strong><br><br /></p><p><span>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;</span><span class='p h4'>你好啊，我是吴振扬</span><br>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;<span class='p h4'>一个热爱自由与探索的年轻人</span><br>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;<span class='p h4'>爱好编程、摄影、设计</span><br><br /></p><p><br /></p><p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;<span class='p h4'>从小我就对新鲜的事物充满了好奇心</span><br>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;<span class='p h4'>想将数字与字符编码</span><br>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;<span class='p h4'>发挥自己的能力去编写与创造</span><img src="/img/sheying/15.jpg" width=350 align="right"><br>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;<span class='p h4'>想拿起相机，按下快门</span><br>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;<span class='p h4'>把当下的美好与感动带给更多的人</span><br>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;<span class='p h4'>慢慢的我学会记录，珍惜脚下的每一步</span><br><br /></p><p><br /></p><p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;<span class='p h4'>我敬佩翁天信的勇敢与胆识</span><br>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;<span class='p h4'>被他的经历与坚守的信条所吸引</span><br>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;<span class='p h4'>同时也庆幸自己在人生的黄金时代</span><br>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;<span class='p h4'>发现并坚定什么是自己所追求的</span><br><br /></p><p><br /><br><img src="/img/sheying/14.jpg" width=350 align="right"><br>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;<span class='p h4'>我不断想把自己的所想所爱结合起来</span><br>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;<span class='p h4'>于是便有了这个网站</span><br>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;<span class='p h4'>它是一次尝试，也希望是此后人生的铺垫</span><br>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;<span class='p h4'>愿能记录下自己的成长与所见所闻</span><br>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;<span class='p h4'>在许多年后回想这一路不是孤单与漫长</span><br>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;<span class='p h4'>而是波浪壮阔的海与满天闪烁的星光</span><br><br /></p><p><br /></p><p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;<span class='p h4'>嗨，有缘人</span><br>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;<span class='p h4'>感谢你能看到这</span><br>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;<span class='p h4'>在我十八岁的结尾我写下这段话</span><br>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;<span class='p h4'>愿，我们初心不忘</span></p><p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;<span class='p h4'>共勉</span></p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
